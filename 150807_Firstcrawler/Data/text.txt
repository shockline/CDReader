http://blog.csdn.net/okcd00/article/details/47004995	前言 爬虫第一步，Python纸尿裤之前的电话面试中被问到了是否会爬虫，简单的就行啊，爬虫爬虫……我还是自学个最简单的吧，至少得理解下这是啥意思啥原理吧于是，照葫芦画瓢……试试看咯，顺带记录在这里备忘，毕竟是第一次用，请允许我逐行百度逐词谷歌所以就变成了这个完全注释版——二话不说上代码#coding=utf-8 import urllibimport re def downloadPage(url):h = urllib.urlopen(url)return h.read()def downloadImg(content):pattern = r'src="(.+?\.jpg)" pic_ext'm = re.compile(pattern)urls = re.findall(m, content)for i, url in enumerate(urls):print("Saving %s.jpg ...... from %s" % (i,url) + '\n')urllib.urlretrieve(url, "%s.jpg" % (i, ))content = downloadPage("http://tieba.baidu.com/p/2460150866")downloadImg(content)修改倒数第二行的url就可以自定义需要下载的页面。然后慢悠悠解释（给自己听）#coding=utf-8什么你问我这句？啊这是注释，嗯注释。提醒你请用UTF-8打开哦import urllib在这里用到了Urllib库里的两个函数——urllib.urlopen(url[,data[,proxies]])>>> import urllib>>> f = urllib.urlopen('http://www.google.com.hk/')>>> firstLine = f.readline()   #读取html页面的第一行>>> firstLine'<!doctype html><html itemscope="" itemtype="http://schema.org/WebPage"><head><meta content="/images/google_favicon_128.png" itemprop="image"><title>Google</title><script>(function(){\n'urlopen返回对象提供方法：-         read() , readline() ,readlines() , fileno() , close() ：这些方法的使用方式与文件对象完全一样-         info()：返回一个httplib.HTTPMessage对象，表示远程服务器返回的头信息-         getcode()：返回Http状态码。如果是http请求，200请求成功完成;404网址未找到-         geturl()：返回请求的urlurllib.urlretrieve(url[,filename[,reporthook[,data]]])urlretrieve方法将url定位到的html文件下载到你本地的硬盘中。如果不指定filename，则会存为临时文件。urlretrieve()返回一个二元组(filename,mine_hdrs)以下为示例代码 [引用]临时存放>>> filename = urllib.urlretrieve('http://www.google.com.hk/')>>> type(filename)<type 'tuple'>>>> filename[0]'/tmp/tmp8eVLjq'>>> filename[1]<httplib.HTTPMessage instance at 0xb6a363ec>存放于本地的用法>>> filename = urllib.urlretrieve('http://www.google.com.hk/',filename='/home/dzhwen/python文件/Homework/urllib/google.html')>>> type(filename)<type 'tuple'>>>> filename[0]'/home/dzhwen/python\xe6\x96\x87\xe4\xbb\xb6/Homework/urllib/google.html'>>> filename[1]<httplib.HTTPMessage instance at 0xb6e2c38c>import re正则表达式包的库文件，此处使用到了——re.findall()  # 根据正则表达式搜索字符串，将所有符合的子字符串放在一给表(list)中返回re.findall可以获取字符串中所有匹配的字符串。如：re.findall(r'\w*oo\w*', text)；获取字符串中，包含'oo'的所有单词。re.compile #可以把正则表达式编译成一个正则表达式对象。可以把那些经常使用的正则表达式编译成正则表达式对象，这样可以提高一定的效率。下面是一个正则表达式对象的一个例子：[引用]代码import retext = "JGood is a handsome boy, he is cool, clever, and so on..."regex = re.compile(r'\w*oo\w*')print regex.findall(text)   #查找所有包含'oo'的单词print regex.sub(lambda m: '[' + m.group(0) + ']', text) #将字符串中含有'oo'的单词用[]括起来。def downloadPage(url):在Python中，函数声明和函数定义是视为一体的。在Python中，函数定义的基本形式如下：def function(params):    block    return expression/value（1）在Python中采用def关键字进行函数的定义，不用指定返回值的类型。（2）函数参数params可以是零个、一个或者多个，同样的，函数参数也不用指定参数类型，因为在Python中变量都是弱类型的，Python会自动根据值来维护其类型。（3）return语句是可选的，它可以在函数体内任何地方出现，表示函数调用执行到此结束；如果没有return语句，会自动返回NONE，如果有return语句，但是return后面没有接表达式或者值的话也是返回NONE。h = urllib.urlopen(url)urllib.urlopen(url[, data[, proxies]]) :创建一个表示远程url的类文件对象，然后像本地文件一样操作这个类文件对象来获取远程数据。参数url表示远程数据的路径，一般是网址；参数data表示以post方式提交到url的数据(玩过web的人应该知道提交数据的两种方式：post与get。如果你不清楚，也不必太在意，一般情况下很少用到这个参数)；参数proxies用于设置代理。urlopen返回 一个类文件对象，它提供了如下方法：read() , readline() , readlines() , fileno() , close() ：这些方法的使用方式与文件对象完全一样;info()：返回一个httplib.HTTPMessage 对象，表示远程服务器返回的头信息getcode()：返回Http状态码。如果是http请求，200表示请求成功完成;404表示网址未找到；geturl()：返回请求的url；代码示例：[引用]import urlliburl = "http://www.baidu.com/"#urlopen()sock = urllib.urlopen(url)htmlCode = sock.read()sock.closefp = open("e:/1.html","wb")fp.write(htmlCode)fp.close#urlretrieve()urllib.urlretrieve(url, 'e:/2.html')return h.read()返回值，返回的为h所读取的内容。def downloadImg(content):定义函数Downloadimg，作用为下载传参的content中包含的jpg文件。pattern = r'src="(.+?\.jpg)" pic_ext'正则表达式的常用语法：[引用]1）单个字符:.          任意的一个字符a|b        字符a或字符b[afg]      a或者f或者g的一个字符        [0-4]      0-4范围内的一个字符[a-f]      a-f范围内的一个字符[^m]       不是m的一个字符\s         一个空格\S         一个非空格\d         [0-9]\D         [^0-9]\w         [0-9a-zA-Z]\W         [^0-9a-zA-Z]2）重复紧跟在单个字符之后，表示多个这样类似的字符*         重复 >=0 次+         重复 >=1 次?         重复 0或者1 次{m}       重复m次。比如说 a{4}相当于aaaa，再比如说[1-3]{2}相当于[1-3][1-3]{m, n}    重复m到n次。比如说a{2, 5}表示a重复2到5次。小于m次的重复，或者大于n次的重复都不符合条件。 正则表达          相符的字符串举例[0-9]{3,5}       9678a?b              ba+b              aaaaab 3) 位置^         字符串的起始位置$         字符串的结尾位置正则表达          相符的字符串举例        不相符字符串^ab.*c$          abeec               cabeec (如果用re.search(), 将无法找到。)4）返回控制我们有可能对搜索的结果进行进一步精简信息。比如下面一个正则表达式：output_(\d{4})该正则表达式用括号()包围了一个小的正则表达式，\d{4}。 这个小的正则表达式被用于从结果中筛选想要的信息（在这里是四位数字）。这样被括号圈起来的正则表达式的一部分，称为群(group)。我们可以m.group(number)的方法来查询群。group(0)是整个正则表达的搜索结果，group(1)是第一个群……import rem = re.search("output_(\d{4})", "output_1986.txt")print(m.group(1)) 我们还可以将群命名，以便更好地使用m.group查询:import rem = re.search("output_(?P<year>\d{4})", "output_1986.txt")   #(?P<name>...) 为group命名print(m.group("year")) m = re.compile(pattern)re.compile(pattern, flags=0)编译正则表达式，返回RegexObject对象，然后可以通过RegexObject对象调用match()和search()方法。prog = re.compile(pattern)result = prog.match(string)跟result = re.match(pattern, string)是等价的。第一种方式能实现正则表达式的重用。urls = re.findall(m, content)re.findall(pattern, string, flags=0)找到 RE 匹配的所有子串，并把它们作为一个列表返回。这个匹配是从左到右有序地返回。如果无匹配，返回空列表。>>> re.findall("a","bcdef") []>>> re.findall(r"\d+","12a32bc43jf3") ['12', '32', '43', '3']for i, url in enumerate(urls):遍历， for var in array 是py中常用的便捷句式for语句是python中的循环控制语句。可用来遍历某一对象，还具有一个附带的可选的else块，主要用于处理for语句中包含的break语句。如果for循环未被break终止，则执行else块中的语句。break 在需要时终止for循环continue 跳过位于其后的语句，开始下一轮循环。for语句的格式如下：[引用]>>>for <> in <对象集合>：...    if <条件>:...        break...    if <条件>:...        continue...    <其他语句>...else:...    <>...print("Saving %s.jpg ...... from %s" % (i,url) + '\n')显示一下保存到第几张图了，顺带告诉一下这张图的url地址，打印在控制台上。urllib.urlretrieve(url, "%s.jpg" % (i, ))直接将远程数据下载到本地。urllib.urlretrieve(url[, filename[, reporthook[, data]]])参数说明：url：外部或者本地urlfilename：指定了保存到本地的路径（如果未指定该参数，urllib会生成一个临时文件来保存数据）；reporthook：是一个回调函数，当连接上服务器、以及相应的数据块传输完毕的时候会触发该回调。我们可以利用这个回调函数来显示当前的下载进度。data：指post到服务器的数据。该方法返回一个包含两个元素的元组(filename, headers)，filename表示保存到本地的路径，header表示服务器的响应头。下面通过例子来演示一下这个方法的使用，这个例子将新浪首页的html抓取到本地，保存在D:/sina.html文件中，同时显示下载的进度。[引用]import urllibdef callbackfunc(blocknum, blocksize, totalsize):    '''回调函数    @blocknum: 已经下载的数据块    @blocksize: 数据块的大小    @totalsize: 远程文件的大小    '''    percent = 100.0 * blocknum * blocksize / totalsize    if percent > 100:        percent = 100    print "%.2f%%"% percenturl = 'http://www.sina.com.cn'local = 'd:\\sina.html'urllib.urlretrieve(url, local, callbackfunc)content = downloadPage("http://tieba.baidu.com/p/2460150866")调用函数传参Url，这里是一个有一些不错图片的百度贴吧文章地址downloadImg(content)调用downloadimg函数，下载地址中的jpg版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/46987259	前言其实说起初衷，是之前吾辈的学校开展了个数模比赛，我去帮别人当帮手，当时的B题是基因拼接，D题是污染程度评定作为ACMer，我当然喜欢B题这种像ACM竞赛题一样感觉的东西，但无奈人家才是参(da)赛(ye)者(a)，他们选了D，嘛，其实据说那次我做的也还是不错。回到正题，于是我就开始考虑这种算法改如何实现呢，反正现在是学生，在CNKI上看论文不要钱，到处看看咯。看到个论文，用dp实现生物序列最短公共超序列，感觉靠谱，要不然就试试呗，拿来当模板用，说不定哪天就出道题呢~给他起了个名儿SCMS = Shortest Common Mother-Sequence (最短公共母序列)建模可以将题意理解为ACM格式，则为如下情况：数据组数为T，【给出T】每组数据中有n条基因序列，【给出N】以下则为n行，每行以一个字符串表示一条基因序列的组成【给出str_i】【每条基因序列均为母序列中的一个子片段，此处的子片段指的是子串而非子序列】（给自己降低一点难度嘛不要在意）要求输出满足所有这些基因序列的母序列。代码实现(C/C++)#include<stdio.h>#include<string.h>struct str{    char letter[1600];    int len;}ans,a[20];struct{    struct str temp;    int x,y;}add[500];int f[1<<12][15],father[1<<12][15],reduce[20][20],cost[20][20],n,m,max,Test,s;struct str ADD(struct str ans,int k,int reduce){    int i;    for(i=ans.len;i<ans.len+a[k].len-reduce;i++)        ans.letter[i]=a[k].letter[reduce+i-ans.len];    ans.letter[i]=0;    ans.len=ans.len+a[k].len-reduce;    return ans;}void quick(int l,int r){    int i=l,j=r;    struct str x=add[(i+j)>>1].temp;    while(i<=j)    {        while(strcmp(add[i].temp.letter,x.letter)<0)  i++;        while(strcmp(add[j].temp.letter,x.letter)>0)  j--;        if(i<=j)        {            add[0]=add[i],add[i]=add[j],add[j]=add[0];            i++,j--;        }    }    if(i<r)  quick(i,r);    if(j>l)  quick(l,j);}void READY(){    int i,j,k,r;    for(i=1;i<=n;i++)        for(j=1;j<=n;j++)            for(k=0;k<a[i].len;k++)            {                for(r=0;k+r<a[i].len&&a[i].letter[k+r]==a[j].letter[r];r++);                if(k+r==a[i].len)                {                    reduce[j][i]=r;                    break;                }            }    s=0;    for(i=1;i<=n;i++)        for(j=1;j<=n;j++)        {            s++;            add[s].temp=ADD(a[i],j,reduce[j][i]),add[s].x=i,add[s].y=j;        }    quick(1,s);    for(i=1;i<=s;i++)        cost[add[i].x][add[i].y]=i;}void read(){    int i,j,k,r;    scanf("%d",&n);    memset(reduce,0,sizeof(reduce));    for(i=1;i<=n;i++)    {        scanf("%s",a[i].letter);        a[i].len=strlen(a[i].letter);    }    for(i=1;i<=n;i++)        for(j=1;j<=n;j++)        {            if(i==j)  continue;                             for(k=0;k<a[j].len;k++)            {                for(r=0;r+k<a[j].len&&r<a[i].len&&a[j].letter[k+r]==a[i].letter[r];r++);                if(r==a[i].len)  break;            }            if(k<a[j].len)  a[i].letter[0]=0;        }    for(i=n;i>=1;i--)        if(a[i].letter[0]==0)        {            for(j=i;j<n;j++)                a[j]=a[j+1];            n--;        }    m=(1<<n)-1;}void DP(){    int i,j,k;    for(i=0;i<=m;i++)        for(j=1;j<=n;j++)            f[i][j]=father[i][j]=0;    for(i=1;i<=m;i++)        for(j=1;j<=n;j++)        {            int add=1<<(j-1);            if((i&add)==0)                for(k=1;k<=n;k++)                    if((i&(1<<(k-1)))!=0)                    {                        if(father[i+add][j]==0)                        {                            f[i+add][j]=f[i][k]+reduce[k][j],father[i+add][j]=k;                            continue;                        }                        if(f[i+add][j]<f[i][k]+reduce[k][j])                            f[i+add][j]=f[i][k]+reduce[k][j],father[i+add][j]=k;                        else if(f[i+add][j]==f[i][k]+reduce[k][j]&&cost[j][father[i+add][j]]>cost[j][k])                            father[i+add][j]=k;                    }        }}void solve(){    max=-1;    int i,j,now;    for(i=1;i<=n;i++)    {        if(max<f[m][i])        {            max=f[m][i],now=m;            ans=a[i];            for(j=i;father[now][j]!=0;)            {                ans=ADD(ans,father[now][j],reduce[father[now][j]][j]);                int t=j;                j=father[now][j],now-=(1<<(t-1));            }        }        else if(max==f[m][i])        {            struct str temp=a[i];            now=m;            for(j=i;father[now][j]!=0;)            {                temp=ADD(temp,father[now][j],reduce[father[now][j]][j]);                int t=j;                j=father[now][j],now-=(1<<(t-1));            }            if(strcmp(ans.letter,temp.letter)>0)  ans=temp;        }    }}int main(){    int T=0;    scanf("%d",&T);    for(int i=1;i<=T;i++)    {read();READY();DP();solve();printf("%s\n",ans.letter);    }    return 0;}Reference参阅的论文如下，关于证明过程和各种条件约束详见论文： 《两个生物序列最短公共超序列的动态规划算法》黄永莲1, 孙世军2 (1.湛江师范学院生物科学与化学学院,广东湛江524048;   2.湛江师范学院信息科技学院,广东湛江524048)摘要:将动态规划算法用于两个生物序列的最短公共超序列的计算。计算过程分为两个算法,第一个算法计算两个序列的所有前缀的最短公共超序列的长度,并存放在一个矩阵中,第二个算法利用前面所得的矩阵,找到两个序列的最短公共超序列。关键词:生物序列;动态规划算法;超序列;最短公共超序列中图分类号:Q-31   文献标识码:A   文章编号:1671-0231(2005)03-0063-03版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/46975783	前言在ICT实习获得的第一个任务与中文分词有关，本想用Stanford中文分词器，苦于VirtualBox中的Ubuntu跑Stanford的中文分词程序的时候会出现OSError: Java Command Failed 的错误。负责OS这方面的队友在纠结不前之时，老师提醒了我：为什么不去试试别的分词器呢？网上搜索了一下中文分词，一眼看到这个ICTCLAS，哈哈哈我正在这里实习为何不试试看呢？CSDN上花了不少积分，PUDN上也花了不少积分，下载开发文档和看配置blog也花了不少时间……大家得出的结论似乎都是“难配”，“错误多”，“不知道什么问题”……我也几乎把这些提及的问题都遇到了个遍……心灰意冷之时发现，官网的最新package下载好了，反正那么大呢，下载下来还是试试看吧官网链接传送门来一个里面的java包，C++包果然还是因为本人比较愚昧一个是一直报错一个是不知道怎么打开……灵光一闪看到了Python示例，就试试吧，毕竟python是解释性语言，依葫芦画瓢试试看好了，随手敲了一些，上网找了个文件输入输出的例子照着做……然后，居然就成功了……配置文件树如下2015/07/20  23:16    <DIR>          .2015/07/20  23:16    <DIR>          ..2015/07/20  19:19    <DIR>          Data2015/07/20  20:31               511 infile.txt2015/07/20  20:32    <DIR>          nlpir2015/07/20  23:22             8,737 nlpir.py2015/07/20  23:22               649 outfile.txt2014/01/03  09:42               332 Readme.txt2015/07/20  20:45    <DIR>          Support2014/01/02  17:41                 0 __init__.py               5 个文件         10,229 字节               5 个目录  2,904,150,016 可用字节[DIR>DATA]2015/07/20  20:32    <DIR>          .2015/07/20  20:32    <DIR>          ..2014/12/25  14:58                92 20141225.err2012/05/18  21:36           286,196 BIG2GBK.map2012/05/18  21:33           468,456 BIG5.pdat2012/05/18  21:33           158,695 BIG5.wordlist2009/01/16  13:48         3,520,144 BiWord.big2012/11/08  20:45            65,540 charset.type2015/06/03  12:52             3,356 classifier.user2015/06/03  12:53             3,356 cluster.user2014/10/31  13:58             1,084 Configure.xml2009/01/16  13:48         1,696,620 CoreDict.pdat2009/01/16  13:48         1,786,424 CoreDict.pos2009/01/16  13:48           478,168 CoreDict.unig2015/06/03  12:53             3,356 DocExtractor.user2015/07/20  20:32    <DIR>          English2014/03/23  20:10           380,016 FieldDict.pdat2014/03/23  20:10            27,257 FieldDict.pos2014/03/23  14:55           546,720 FTU8.pdat2014/03/23  14:55           190,687 FTU8.wordlist2014/03/23  14:55           286,196 FTU82GBK.map2012/05/18  21:34           549,204 GBK.pdat2012/05/18  21:34           166,985 GBK.wordlist2012/05/18  21:36           286,196 GBK2BIG.map2014/03/23  14:55           286,196 GBK2FTU8.map2012/05/18  21:37           286,196 GBK2GBKC.map2012/05/18  21:37           286,196 GBK2UTF.map2012/12/22  11:50           550,848 GBKA.pdat2012/12/22  11:50           166,985 GBKA.wordlist2012/12/22  11:50           286,196 GBKA2UTF.map2012/05/18  21:34           550,848 GBKC.pdat2012/05/18  21:34           166,985 GBKC.wordlist2012/05/18  21:37           286,196 GBKC2GBK.map2009/01/16  13:48         1,978,128 GranDict.pdat2009/01/16  13:48         1,778,776 GranDict.pos2014/01/03  10:39               422 ICTPOS.map2015/06/03  12:52             3,356 keyExtract.user2014/03/18  13:27             3,356 LJHtmlParser.user2014/03/12  12:47            79,412 location.map2014/03/12  12:46           416,748 location.pdat2014/03/12  12:47           106,165 location.wordlist2014/08/12  10:51             5,100 NewWord.lst2009/01/16  13:48            37,253 NLPIR.ctx2015/07/01  14:48             3,356 NLPIR.user2009/01/16  13:48               288 NLPIR_First.map2012/11/14  15:57             3,356 NLPIR_trial.user2009/01/16  13:48             2,213 nr.ctx2009/01/16  13:48             3,008 nr.fsa2009/01/16  13:48         1,757,200 nr.role2014/01/09  15:24               323 PKU.map2014/01/09  15:24               300 PKU_First.map2013/09/16  13:32           854,520 sentiment.pdat2013/09/16  13:33            88,000 sentiment.ung2015/06/03  12:53             3,356 summary.user2014/08/12  10:30            33,620 UserDict.pdat2014/03/23  14:02           286,196 UTF2GBK.map2012/12/22  11:50           286,196 UTF2GBKA.map2012/05/18  21:33           557,268 UTF8.pdat2012/05/18  21:33           190,690 UTF8.wordlist              56 个文件     22,250,000 字节               3 个目录  2,904,150,016 可用字节[DIR>NLPIR]2015/07/20  20:32    <DIR>          .2015/07/20  20:32    <DIR>          ..2013/03/20  09:46         1,027,819 libNLPIR32.so2013/12/20  13:32         2,014,184 libNLPIR64.so2013/12/19  21:15            21,533 NLPIR.h2013/12/19  20:51         1,684,992 NLPIR32.dll2013/12/19  20:51            11,636 NLPIR32.lib2014/01/01  21:07         2,301,952 NLPIR64.dll2014/01/01  21:07            11,678 NLPIR64.lib2013/11/08  16:48               156 Readme.txt               8 个文件      7,073,950 字节               2 个目录  2,904,150,016 可用字节[DATA>SUPPORT]2015/07/20  20:45    <DIR>          .2015/07/20  20:45    <DIR>          ..2015/07/17  16:11             2,737 Anti-Simply.cpp2015/07/17  20:50               478 Count.cpp2015/07/17  23:49               477 FileTest.cpp2015/07/17  13:51               447 Multifile_Test.cpp2015/07/20  20:44                87 Readme.md2015/07/17  16:58             2,848 Simply.cpp               6 个文件          7,074 字节               2 个目录  2,904,150,016 可用字节代码Python修改后可运行代码如下# -*- coding: UTF-8 -*-__author__ = 'Peter_Howe<haobibo@gmail.com>''''Python Warpper for ICTCLAS2014Loading functions from Dynamic Link Library  directly.'''from ctypes import *#NLPIR2014 Lib File (NLPIR64, NLPIR32, libNLPIR64.so, libNLPIR32.so),#Change this when you are not using a Win64 environment:libFile = './nlpir/NLPIR64.dll'dll =  CDLL(libFile)def loadFun(exportName, restype, argtypes):    global dll    f = getattr(dll,exportName)    f.restype = restype    f.argtypes = argtypes    return fclass ENCODING:    GBK_CODE        =   0               #默认支持GBK编码    UTF8_CODE       =   GBK_CODE+1      #UTF8编码    BIG5_CODE       =   GBK_CODE+2      #BIG5编码    GBK_FANTI_CODE  =   GBK_CODE+3      #GBK编码，里面包含繁体字class POSMap:    ICT_POS_MAP_SECOND  = 0 #计算所二级标注集    ICT_POS_MAP_FIRST   = 1 #计算所一级标注集    PKU_POS_MAP_SECOND  = 2 #北大二级标注集    PKU_POS_MAP_FIRST   = 3#北大一级标注集POS = {"n": {  #1.名词  (1个一类，7个二类，5个三类)"n":"名词","nr":"人名","nr1":"汉语姓氏","nr2":"汉语名字","nrj":"日语人名","nrf":"音译人名","ns":"地名","nsf":"音译地名","nt":"机构团体名","nz":"其它专名","nl":"名词性惯用语","ng":"名词性语素"},"t": {  #2.时间词(1个一类，1个二类)"t":"时间词","tg":"时间词性语素"},"s": {  #3.处所词(1个一类)"s":"处所词"},"f": {  #4.方位词(1个一类)"f":"方位词"},"v": {  #5.动词(1个一类，9个二类)"v":"动词","vd":"副动词","vn":"名动词","vshi":"动词“是”","vyou":"动词“有”","vf":"趋向动词","vx":"形式动词","vi":"不及物动词（内动词）","vl":"动词性惯用语","vg":"动词性语素"},"a": {  #6.形容词(1个一类，4个二类)"a":"形容词","ad":"副形词","an":"名形词","ag":"形容词性语素","al":"形容词性惯用语"},"b": {  #7.区别词(1个一类，2个二类)"b":"区别词","bl":"区别词性惯用语"},"z": {  #8.状态词(1个一类)"z":"状态词"},"r": {  #9.代词(1个一类，4个二类，6个三类)"r":"代词","rr":"人称代词","rz":"指示代词","rzt":"时间指示代词","rzs":"处所指示代词","rzv":"谓词性指示代词","ry":"疑问代词","ryt":"时间疑问代词","rys":"处所疑问代词","ryv":"谓词性疑问代词","rg":"代词性语素"},"m": {  #10.数词(1个一类，1个二类)"m":"数词","mq":"数量词"},"q": {  #11.量词(1个一类，2个二类)"q":"量词","qv":"动量词","qt":"时量词"},"d": {  #12.副词(1个一类)"d":"副词"},"p": {  #13.介词(1个一类，2个二类)"p":"介词","pba":"介词“把”","pbei":"介词“被”"},"c": {  #14.连词(1个一类，1个二类)"c":"连词","cc":"并列连词"},"u": {  #15.助词(1个一类，15个二类)"u":"助词","uzhe":"着","ule":"了 喽","uguo":"过","ude1":"的 底","ude2":"地","ude3":"得","usuo":"所","udeng":"等 等等 云云","uyy":"一样 一般 似的 般","udh":"的话","uls":"来讲 来说 而言 说来","uzhi":"之","ulian":"连 " #（“连小学生都会”）},"e": {  #16.叹词(1个一类)"e":"叹词"},"y": {  #17.语气词(1个一类)"y":"语气词(delete yg)"},"o": {  #18.拟声词(1个一类)"o":"拟声词"},"h": {  #19.前缀(1个一类)"h":"前缀"},"k": {  #20.后缀(1个一类)"k":"后缀"},"x": {  #21.字符串(1个一类，2个二类)"x":"字符串","xx":"非语素字","xu":"网址URL"},"w":{   #22.标点符号(1个一类，16个二类)"w":"标点符号","wkz":"左括号", #（ 〔  ［  ｛  《 【  〖 〈   半角：( [ { <"wky":"右括号", #） 〕  ］ ｝ 》  】 〗 〉 半角： ) ] { >"wyz":"全角左引号", #“ ‘ 『"wyy":"全角右引号", #” ’ 』"wj":"全角句号",#。"ww":"问号",#全角：？ 半角：?"wt":"叹号",#全角：！ 半角：!"wd":"逗号",#全角：， 半角：,"wf":"分号",#全角：； 半角： ;"wn":"顿号",#全角：、"wm":"冒号",#全角：： 半角： :"ws":"省略号",#全角：……  …"wp":"破折号",#全角：——   －－   ——－   半角：---  ----"wb":"百分号千分号",#全角：％ ‰   半角：%"wh":"单位符号"#全角：￥ ＄ ￡  °  ℃  半角：$}}class SegAtom(Structure):    _fields_ = [("start", c_int32), ("length", c_int32),        ("sPOS", c_char * 40),      ("iPOS", c_int32),        ("word_ID", c_int32),       ("word_type", c_int32), ("weight", c_int32)    ]def translatePOS(sPOS):    global POS    if sPOS=='url': sPOS = 'xu'    c = sPOS[0]    return POS[c][sPOS]Init = loadFun('NLPIR_Init',c_int, [c_char_p, c_int, c_char_p])Exit = loadFun('NLPIR_Exit',c_bool, None)ParagraphProcess = loadFun('NLPIR_ParagraphProcess',c_char_p, [c_char_p, c_int])ParagraphProcessA = loadFun('NLPIR_ParagraphProcessA',POINTER(SegAtom), [c_char_p, c_void_p, c_bool])#ParagraphProcessAW = loadFun('NLPIR_ParagraphProcessAW',None, [c_int, POINTER(SegAtom)])FileProcess = loadFun('NLPIR_FileProcess',c_double, [c_char_p, c_char_p, c_int])ImportUserDict = loadFun('NLPIR_ImportUserDict',c_uint, [c_char_p])AddUserWord = loadFun('NLPIR_AddUserWord', c_int, [c_char_p])SaveTheUsrDic = loadFun('NLPIR_SaveTheUsrDic', c_int, None)DelUsrWord = loadFun('NLPIR_DelUsrWord',c_int, [c_char_p])GetUniProb = loadFun('NLPIR_GetUniProb', c_double, [c_char_p])IsWord = loadFun('NLPIR_IsWord',c_bool, [c_char_p])GetKeyWords = loadFun('NLPIR_GetKeyWords',c_char_p, [c_char_p, c_int, c_bool])GetFileKeyWords = loadFun('NLPIR_GetNewWords',c_char_p, [c_char_p, c_int, c_bool])GetNewWords = loadFun('NLPIR_GetNewWords', c_char_p, [c_char_p, c_int, c_bool])GetFileNewWords = loadFun('NLPIR_GetFileNewWords',c_char_p, [c_char_p, c_int, c_bool])FingerPrint = loadFun('NLPIR_FingerPrint',c_ulong, [c_char_p])SetPOSmap = loadFun('NLPIR_SetPOSmap',c_int, [c_int])#New Word IdentificationNWI_Start = loadFun('NLPIR_NWI_Start', c_bool, None)NWI_AddFile = loadFun('NLPIR_NWI_AddFile',c_bool, [c_char_p])NWI_AddMem = loadFun('NLPIR_NWI_AddMem',c_bool, [c_char_p])NWI_Complete = loadFun('NLPIR_NWI_Complete', c_bool, None)NWI_GetResult = loadFun('NLPIR_NWI_GetResult',c_char_p, [c_int])NWI_Result2UserDict = loadFun('NLPIR_NWI_Result2UserDict',c_uint, None)if not Init('',ENCODING.UTF8_CODE,''):    print("Initialization failed!")    exit(-111111)'''if not SetPOSmap(3): #POSMap.ICT_POS_MAP_SECOND    print("Setting POS Map failed!")    exit(-22222)'''def seg(paragraph):    result = ParagraphProcess(paragraph, c_int(1))    atoms = [i.strip().split('/') for i in result.split(' ') if len(i)>=1 and i[0]!=' ']    atoms = [(a[0],a[1]) for a in atoms if len(a[0])>0]    return atomsdef segment(paragraph):    count = c_int32()    result = ParagraphProcessA(paragraph, byref(count),c_bool(True))    count = count.value    atoms = cast(result, POINTER(SegAtom))    return [atoms[i] for i in range(0,count)]def Seg(paragraph):    atoms = segment(paragraph)    for a in atoms:        if len(a.sPOS) < 1: continue        i = paragraph[a.start: a.start + a.length]#.decode('utf-8')#.encode('ascii')        yield (i, a.sPOS)if __name__ == "__main__":#p = "Test Article: 中国科学院计算技术研究所在多年研究基础上，耗时一年研制出了基于多层隐码模型的汉语词法分析系统 ICTCLAS(Institute of Computing Technology, Chinese Lexical Analysis System)，该系统的功能有：中文分词；词性标注；未登录词识别。分词正确率高达97.58%(最近的973专家组评测结果)，基于角色标注的未登录词识别能取得高于90%召回率，其中中国人名的识别召回率接近98%，分词和词性标注处理速度为31.5KB/s。ICTCLAS 和计算所其他14项免费发布的成果被中外媒体广泛地报道，国内很多免费的中文分词模块都或多或少的参考过ICTCLAS的代码。"r = open('infile.txt','r')f = open('outfile.txt','w')for eachline in r:p = eachlinefor t in Seg(p):#s = '%s\t%s\t%s\n' % (t[0],t[1],translatePOS(t[1]))s = '%s\t' % (t[0])f.write(s)f.write('\n')f.close()使用说明需要改动的应该只有main函数了，被注释的部分中，t[0]是分词结果，t[1]是这个被分出来的词的词性，translatePOS(t[1])则是将其分离出来所用到的规则（理论依据）示例：infile.txt中国科学院计算技术研究所在多年研究基础上耗时一年研制出了基于多层隐码模型的汉语词法分析系统ICTCLAS(Institute of Computing Technology, Chinese Lexical Analysis System)该系统的功能有：中文分词；词性标注；未登录词识别。分词正确率高达97.58%(最近的973专家组评测结果)，基于角色标注的未登录词识别能取得高于90%召回率，其中中国人名的识别召回率接近98%，分词和词性标注处理速度为31.5KB/s。ICTCLAS 和计算所其他14项免费发布的成果被中外媒体广泛地报道outfile.txt中国科学院计算技术研究所在多年研究基础上耗时一年研制出了基于多层隐码模型的汉语词法分析系统ICTCLAS(InstituteofComputingTechnology,ChineseLexicalAnalysisSystem)该系统的功能有：中文分词；词性标注；未登录词识别。分词正确率高达97.58%(最近的973专家组评测结果)，基于角色标注的未登录词识别能取得高于90%召回率，其中中国人名的识别召回率接近98%，分词和词性标注处理速度为31.5KB/s。ICTCLAS和计算所其他14项免费发布的成果被中外媒体广泛地报道After TranslatePOS(t[1])中国科学院nt机构团体名计算v动词技术n名词研究vn名动词所usuo所在v动词多年mq数量词研究vn名动词基础n名词上f方位词耗时vi不及物动词（内动词）一m数词年qt时量词研制v动词出vf趋向动词了ule了 喽基于p介词多m数词层qv动量词隐v动词码q量词模型n名词的ude1的 底汉语nz其它专名词法n名词分析vn名动词系统n名词ICTCLASx字符串(wkz左括号Institutex字符串ofx字符串Computingx字符串Technologyx字符串,wd逗号Chinesex字符串Lexicalx字符串Analysisx字符串Systemx字符串)wky右括号该rz指示代词系统n名词的ude1的 底功能n名词有vyou动词“有”：wp破折号中文nz其它专名分词v动词；wf分号词性n名词标注v动词；wf分号未d副词登录v动词词n名词识别vn名动词。wj全角句号分词v动词正确ad副形词率v动词高ad副形词达v动词97.58%m数词(wkz左括号最近t时间词的ude1的 底973m数词专家组n名词评测vn名动词结果n名词)wky右括号，wd逗号基于p介词角色n名词标注v动词的ude1的 底未d副词登录v动词词n名词识别v动词能v动词取得v动词高于v动词90%m数词召回v动词率v动词，wd逗号其中rz指示代词中国ns地名人n名词名q量词的ude1的 底识别vn名动词召回v动词率k后缀接近v动词98%m数词，wd逗号分词v动词和cc并列连词词性n名词标注v动词处理v动词速度n名词为v动词31.5KB/surl网址URL。wj全角句号ICTCLASx字符串和cc并列连词计算vn名动词所n名词其他rzv谓词性指示代词14m数词项q量词免费vd副动词发布v动词的ude1的 底成果n名词被pbei介词“被”中外b区别词媒体n名词广泛a形容词地ude2地报道v动词Source_CodePython.Ver DemoGithub, 向张华平博士致敬Python.Ver Ofiicial DemoGithub. Tsroten/pynlpirGithub. Haobio版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/46968491	概念JSON：JavaScript 对象表示法（JavaScript Object Notation）。JSON 是存储和交换文本信息的语法。类似 XML。JSON 比 XML 更小、更快，更易解析。每一章中用到的实例{"employees": [{ "firstName":"Bill" , "lastName":"Gates" },{ "firstName":"George" , "lastName":"Bush" },{ "firstName":"Thomas" , "lastName":"Carter" }]}这个 employee 对象是包含 3 个员工记录（对象）的数组。什么是 JSON ？JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation）JSON 是轻量级的文本数据交换格式JSON 独立于语言 *JSON 具有自我描述性，更易理解* JSON 使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。JSON - 转换为 JavaScript 对象JSON 文本格式在语法上与创建 JavaScript 对象的代码相同。由于这种相似性，无需解析器，JavaScript 程序能够使用内建的 eval() 函数，用 JSON 数据来生成原生的 JavaScript 对象。简介亲自试一试 - 实例通过我们的编辑器，您可以在线编辑 JavaScript 代码，然后通过点击一个按钮来查看结果：<html><body><h2>在 JavaScript 中创建 JSON 对象</h2><p>Name: <span id="jname"></span><br />Age: <span id="jage"></span><br />Address: <span id="jstreet"></span><br />Phone: <span id="jphone"></span><br /></p><script type="text/javascript">var JSONObject= {"name":"Bill Gates","street":"Fifth Avenue New York 666","age":56,"phone":"555 1234567"};document.getElementById("jname").innerHTML=JSONObject.namedocument.getElementById("jage").innerHTML=JSONObject.agedocument.getElementById("jstreet").innerHTML=JSONObject.streetdocument.getElementById("jphone").innerHTML=JSONObject.phone</script></body></html>亲自试一试类似 XMLJSON 是纯文本JSON 具有“自我描述性”（人类可读）JSON 具有层级结构（值中存在值）JSON 可通过 JavaScript 进行解析JSON 数据可使用 AJAX 进行传输相比 XML 的不同之处没有结束标签更短读写的速度更快能够使用内建的 JavaScript eval() 方法进行解析使用数组不使用保留字为什么使用 JSON？对于 AJAX 应用程序来说，JSON 比 XML 更快更易使用：使用 XML读取 XML 文档使用 XML DOM 来循环遍历文档读取值并存储在变量中使用 JSON读取 JSON 字符串用 eval() 处理 JSON 字符串语法JSON 语法是 JavaScript 语法的子集。JSON 语法规则JSON 语法是 JavaScript 对象表示法语法的子集。数据在名称/值对中数据由逗号分隔花括号保存对象方括号保存数组JSON 名称/值对JSON 数据的书写格式是：名称/值对。名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值："firstName" : "John"这很容易理解，等价于这条 JavaScript 语句：firstName = "John"JSON 值JSON 值可以是：数字（整数或浮点数）字符串（在双引号中）逻辑值（true 或 false）数组（在方括号中）对象（在花括号中）nullJSON 对象JSON 对象在花括号中书写：对象可以包含多个名称/值对：{ "firstName":"John" , "lastName":"Doe" }这一点也容易理解，与这条 JavaScript 语句等价：firstName = "John"lastName = "Doe"JSON 数组JSON 数组在方括号中书写：数组可包含多个对象：{"employees": [{ "firstName":"John" , "lastName":"Doe" },{ "firstName":"Anna" , "lastName":"Smith" },{ "firstName":"Peter" , "lastName":"Jones" }]}在上面的例子中，对象 "employees" 是包含三个对象的数组。每个对象代表一条关于某人（有姓和名）的记录。JSON 使用 JavaScript 语法因为 JSON 使用 JavaScript 语法，所以无需额外的软件就能处理 JavaScript 中的 JSON。通过 JavaScript，您可以创建一个对象数组，并像这样进行赋值：例子var employees = [{ "firstName":"Bill" , "lastName":"Gates" },{ "firstName":"George" , "lastName":"Bush" },{ "firstName":"Thomas" , "lastName": "Carter" }];可以像这样访问 JavaScript 对象数组中的第一项：employees[0].lastName;返回的内容是：Gates可以像这样修改数据：employees[0].lastName = "Jobs";亲自试一试<html><body><h2>在 JavaScript 中创建 JSON 对象</h2><p>Name: <span id="jname"></span><br />Age: <span id="jage"></span><br />Address: <span id="jstreet"></span><br />Phone: <span id="jphone"></span><br />try: <span id="jtry"></span><br /></p><script type="text/javascript">var JSONObject= {"name":"Bill Gates","street":"Fifth Avenue New York 666","age":56,"phone":"555 1234567"};document.getElementById("jname").innerHTML=JSONObject.namedocument.getElementById("jage").innerHTML=JSONObject.agedocument.getElementById("jstreet").innerHTML=JSONObject.streetdocument.getElementById("jphone").innerHTML=JSONObject.phonevar employees = [{ "firstName":"Bill" , "lastName":"Gates" },{ "firstName":"George" , "lastName":"Bush" },{ "firstName":"Thomas" , "lastName": "Carter" }];document.getElementById("jtry").innerHTML=employees[0].lastName;</script></body></html>这里需要注意的是<xxx></xxx>相当于花括号，需要在那中间来申明变量之类的操作，否则就直接作为文本显示出来了。在下面的章节，您将学到如何把 JSON 文本转换为 JavaScript 对象。JSON 文件JSON 文件的文件类型是 ".json"JSON 文本的 MIME 类型是 "application/json"使用把 JSON 文本转换为 JavaScript 对象JSON 最常见的用法之一，是从 web 服务器上读取 JSON 数据（作为文件或作为 HttpRequest），将 JSON 数据转换为 JavaScript 对象，然后在网页中使用该数据。为了更简单地为您讲解，我们使用字符串作为输入进行演示（而不是文件）。JSON 实例 - 来自字符串的对象创建包含 JSON 语法的 JavaScript 字符串：var txt = '{ "employees" : [' +'{ "firstName":"Bill" , "lastName":"Gates" },' +'{ "firstName":"George" , "lastName":"Bush" },' +'{ "firstName":"Thomas" , "lastName":"Carter" } ]}';由于 JSON 语法是 JavaScript 语法的子集，JavaScript 函数 eval() 可用于将 JSON 文本转换为 JavaScript 对象。eval() 函数使用的是 JavaScript 编译器，可解析 JSON 文本，然后生成 JavaScript 对象。必须把文本包围在括号中，这样才能避免语法错误：var obj = eval ("(" + txt + ")");在网页中使用 JavaScript 对象：例子<p>First Name: <span id="fname"></span><br />Last Name: <span id="lname"></span><br /></p><script type="text/javascript">document.getElementById("fname").innerHTML = obj.employees[1].firstNamedocument.getElementById("lname").innerHTML = obj.employees[1].lastName</script>亲自试一试<html><body><p>First Name: <span id="fname"></span><br />Last Name: <span id="lname"></span><br /></p><script type="text/javascript">var txt = '{ "employees" : [' +'{ "firstName":"Bill" , "lastName":"Gates" },' +'{ "firstName":"George" , "lastName":"Bush" },' +'{ "firstName":"Thomas" , "lastName":"Carter" } ]}';var obj = eval ("(" + txt + ")");document.getElementById("fname").innerHTML = obj.employees[1].firstNamedocument.getElementById("lname").innerHTML = obj.employees[1].lastName</script></body></html>JSON 解析器提示：eval() 函数可编译并执行任何 JavaScript 代码。这隐藏了一个潜在的安全问题。使用 JSON 解析器将 JSON 转换为 JavaScript 对象是更安全的做法。JSON 解析器只能识别 JSON 文本，而不会编译脚本。在浏览器中，这提供了原生的 JSON 支持，而且 JSON 解析器的速度更快。较新的浏览器和最新的 ECMAScript (JavaScript) 标准中均包含了原生的对 JSON 的支持。Web 浏览器支持Web 软件支持Firefox (Mozilla) 3.5Internet Explorer 8ChromeOpera 10Safari 4jQueryYahoo UIPrototypeDojoECMAScript 1.5亲自试一试对于较老的浏览器，可使用 JavaScript 库： https://github.com/douglascrockford/JSON-jsJSON 格式最初是由 Douglas Crockford 制定的。ReferenceGithub:  douglascrockford/JSON-jsJSON in JavaScriptDouglas Crockforddouglas@crockford.com2015-05-03JSON is a light-weight, language independent, data interchange format.See http://www.JSON.org/The files in this collection implement JSON encoders/decoders in JavaScript.JSON became a built-in feature of JavaScript when the ECMAScript ProgrammingLanguage Standard - Fifth Edition was adopted by the ECMA General Assemblyin December 2009. Most of the files in this collection are for applicationsthat are expected to run in obsolete web browsers. For most purposes, json2.jsis the best choice.json2.js: This file creates a JSON property in the global object, if thereisn't already one, setting its value to an object containing a stringifymethod and a parse method. The parse method uses the eval method to do theparsing, guarding it with several regular expressions to defend againstaccidental code execution hazards. On current browsers, this file does nothing,preferring the built-in JSON object. There is no reason to use this file unlessfate compels you to support IE8, which is something that no one should ever have to do again.json_parse.js: This file contains an alternative JSON parse function thatuses recursive descent instead of eval.json_parse_state.js: This files contains an alternative JSON parse function thatuses a state machine instead of eval.cycle.js: This file contains two functions, JSON.decycle and JSON.retrocycle,which make it possible to encode cyclical structures and dags in JSON, and tothen recover them. This is a capability that is not provided by ES5. JSONPath is used to represent the links. [http://GOESSNER.net/articles/JsonPath/]版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/46934585	今天接到一个小任务，说是让把好多文件（大概2800来个，总大小超过1G）中的信息进行筛选，整合到一个文件里方便接下来的操作。那么，无可避免的就需要用到多文件读写。那么，该如何批量打开多个文件进行读写操作呢？众所周知 freopen(filename,r/w,i/ostream)的第一个参数filename需要是一个常量const char*，即便文件名是有序的，我们也没办法将变量传参进去。于是，在搜索与自学中看到了这样一个实例：#include <iostream>#include <fstream>using namespace std;int main(){int i;char filename[30],line[1001];ifstream File[5];ofstream File2;  File2.open("5.txt",ios::out);for(i=1;i<5;i++){sprintf(filename,"%d.txt",i);File[i].open(filename,ios::in);while(!File[i].eof()){File[i].getline(line,1000);File2<<line<<endl;}File[i].close();}File2.close();system("pause");return 0;}用数组来申明文件输入输出流，使用正规的fsream函数来进行操作，简单易懂而且操作高效。然而，关于当前文件夹究竟有哪些文件，也懒得一一输入进来，于是我们又需要这样一个函数来获得某个文件夹内，所有文件的名称（获得之后也可以通过文件读写把所有文件名写入一个文件中）#include <sys/types.h>#include <dirent.h>#include <stdio.h>#include<iostream>#include<vector>using namespace std;int main(int argc, char *argv[]){DIR *dp;struct dirent *dirp;vector<std::string> filename;if( (dp=opendir("F:\\directory_name") )==NULL )perror("open dir error");while( (dirp=readdir(dp) )!=NULL )filename.push_back(dirp->d_name);for(int i=0;i<filename.size();i++)cout<<filename[i]<<endl;closedir(dp);return 0;}在掌握了这些之后，尝试着写了一个较大的程序，实现的工程应用如下：从CN-pair中获得事先输出的<Code-Name>键值对，存储在缓存中，接着对大数量的文件进行读取，每行三列以'\t'分割的数据经过处理，获得第二列中的数据，筛去<Code-Name>的值，依次存储于文件SUM中，与其相对应的频数则也依次存储于FREQ中：#include <map>#include <cmath> #include <vector>#include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <fstream>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}map<string,string> mark;vector<int> freq;void get_CNpair()//get <Code-Name> pair into Cache{string c,n; mark.clear();freopen("CN-pair","r",stdin);while(cin>>c>>n) mark[c]=n; fclose(stdin);}int IncludeChinese(char *str)  //0: English  1:Chinese{   char c;   while(1)   {       c=*str++;       if (c==0) break;   if (c&0x80)       if (*str & 0x80) return 1;   }   return 0;}int main(){get_CNpair(); freq.clear();char filename[30],line[1024],t[1024];ifstream File[3333];ofstream File2;  File2.open("Sum.txt",ios::out);int i=1;for(map<string,string>::iterator mit=mark.begin();mit!=mark.end();++mit,++i){//cout<<mit->first<<":"<<mit->second<<endl;char addr[6];for(int j=0;j<6;j++) addr[j]=(mit->first)[j];sprintf(filename,"%s",addr);File[i].open(filename,ios::in);//File2<<"#"<<mit->first<<"#"<<endl;while(!File[i].eof()){File[i].getline(line,1023);string anti=line;int flag=0,rj=0,temp=0;for(int ri=0;ri<strlen(line);ri++){if(flag==0 && line[ri]=='\t') {flag=1;continue;}if(flag==0) continue;if(line[ri]=='\t'){temp=0; ri++;while(line[ri]!='.') {temp=temp*10+(int)(line[ri]-'0');ri++;}break;}else{if(line[ri]!=32 && line[ri]>0 && line[ri]<127);else if(isdigit(line[ri]));else t[rj++]=line[ri];}}t[rj]='\0';if(strlen(t)>0 && IncludeChinese(t)) {string t_str=t,rpls1=mit->first,rpls2=mit->second;//cout<<rpls1<<rpls2<<endl;if(t_str.find(rpls1)!=t_str.npos)t_str=t_str.replace(t_str.find(rpls1),rpls1.length(),"");//cout<<"rpls1:"<<t_str<<":"<<rpls1<<endl;if(t_str.find(rpls2)!=t_str.npos)t_str=t_str.replace(t_str.find(rpls2),rpls2.length(),"");//cout<<"rpls2:"<<t_str<<":"<<rpls2<<endl;if(t_str.length()>0){bool blank_flag=1;for(int bi=0;bi<t_str.length();bi++){if(t_str[bi]!=' '){blank_flag=0;break;}}if(blank_flag){File2<<line<<endl;freq.push_back(temp);}}}}File[i].close();}File2.close();freopen("freq.txt","w",stdout);//for(vector<int>::iterator vd=freq.begin();vd!=freq.end();++vd)for(int i=0;i<freq.size();i++)cout<<freq[i]<<endl;fclose(stdout);return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/46914215	前言啊啊啊，我还真是喜欢STL呢，明知道不能过度依赖它，但是就觉得好好用啊好方便啊怎么办……啃饼干啃STL，今天又啃了一个set。set是一个很棒的数据结构，度娘说：“STL 对这个序列可以进行查找，插入删除序列中的任意一个元素，而完成这些操作的时间同这个序列中元素个数的对数成比例关系，并且当游标指向一个已删除的元素时，删除操作无效。而一个经过更正的和更加实际的定义应该是：一个集合(set)是一个容器，它其中所包含的元素的值是唯一的。这在收集一个数据的具体值的时候是有用的。集合中的元素按一定的顺序排列，并被作为集合中的实例。一个集合通过一个链表来组织，在插入操作和删除操作上比向量(vector)快，但查找或添加末尾的元素时会有些慢。具体实现采用了红黑树的平衡二叉树的数据结构。”然后又有如下解释:set是STL中一种标准关联容器（vector,list,string,deque都是序列容器，而set，multiset，map，multimap是标准关联容器），它底层使用平衡的搜索树——红黑树实现，插入删除操作时仅仅需要指针操作节点即可完成，不涉及到内存移动和拷贝，所以效率比较高。set，顾名思义是“集合”的意思，在set中元素都是唯一的，而且默认情况下会对元素自动进行升序排列，支持集合的交(set_intersection),差(set_difference) 并(set_union)，对称差(set_symmetric_difference) 等一些集合上的操作，如果需要集合中的元素允许重复那么可以使用multiset叫人如何不动心？于是来学学看了~鉴于本人学习STL的方法是先拼命看啊看啊看，然后再敲啊敲啊敲，所以还是从SourceCode来看看比较符合我的胃口——代码理解set的初始化首先是裸set模板，用int的太没诚意了，用个<string,int>型的结构体吧~#include<set>#include<iostream>#include<algorithm>using namespace std;struct Info  {      string name;      double score;      bool operator < (const Info &a) const // Custom cmp_Rule     {          //Desc:<  Asc:>          return a.score < score;      }  };  int main(){set<Info> s;      Info info;      info.name = "Jack";      info.score = 80;      s.insert(info);      info.name = "Tom";      info.score = 99;      s.insert(info);      info.name = "Steven";      info.score = 60;      s.insert(info);  s.erase(s.find(info));    set<Info>::iterator it;      for(it = s.begin(); it != s.end(); it++)          cout << (*it).name << " : " << (*it).score << endl;   return 0;}/* 运行结果： Tom : 99 Jack : 80 */ 可见set会自动维护其中元素的顺序，可以通过重载操作符的方式自定义排序的规则，此外，erase删除某个元素时需要传参指向这个被删除的元素的迭代器；寻找是否存在某个元素，如果存在则获取其迭代位置的迭代器则使用find()函数。说到erase，也可以传入两个参数作为前后指针删除其中的元素，代码如下：// set::lower_bound/upper_bound#include <iostream>#include <set>int main (){  std::set<int> myset;  std::set<int>::iterator itlow,itup;  for (int i=1; i<10; i++) myset.insert(i*10); // 10 20 30 40 50 60 70 80 90  itlow=myset.lower_bound (30);                //       ^  itup=myset.upper_bound (60);                 //                   ^  myset.erase(itlow,itup);                     // 10 20 70 80 90  std::cout << "myset contains:";  for (std::set<int>::iterator it=myset.begin(); it!=myset.end(); ++it)    std::cout << ' ' << *it;  std::cout << '\n';  return 0;}关于等号的操作符重载// assignment operator with sets#include <iostream>#include <set>int main (){  int myints[]={ 12,82,37,64,15 };  std::set<int> first (myints,myints+5);   // set with 5 ints  std::set<int> second;                    // empty set  second = first;                          // now second contains the 5 ints  first = std::set<int>();                 // and first is empty  std::cout << "Size of first: " << int (first.size()) << '\n';  std::cout << "Size of second: " << int (second.size()) << '\n';  return 0;}如果只是像上述一样把first和second交换包含元素的话，其实swap也就够了：// swap sets#include <iostream>#include <set>main (){  int myints[]={12,75,10,32,20,25};  std::set<int> first (myints,myints+3);     // 10,12,75  std::set<int> second (myints+3,myints+6);  // 20,25,32  first.swap(second);  std::cout << "first contains:";  for (std::set<int>::iterator it=first.begin(); it!=first.end(); ++it)    std::cout << ' ' << *it;  std::cout << '\n';  std::cout << "second contains:";  for (std::set<int>::iterator it=second.begin(); it!=second.end(); ++it)    std::cout << ' ' << *it;  std::cout << '\n';  return 0;}黑科技之equal_elements此外，看到一个特别方便的函数叫做equal_elements()，作用是返回一个pair，pair的first指向lower_bound，pair的second指向upper_bound。// set::equal_elements#include <iostream>#include <set>int main (){  std::set<int> myset;  for (int i=1; i<=5; i++) myset.insert(i*10);   // myset: 10 20 30 40 50  std::pair<std::set<int>::const_iterator,std::set<int>::const_iterator> ret;  ret = myset.equal_range(30);  std::cout << "the lower bound points to: " << *ret.first << '\n';  std::cout << "the upper bound points to: " << *ret.second << '\n';  return 0;}是不是特别方便呢？~存疑get_allocator() 的用法及意义// set::get_allocator#include <iostream>#include <set>int main (){  std::set<int> myset;  int * p;  unsigned int i;  // allocate an array of 5 elements using myset's allocator:  p=myset.get_allocator().allocate(5);  // assign some values to array  for (i=0; i<5; i++) p[i]=(i+1)*10;  std::cout << "The allocated array contains:";  for (i=0; i<5; i++) std::cout << ' ' << p[i];  std::cout << '\n';  myset.get_allocator().deallocate(p,5);  return 0;}关于集合间逻辑关系操作四种常用函数标准用法：#include <algorithm>#include <iostream>#include <set>using namespace std; int main(){       int a[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8 };       set<int> S( a, a + 9 );             int b[] = { 3, 6, 8, 9 };       set<int> S2( b, b + 4 );             set<int>::iterator site;        set<int> Su;       set<int> Si;       set<int> Sd;       set<int> Ssd;             //交集       set_intersection( S.begin(), S.end(),                                   S2.begin(), S2.end(),                                   inserter( Si, Si.begin() ) );                                         //并集       set_union( S.begin(), S.end(),                     S2.begin(), S2.end(),                        inserter( Su, Su.begin() ) );                              //差集       set_difference( S.begin(), S.end(),                                S2.begin(), S2.end(),                                   inserter( Sd, Sd.begin() ) );             //对称差集       set_symmetric_difference( S.begin(), S.end(),                                                S2.begin(), S2.end(),                                                 inserter( Ssd, Ssd.begin() ) );                                                             site = Si.begin();       cout<<"the intersection of S and S2 is : ";       while( site != Si.end() )       {              cout<< *site <<" ";              ++ site;       }       cout<<endl;             site = Su.begin();       cout<<"the union of S and S2 is : ";       while( site != Su.end() )       {              cout<< *site <<" ";              ++ site;       }       cout<<endl;             site = Sd.begin();       cout<<"the difference of S and S2 is : ";       while( site != Sd.end() )       {              cout<< *site <<" ";              ++ site;       }       cout<<endl;             site = Ssd.begin();       cout<<"the symmetric difference of S and S2 is : ";       while( site != Ssd.end() )       {              cout<< *site <<" ";              ++ site;       }       cout<<endl;             return 0;}输出：the intersection of S and S2 is : 3 6 8the union of S and S2 is : 0 1 2 3 4 5 6 7 8 9the difference of S and S2 is : 0 1 2 4 5 7the symmetric difference of S and S2 is : 0 1 2 4 5 7 9详解用法：#include<set>#include<iterator>#include<iostream>#include<algorithm>using namespace std;set<int> eg1,eg2;int main(){//插入eg1.insert(1);eg1.insert(100);eg1.insert(5);eg1.insert(1);//元素1因为已经存在所以set中不会再次插入1eg1.insert(10);eg1.insert(9);//遍历set，可以发现元素是有序的set<int>::iterator set_iter=eg1.begin();cout<<"Set named eg1:"<<endl;for(;set_iter!=eg1.end();set_iter++) cout<<*set_iter<<" ";cout<<endl;//使用size()函数可以获得当前元素个数cout<<"Now there are "<<eg1.size()<<" elements in the set eg1"<<endl;if(eg1.find(200)==eg1.end())//find()函数可以查找元素是否存在   cout<<"200 isn't in the set eg1"<<endl;for(int i=6;i<15;i++) eg2.insert(i);cout<<"Set named eg2:"<<endl;for(set_iter=eg2.begin();set_iter!=eg2.end();set_iter++) cout<<*set_iter<<" ";cout<<endl;//获得两个set的并set<int> eg3; cout<<"Union:";set_union(eg1.begin(),eg1.end(),eg2.begin(),eg2.end(),insert_iterator<set<int> >(eg3,eg3.begin()));//注意第五个参数的形式copy(eg3.begin(),eg3.end(),ostream_iterator<int>(cout," "));cout<<endl;//获得两个set的交，注意进行集合操作之前接收结果的set要调用clear()函数清空一下eg3.clear();set_intersection(eg1.begin(),eg1.end(),eg2.begin(),eg2.end(),insert_iterator<set<int> >(eg3,eg3.begin()));cout<<"Intersection:";copy(eg3.begin(),eg3.end(),ostream_iterator<int>(cout," "));cout<<endl;//获得两个set的差eg3.clear();set_difference(eg1.begin(),eg1.end(),eg2.begin(),eg2.end(),insert_iterator<set<int> >(eg3,eg3.begin()));cout<<"Difference:";copy(eg3.begin(),eg3.end(),ostream_iterator<int>(cout," "));cout<<endl;//获得两个set的对称差，也就是假设两个集合分别为A和B那么对称差为AUB-A∩Beg3.clear();set_symmetric_difference(eg1.begin(),eg1.end(),eg2.begin(),eg2.end(),insert_iterator<set<int> >(eg3,eg3.begin()));copy(eg3.begin(),eg3.end(),ostream_iterator<int>(cout," "));cout<<endl;return 0;}输出:Set named eg1:1 5 9 10 100Now there are 5 elements in the set eg1200 isn't in the set eg1Set named eg2:6 7 8 9 10 11 12 13 14Union:1 5 6 7 8 9 10 11 12 13 14 100Intersection:9 10Difference:1 5 1001 5 6 7 8 11 12 13 14 100版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/46805743	前言关于上一篇文章中基于servlet的HttpUrl服务端，以时间为例的实时信息更新。既然有写Server端，自然会要想如何应用这段信息，于是尝试着在安卓端想写一个demo，使用一个距离传感器，它们实时采集数据然后通过UART的方式把数据发送到PC端，然后PC端通过WIFI无线网络利用HttpUrl通信方式再将数据发送到手机，手机将数据按照一定的格式进行显示。应用背景（实用性）在解决了基础物质生活需求的今天，随着科技的不断进步，人们的生活受到了潜移默化的影响，生活质量也不断得到提高。促使人们开始追求家庭生活现代化、居住环境舒适化、安全化等，为此智能家居也随之而生，所谓的智能家居是以住宅为平台，利用综合布线技术、网络通信技术、安全防范技术、自动控制技术、音视频技术将家居生活有关的设施集成，构建高效的住宅设施与家庭日程事务的管理系统，提升家居安全性、便利性、舒适性、艺术性，并实现环保节能的居住环境。随着物联网络的出现，为智能家居系统的发展及应用加入了助推剂。物联网是指各类传感器与现有的互联网相互衔接的一种新技术。物联网让智能家居的功能产生了飞跃，它改变的将不仅仅是家电产品的功能，而是生活方式，给消费者带来的便捷令人向往。需求分析本次从实际出发，目的为实现使用手机应用通过无线对一个距离传感器实现监测和控制，是智能联网系统的基本需求。 获取传感器数值 通过串口传输数据 服务器端监听串口数据发送给手机端 手机端通过无线实时显示传感器数据配置及环境硬件配置@ZoeCur 1只 Sharp GP2Y0A21YK距离传感器 Nokia 5110 屏幕 TM4C Lanchpad USB数据线 （模拟串口） PC机(ThinkPad T430) Android系统智能手机开发环境 Windows 8 Keil v4 JDK 1.8 Eclipse EE（javacomm20-win32／RXTX_win64） ADT运行环境 Windows 8 JRE 1.8 javacomm20-win32／RXTX_win64 Android 4.4.4 （三星N7100）设计理念Servlet设计Method设计Client-Android 设计数据分析为了得到传感器返回的电压值与实际距离的关系，需要获得这两者间的函数关系，于是用厘米尺量取几个点用以数据拟合。T=[999,860,660,450,370,270,200,150,130];D=[5,10,15,20,25,30,40,60,80];使用Matlab进行拟合General model Exp2:     f(x) = a*exp(b*x) + c*exp(d*x)Coefficients (with 95% confidence bounds):       a =        1944  (-371.5, 4260)       b =    -0.02985  (-0.03951, -0.02019)       c =       51.71  (42.08, 61.33)       d =   -0.002019  (-0.002434, -0.001603)Goodness of fit:  SSE: 7.813  R-square: 0.9984  Adjusted R-square: 0.9974  RMSE: 1.25选用函数为：f(x)=1944*exp(-0.02985*x)+51.71*exp(-0.002019*x)考虑到计算复杂度和计算精度的问题，放弃高斯拟合选用了契合度稍低但容易计算的自然对数拟合函数。将其写作函数，用来对电压值转换为距离：public String changeToDist(String str)    {    double x=(double)Integer.parseInt(str);double val = 1944.0 * Math.exp(-0.02985*x) + 51.71 * Math.exp(-0.002019*x);String ret="";if(val>80.0)ret = " >80.00 cm";else if(val<5.0) ret = " <5.00 cm";else{ret = val + "";ret = ret.substring(0,6) + "cm";}System.out.println("[Log] Info_sensor="+ret);return ret;    }服务器实时传送数值如上，可见数值转换正常。关于麻烦的安卓端package com.example.sensor_app;import java.io.ByteArrayOutputStream;import java.io.InputStream;import org.apache.http.HttpEntity;import org.apache.http.HttpResponse;import org.apache.http.HttpStatus;import org.apache.http.client.HttpClient;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.DefaultHttpClient;import android.os.AsyncTask;import android.os.Bundle;import android.app.Activity;import android.view.Menu;import android.view.View;import android.widget.Button;import android.widget.TextView;public class MainActivity extends Activity {private Button butt3 = null; private TextView text1 = null;String value = null;private MyTask mTask;    @Override    protected void onCreate(Bundle savedInstanceState) {     super.onCreate(savedInstanceState);         setContentView(R.layout.activity_main);                  butt3 = (Button) this.findViewById(R.id.button1);         text1 = (TextView) this.findViewById(R.id.text1);                  butt3.setOnClickListener(new Button.OnClickListener()     { @Override public void onClick(View arg0) { // TODO Auto-generated method stub mTask = new MyTask(); mTask.execute("http://192.168.191.1:8080/SensorApp/ReadDemo?op=getValue"); butt3.setEnabled(false); }     });    }        private class MyTask extends AsyncTask<String,Integer,String>{        @Overrideprotected void onPreExecute() {//Log.i(TAG,"onPreExecute() called");text1.setText("loading");}@Overrideprotected String doInBackground(String... params) {//Log.i(, "doInBackGround()call");try {                  HttpClient client = new DefaultHttpClient();                  HttpGet get = new HttpGet(params[0]);                  HttpResponse response = null;                              while(true){                response = client.execute(get);                 if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {                      HttpEntity entity = response.getEntity();                      InputStream is = entity.getContent();                      long total = entity.getContentLength();                      ByteArrayOutputStream baos = new ByteArrayOutputStream();                      byte[] buf = new byte[1024];                      int count = 0;                      int length = -1;                      while ((length = is.read(buf)) != -1) {                          baos.write(buf, 0, length);                          count += length;                          //调用publishProgress公布进度,最后onProgressUpdate方法将被执行                         // publishProgress((int) ((count / (float) total) * 100));                          //为了演示进度,休眠500毫秒                                                                    }                      //更新当前值                    value = new String(baos.toByteArray(), "gb2312");                    //调用onProgressUpdate(Integer... values)                    publishProgress((int) ((count / (float) total) * 100));                   //一秒后继续更新                    Thread.sleep(1000);                     //return new String(baos.toByteArray(), "gb2312");                  }                /*Thread.sleep(1000);                  i++;                publishProgress(i,5);*/                }              } catch (Exception e) {                  //Log.e(TAG, e.getMessage());              }              return null;  }@Overrideprotected void onProgressUpdate(Integer... values) {// TODO Auto-generated method stubtext1.setText(value);}@Overrideprotected void onPostExecute(String result) {// TODO Auto-generated method stubtext1.setText(result); }    }    @Override    public boolean onCreateOptionsMenu(Menu menu) {        // Inflate the menu; this adds items to the action bar if it is present.        getMenuInflater().inflate(R.menu.main, menu);        return true;    }    }难点在于开线程以及同步实时更新数值。关于控件的信号槽问题是Android的通病，不过与本次实验尝试无关，就不在这里写这些的处理方法了。调试完毕后，连接手机打开ADB调试，开始运行安卓客户端。如图，此为在安卓OS中的APP图标及打开时的初始界面。紧接着，在JavaEE中打开服务端，开始运行，上图为服务端控制台数据，也同时编写Log日志，实时向客户端传值。电路板纹理的正六边形为启动按钮，安卓端接收到服务端确认后，将实时显示服务器传来的数据，由于服务端的串口数据接收间隔为5秒，当接收到新数据时会显示<NEW>以作提示。总结此次课程设计中，我负责的主要是服务端与安卓客户端的部分，辅以对数据在Matlab中进行数据拟合。过程中查阅了许多资料，为了新功能进行了若干次尝试，这是一次非常有收获的经历。从串口获取数据之后，服务器需要持续地将串口数据读取到程序中，通过我拟合出的“传感器电压值-实际距离值”函数将String类型的信息转换成实际距离，加上传感器型号与服务器时间后传递给网络端口。另一个难点在于一次请求之后要无限实时信息传递，加上各类异常和新数据的判定，最终终于完成了之后，成就感和自豪油然而生。ReleaseSourceCode： https://github.com/okcd00/Colorful_Projects/tree/master/J2EE_Projects/Android-Server-Sensor%20%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/46795805	前言嘛……对于深恶痛绝的JAVA，不得已还是得稍微做些东西，再怎么恨得牙痒痒烦的头冒烟也得写啊……JAVA来说最烦的就是分支太多，选择太多，坑太多，环境太难配……呐，这不是，失败的想法——HttpUrl为手机动态同步服务器数据，的半成品拿来作以后写项目的备忘了么~咳咳，这个大概是一个什么呢……是一个使用JAVAEE搭建一个使用JSP页面获取所需值的项目环境说明Win8.1 ProfessionalJava 1.8.0_25JavaEE Eclipse Java EE IDE for Web Developers. Version: Luna Service Release 1 (4.4.1)过程记录首先， New 一个 Project 的时候要注意是 Dynamic Web Project， 即动态网页项目项目名字，然后Finish对于这个jsp的实现自然需要在Java Resources里添加代码，需要的是Method和Servlet两个package，本来想像上图这种方式添加包，后来发现——新建class的时候就可以加package啊！【示例】我这里的Method里写的是 ReturnValue.javapackage Method;import java.text.SimpleDateFormat;import java.util.Date;public class ReturnValue {private String info = null;public void setString(String t){this.info=t;}public String getValue(){SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");//this.info = sdf.format(new Date());return info;}}然而servlet里写的是 COMServlet.javapackage Servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import Method.ReturnValue;//import com.sun.org.apache.xml.internal.serialize.Printer;/** * Servlet implementation class COMServlet */@WebServlet("/COMServlet")public class COMServlet extends HttpServlet {private static final long serialVersionUID = 1L;           /**     * @see HttpServlet#HttpServlet()     */    public COMServlet() {        super();    }/** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {//url形式：http://xxx.xxx.xxx.xxx:8080/项目名称/COMServlet?op=getValue//8080端口是不一定的 得看看你电脑是不是用这个作为http协议的端口 一般是这个啦String op = request.getParameter("op");if(op!=null){switch(op){case "getValue":sendValue(request,response);}}}private void sendValue(HttpServletRequest request,HttpServletResponse response) {response.setContentType("text/html;charset=utf-8");response.setCharacterEncoding("UTF-8");PrintWriter writer;//获得系统中的值ReturnValue r = new ReturnValue();try {writer = response.getWriter();writer.println(r.getValue());} catch (IOException e) {// TODO Auto-generated catch blocke.printStackTrace();}}/** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {// TODO Auto-generated method stub}}然后在WebContent里添加文件 xxx.jspbody部分写一个超链接，超链接到 servlet，其中?后面是传参，详见上文中代码，即传入参数op为getValue<%@ page language="java" contentType="text/html; charset=ISO-8859-1"    pageEncoding="ISO-8859-1"%><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Insert title here</title></head><body><a href="COMServlet?op=getValue"> Just_A_Test </a></body></html>写完了之后对jsp右键 run on server就会有显示了，这个截图中由于info没有被更新，所以返回是null返回服务器实时更新的值，示例如下，为返回服务器时间：public String getValue(){SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");this.info = sdf.format(new Date());return info;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/46407397	被坑了好久……好久……好久……终于搭建好了，不写个博客记(qing)录(zhu)一下么？前言自然要写最重要的东西：不要完全照抄2.1.1的教程去装2.1.2！2.1.2的/opt/tinyos-2.1.2/下并没有tinyos.sh文件！咳咳，来来来我们从头来说~ 图文说明哟第一件事自然是要加个tinyOS的源，这里用的是斯坦福的tinyOS源：gedit /etc/apt/sources.list需要添加的行如下： deb http://tinyos.stanford.edu/tinyos/dists/ubuntu lucid main源改好了之后，需要更新一下源~ 就是apt-get update这项操作会在list文件中读取，如果有新的会把新的报头摘取下来我们输入sudo apt-get install tinyos的时候，可以获得当前已有的各种版本的清单，选择一个，这里我选择的是最新的sudo apt-get install tinyos-2.1.2会询问是否安装，虽然空间很吃紧但咱还是得装呀~于是开始了漫长的等待下载完成，自动开始解包安装完成，返回用户操作通过修改bashrc来添加tinyos.sh的操作gedit ~/.bashrc这个在2.1.1都是有效的，然而——2.1.2 根本没有tinyos.sh这个文件！所以我们需要将bashrc的末尾添加如下文本#installation by substituting /opt for the actual tinyos tree#installation pointTOSROOT="/opt/tinyos-2.1.2"TOSDIR="$TOSROOT/tos"CLASSPATH="$TOSROOT/support/sdk/java/tinyos.jar:."MAKERULES="$TOSROOT/support/make/Makerules"export TOSROOTexport TOSDIRexport CLASSPATHexport MAKERULES#Sourcing the tinyos environment variable setup scriptsource /opt/tinyos-2.1.2/tinyos.sh添加成功之后记住要重启终端其实不重启也是可以的，输入这段指令就可以了——source ~/.bashrc打开sim.extra，对python的版本号作更改sudo gedit /opt/tinyos-2.1.1/support/make/sim.extra什么，不知道python版本号？python --version什么，你还没有python？apt-get install python获取JNI和G++并给予用户权限sudo tos-install-jnisudo apt-get install g++sudo chown okcd00 -R /opt/tinyos-2.1.2/此处的okcd00是我的ID哦，你们要改成自己的username哦在线down了一些实例下来，打算尝试能不能在TinyOS下跑，也算一种验证。wget http://github.com/tinyos/tinyos-release/archive/tinyos-2_1_2.tar.gz解压之后覆盖了tinyos-2.1.2的apps文件夹，然后进入Blink目录下，尝试make telosb出现上述信息，即代表成功编译运行，验证完毕，TinyOS2.1.2至此完全搭建完成倘若有什么没有写的完善的不容易懂的，请在下方留言。当然如果有什么好的建议或者意见也欢迎告诉我~版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/46345107	CTF什么的，以前就略有耳闻，然而较为具体的是在360的GeekGame宣讲会上得知的。这次试了试，写一些关于这次 【第一次CTF自学纪实】什么是CTF:      CTF全称Capture The Flag，即夺旗比赛，衍生自古代军事战争模式，两队人马前往对方基地夺旗，每队人马须在保护好己方旗帜的情况下将对方旗帜带回基地。在如今的计算机领域中，CTF已经成为安(hei)全(ke)竞赛的一种重要比赛形式，参赛选手往往需要组队参加，通过团队之间的相互合作使用逆向、解密、取证分析、渗透利用等技术最终取得flag。CTF的比赛形式:      CTF夺旗赛通常有两种形式，解题模式（Jeopardy）和攻防模式（Attack-Defense）。在解题模式的比赛中，主办方会提供一系列不同类型的赛题，比如上线一个有漏洞的服务、提供一段网络流量、给出一个加密后的数据或经过隐写后的文件等，他们将 flag 隐藏在这些赛题中，选手们通过比拼解题来一决高下；在攻防模式比赛中，主办方会事先编写一系列有漏洞的服务，并将它们安装在每个参赛队伍都相同的环境中，参赛队伍一方面需要修补自己服务的漏洞，同时也需要去攻击对手们的服务、拿到对手环境中的 flag 来得分，攻防模式的竞赛往往比解题模式的竞赛更接近真实环境，比赛过程也更加激烈。CTF的常见题型:      一般在CTF比赛中，会涉及MISC，PPC，CRYPTO，PWN，REVERSE，WEB，STEGA这几种题目。       MISC(miscellaneous)类型的题目比较杂乱，可能要分析数据，可能需要百度一下，还可能需要脑筋急转弯；PPC(Professionally ProgramCoder)会考察一些编程类的题目；是CRYPTO是密码学，考察各种加解密技术，当然这和软件加密解密的REVERSE技术是两码事。PWN在黑客俚语中代表着，攻破，取得权限，多为溢出类题目。STEGA(Steganography)会将flag隐藏到各种有码无码高清不高清的图片和音像制品中；WEB题目不用多说，大家都懂的。。国内外有哪些著名的CTF比赛:      国内：当然是最近炒得火热的XCTF全国联赛了！      国外：                PHDays CTF全称Positive Hack Days CTF，是一个国际性信息安全竞赛，竞赛规则基于CTF，但更贴近网络实战环境。                iCTF国际黑客竞赛是一个面向全球信息安全专业研究学生团队的大型在线黑客竞赛。清华blue-lotus实验室在上届（2011）竞赛中排名第23位（共87个参赛团队）。                DEFCON是世界上最大、最古老的地下黑客大会，和Black Hat的创始人相同，但相比于Black Hat要随意得多。DEFCON以小规模讨论及技术切磋为主，会上最流行的活动是若干人组成一个局域网，然后互打攻防战（CTF），参赛者的目标是进攻对手的网络，但同时保护好自己的地盘。由于想参赛的队伍都得经过会前淘汰赛，因此参赛者都有相当高的实力。被这些所吸引，作为爱好我也尝试了一下CTF，也就是浅尝辄止的级别吧，待ACM、CISCN、暑期实习之类的压力变得小一些之后，再来继续玩~作为第一次尝试，于此做一下记录，以便日后查看以及拾起再续。此次使用的是合天平台，环境是云端临时实验机，图为正在申请新实验机。实验机申请完成，这里合天很贴心的做出了任务系统，出现任务，以答题的形式来检测是否真正理解了相关的知识原理。实验机开始后是这样一个简洁的WinXP系统。在浏览器中登录提供的CTF的IP地址 10.1.1.23/1/，可以看到第一关的Button由于第一关似乎并没有什么用，于是看看网页源代码，看到一句注释，删除？那就地址栏改成1.php.bak看看要删掉的是啥呗~感觉很像，但是有这么多奇奇怪怪的分号什么情况？再看看源代码其实我很好奇这里为啥是红色的……然而我看到了php结尾的东西，第一时间想到的自然是地址栏打一下（不过感觉是不是能通过某种方法把这个button显示出来……嘛，能进行就成，暂时不管了）有个输入框有个第三关……点击button之后问了一句从哪来然后强行返回刚刚的页面提示上说这里可以“插”，那就试试呗，然而尝试插一个弹窗试试看……啊，弹窗了哎试试 window.location='3rd.php' 果然这样子3rd就让进了……眼皮底下……眼皮底下是哪里啦！主要用的都是Chrome，火狐浏览器不熟……不过还是百度到了怎么浏览器自带抓包响应头里有个本不应该存在的东西，NEXT，看来是自定义的，反正给了名字就进去呗（CTF总不至于给个蜜罐来骗咱嘛）然而这里有个丧心病狂的按钮，叫做“点我”，然而鼠标只要一移到他附近，按钮就立马消失了审查元素走起，发现这里有个joy函数，就是用来藏元素用的找这个函数在哪里被用到了，onmouseover="joy()" ，咱先把style改成 display:block 把按钮调出来。按钮有了自然就要把这个害人的joy函数删掉咯看吧 现在就可以点这个按钮了。KEY-GET中途查了好多资料还问了信息安全班的同学相关的部分知识，看来CTF需要的知识面范围真的好广呢，不过确实好好玩，等以后有时间再学习新的技术吧版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/46301605	前言儿童节快乐~~ 啊对了首先想带标程回家看的可以来这里：教主大大标程包 /我的现场赛代码在校赛这样三人组队两台电脑的环境下，单挑的压力着实是十分之大……毕竟在同等条件下别人手速只要超过自己的一半就一定会在罚时上输掉。所以只有尽可能的减少WA的次数，比赛结束时是 8*Submission/6*AC 的 W/A 率，对自己而言确实是个难得的正确率了。作为ATeam1，总觉得啊又是A又是1的，不努努力怎么对得起我的对标，然则全场拼的话又拼不过手速，只有速读速写了，最终A题抢一血提交，却在每组测试数据前忘了给balance清零，于是抢到了全场第一发WA（第一个WA应该叫啥，FW么），然后再提交的时候已经是ID4了，即使AC也不是FB了……然后奋力过B，C，都是一次过，这两题中有一题我是FB，可惜忘了是哪题了……然后去做了F，很可惜没看到题目中有一句“Tb>Ta”，即同时发送信息是不可以的，又送了一发WA，第二发才AC掉……看到D那么多那么多条件，当场吓傻了……这……这还让不让人好好做题啦！等会……教主不是最喜欢把签到题隐藏在看起来最烦的题里么，仔细读了读题发现，啊可食用商品直接乘以0.8来考虑嘛，然后删掉了一群句子，然后就是那个买了不可食用物品的话则所有物品中价格最低的那个打五折……刚打算动手写个分支（价格最低的是不可食用/可食用），突然反应过来啊不对啊，无论这个人接下来买啥，肯定不会比只买这个非食用物品的折扣低（买了价值高的，因为价值比这个非食用物品高，不考虑，买了价值低的，折扣变为这个价值低的物品的一半），突然这道题就变成裸贪心了……哗啦哗啦写掉1A然后手头剩下一个G和一个E，看到E我就好难过……啊啊啊教练我要学图论……只有啃G了，……然而G题也是个题目一时半会不知道是啥的题目（每道题第一时间一定是被教主又在玩什么ACG梗或者电影梗吸引），然后在纸上随手画了画……啊咧，这个画法似曾相识……啊，凸包么！能用三角形框起来的意思就是说并没有点在最终的三个点框成的三角形之外，这不就是凸包嘛~ 然后敲了个凸包，凸包点数不大于三即可，Submit~ 然后E……我瞪着它它瞪着我……除了枚举然后dfs放守卫以外我想不出任何解法……然而写着写着… 惊讶地发现……啊为何我本来只想写个dist数组来存，莫名其妙写成dp了……(刚刚打字打dp居然打成“大破”了我也是捂脸……) 然后就想干脆改成dp吧…… 然后又觉得唔还是写个递归从鹰眼开始来获得每个节点的各个分支需要多少个警卫求和吧……然后……啊对哦递归深度怎么可能到1K……Time‘s up解题报告Problem_[A]kali’s Balancetimelimit 2 seconds / memory limit 256 megabytes Description艾欧尼亚群岛上存在一个上古教派，致力于维护某种均衡。规则与混乱、光明与黑暗——万物必须和谐共存，这就是宇宙的真理。该教派名为均衡教派，维护世界均衡的神圣使命则由三个暗影战士来执行。阿卡丽便是这三名暗影勇士中一员，她肩负着修枝的神圣职责——将威胁瓦洛兰大陆和谐的敌人消灭干净。阿卡丽自小和母亲一起习武，练就一身好武功。母亲的训练严酷无情，她的基本原则是：“我们是在替天行道”。阿卡丽十四岁加入均衡教派，那时她就能空手砍断链条。毋庸置疑，她将继承母亲“暗影之拳”的名号。她的所作所为别人可能无法理解，但在阿卡丽看来，她在执行母亲神圣的信条。她要和慎和凯南一起维护着瓦洛兰大陆的平衡。这一神圣的追求毫无疑问地将三个暗影忍者引领向正义之地。作为一个捍卫均衡的忍者，她很早以前就被师傅嘱托需要监视另一块神秘的大陆HUXI：有许许多多不同的神秘能量散布在这片大陆的各个角落，每份神秘能量都可以以一个正整数来描述其蕴含的能量值。年轻的暗影忍者认为这块神秘的大陆上的能量值为奇数的神秘能量数量若与能量值为偶数的神秘能量数量保持严格一致，那么这片大陆便是平衡的。 Input第一行一个正正数T(T<=20)，描述测试数据组数。接下来每两行描述一组测试数据：每组测试数据的第一行含有一个整数N(1<=N<=1024)描述神秘大陆HUXI上的神秘能量数量；每组测试数据的第二行含有N个正整数Ai(1<=Ai<=1024)描述这些神秘能量所蕴含的能量值。 Output对于每组测试数据，依次输出一个大写英文字母’B’表示神秘大陆HUXI是平衡的，或输出一个大写英文字母’U’表示大陆HUXI不平衡；每组测试数据的输出独占一行(即每个大写英文之母之后需要换行，详如Sample)。 Sample Input:Sample Output:241 2 3 102441 2 3 3BU 梗：英雄联盟-均衡教派-阿卡丽题意：给n个数，奇数个数等于偶数个数的时候输出B（Balance），否则输出U思路：均衡，存乎万物之间！用一个均衡值（不好，我的中二之魂！）来代表均衡的程度，初始为0，出现一个奇数减一，出现一个偶数加一，最终如果均衡值依然为0则输出B，否则输出U。Code：#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;int main(){    freopen("A.in","r",stdin);    int T; scanf("%d",&T);    int a[1111];    for(int _T=0;_T<T;_T++)    {        int balance=0;        memset(a,0,sizeof a);        int n;  scanf("%d",&n);        for(int i=0;i<n;i++)        {            scanf("%d",&a[i]);            if(a[i]%2==1) balance++;            else balance--;        }        if(balance==0) printf("B\n");        else printf("U\n");    }    return 0;} Problem_[B]rain Bursttimelimit 2 seconds / memory limit 256 megabytes DescriptionBrain Burst 2039是日本轻小说作家川原砾创作的轻小说作品《加速世界》中的一款游戏的名称。这是一款VR-MMORPG(Virtual Reality - Massively Multiplayer OnlineRole-playing game)虚拟现实大型多人在线角色扮演类游戏，这款游戏与普通的MMORPG大型多人在线角色扮演类游戏有一个很重要的相似点：等级非常重要。玩家刚进入游戏时等级为Lv.1，当前经验值为0 exp, 当前等级升级需要经验值为300 exp。玩家在游戏中获取经验将会累加在自己的当前经验值上，若一位Lv 1玩家获取经验后，一旦当前经验值不少于300 exp时便会升级，这时系统会立即在玩家的当前经验值上扣除玩家升级所需经验的，然后将玩家的等级提升至Lv 2。当然，升级所需经验会随着玩家等级的提升不断的升高，若当前玩家等级为K(K>=1)，则玩家当前等级升级需要经验值为300+(K-1)*100。然而在某些特定条件下，玩家甚至会连续升级：例如一名当前等级为Lv 2, 当前经验值为 200 exp的玩家获取1000 exp经验后，那么他将会升级到Lv 4, 当前经验值剩余300 exp (升级到Lv 3后当前经验剩余800，不低于Lv 3到Lv 4的升级所需经验500故连续升级)。由于游戏开发需要， 现在给定某玩家获取N exp经验后的等级Lv. L，与该玩家获取经验后的当前经验值E exp，需要编程计算求得这位玩家在获取这N exp经验之前的等级和经验值。 Input第一行一个正正数T(T<=100)，描述测试数据组数。接下来每行描述一组测试数据：每组测试数据唯一一行含有3个非负整数，依次为N(0<=N<=10000)玩家获取经验，L(1< =L<=99)玩家获取经验后等级，E(0<=E<=300+(L-1)*100)玩家获取经验后当前经验值。输入数据保证合法性（即玩家在获得经验前至少为Lv1, 0 exp）。 Output对于每组测试数据，依次输两个非负整数分别表示玩家在获取经验前的等级和经验值。每组测试数据的输出独占一行(即每两个非负整数之后需要换行，详如Sample)。 Sample Input:Sample Output:51000 4 300300 2 0100 1 2000 4 3001985 6 1002 2001 01 1004 3002 315 梗：ACG-动漫-加速世界 / ACG-MMO-等级制MMO题意：正所谓在MMO中高等级玩家单手干掉一群神装萌新，等级很重要。这题的意思是，每行给三个数N / L / E，即我获得了N点经验值，现在是L等级多E点经验值，问我获得这N点经验值之前我是多少级多少经验值呢?思路：等级+经验的表述一般是表象，实际上仍然是总经验（升级到各等级所需经验和+多余经验）这样的一个值，我们事先计算一下升到各个等级需要的总经验值存在exp数组里，那么每次给出的L和E我们都可以通过exp[L]+E的方式来表示总经验，减去N之后就是所需要的之前的经验值。再在数组里进行查找（这个数据范围是100，遍历和二分查找其实差别不大，不过大家还是养成二分的好习惯哦，如果这是1e9的等级数的对不对~~ 啊不过那么高等级谁还愿意玩啊……），查找到之后等级就知道了，然后就能减掉它获得剩余经验啦~Code：#include <cstdio>#include <string>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;int exp[101];void exp_init(){    memset(exp,0,sizeof exp);    exp[0]=-1;    exp[1]=0;    for(int i=2;i<101;i++)    {        exp[i]=exp[i-1]+300+(i-2)*100;        //cout<<i<<":"<<exp[i]<<endl;    }}int main(){    freopen("B.in","r",stdin);    int T;  scanf("%d",&T);    exp_init();    for(int _T=0;_T<T;_T++)    {        int n,l,e;        scanf("%d%d%d",&n,&l,&e);        int now=exp[l]+e-n;        int lv= upper_bound(exp,exp+101,now)-exp-1;        int rest=now-exp[lv];        cout<<lv<<" "<<rest<<endl;    }    return 0;}这里需要说明的是，upper_bound()函数是STL中自带的“有序数列中二分查找到第一个大于key的位置”函数，这里的用法是在exp[0]到exp[100]寻找now的值所在的位置，减掉exp的首地址就是下标的值了。（这里用for遍历一下找到第一个比now大的-1或者找到最后一个比now小的都是可以的哦）Problem_[C]ross Minestimelimit 2 seconds / memory limit 256 megabytes Description传统扫雷是一款单人的电脑游戏。游戏目标是找出所有没有地雷的方格，完成游戏；要是按了有地雷的方格，游戏失败。游戏以完成时间来评高低。游戏开始时，玩家可看到一堆整齐排列的空白方块，方块数可由玩家自行选择。如果是第一次点开方块则不会踩到地雷。如果玩家点开没有地雷的方块，会有一个数字显现其上，这个数字代表着邻近方块有多少颗地雷（数字至多为8），玩家须运用逻辑来推断哪些方块含或不含地雷。交叉扫雷与传统扫雷不同，没有地雷的方块上的统计数字统计的并非相邻方块上的地雷数量，而是统计以自己为正中心的5*5的正方形两条对角线上除自己之外的方格（之后略称为相对交叉位置）的地雷数量，如上图所示。作为交叉扫雷的开发人员，你需要编程解决在输入所有地雷位置的情况下按照交叉扫雷规则标记所有没有地雷的方块其相对交叉位置方块中的地雷数量。 Input第一行一个正正数T(T<=20)，描述测试数据组数。每组测试数据的第一行含有一个整数N(1<=N<=16)描述交叉扫雷游戏棋盘尺寸为N*N；每组测试数据的第二行起总计N行每行共N个字符（小写字母‘x’表示该方块含有地雷，小写字母‘o’表示该方块没有地雷）。 Output对于每组测试数据，依次输出一个N*N的字符矩阵对应每组输入数据。矩阵含有小写字母’x’表示对应方格含有地雷或数字’0’-’8’表示对应方格其相对交叉位置方块中的地雷数量。 Sample Input:Sample Output:25xoxxoooxxoxooooxoxxoooxoo3ooooooxxox1xx114xx2x4324x3xx102x11001111xx0 梗：扫雷题意：想必各位都写过扫雷吧，这里唯一不同的是每个格子里的数字不是周围一圈的雷数而是一个叉上的雷数。让输出这个图（所有非雷格输出数字）思路：首先我们用int[][]代表每个格子周围一个叉范围内的雷数，用char[][]读入这张图，读入过程中一旦当前读入的是个雷，则开始遍历周围一个叉范围内的所有格子（这里记得范围哦，先判断这个坐标在不在图内再去访问格子的数组，否则会RE数组越界的），对int[][]数组的当前位置进行++，读完了，数字们也就加完了。然后输出这张图，如果char[][]数组中这个地方是雷就输出x，否则输出int[][]中的数字。Code：#include <cstdio>#include <string>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;char mp[20][20];int nmp[20][20];void update(int n,int x,int y){    int dir[8][2]={-2,-2,-1,-1,1,1,2,2,1,-1,2,-2,-1,1,-2,2};    for(int i=0;i<8;i++)    {        if(x+dir[i][0]>=1 && x+dir[i][0]<=n && y+dir[i][1]>=1 && y+dir[i][1]<=n)            nmp[x+dir[i][0]][y+dir[i][1]]++;    }}int main(){    freopen("C.in","r",stdin);    int T;  scanf("%d",&T);    for(int _T=0;_T<T;_T++)    {        memset(nmp,0,sizeof nmp);        int n=0;    scanf("%d",&n);        for(int i=1;i<=n;i++)        {            getchar();            for(int j=1;j<=n;j++)            {                scanf("%c",&mp[i][j]);                if(mp[i][j]=='x') update(n,i,j);            }        }        for(int i=1;i<=n;i++)        {            for(int j=1;j<=n;j++)            {                if(mp[i][j]=='x')printf("x");                else printf("%d",nmp[i][j]);            }            printf("\n");        }    }    return 0;}Problem_[D]iscount Shoppingtimelimit 2 seconds / memory limit 256 megabytes Description重庆大学ACM-ICPC代表队共N名队员共同前往ACMOUNTAIN出席比赛。赛前，大家偶然发现位于ACMOUNTAIN的ACMARKET正在进行大促销活动。ACMARKET的商品均分为可食用和不可食用两种，可食用商品全部8折优惠（原价*0.8），不可食用商品原价。       若任意一个人购买了至少一件不可食用商品，那么他的所有所购买的商品中实际购买价格（即若是可食用商品将会以8折后价格计算）最低商品中的其中一件（即有多件商品实际购买价格最低时仅能优惠其中一件）会在实际购买价格的基础上再享受一次5折优惠（即若享受8折后的可食用商品是客户所购买的最低价的商品那么他可以选择以原价*0.8*0.5的价格来购买这件商品）。代表队员们列出了他们希望购买的M件商品，请问N名队员最少共计使用多少钱可以购买该清单上的全部商品（每名队员最多仅能购买一次商品，但一次购买数量不受限制）。 Input第一行一个正正数T(T<=20)，描述测试数据组数。接下来每行描述一组测试数据：每组测试数据第1行两个整数，依次为N(1<=N<=10000)代表队队员个人, (1<=M<=10000)清单商品个数；每组测试数据第2至1+M行每行两个整数，描述每一件在清单上的商品，P(1 <=p<=10000)商品原价，T是否为可食用（T=0时该商品为不可食用，反之T=1时该商品为可食用）。 Output对于每组测试数据，输出一个浮点数（保留两位小数，四舍五入）即购买清单上全部商品最少的花费。每组测试数据的输出独占一行(即每个浮点数之后需要换行，详如Sample)。 Sample Input:Sample Output:22 31024 01024 1512 02 581 1 511 02137 0155 11024 01587.202759.90 梗：ACM / ACMer买东西遇到促销一定要找(jing)最(da)优(xi)解(suan)题意：有n个人要去买m个东西，每个东西有原始价格（p，食用物品本质上是p*0.8）和属性（T，1为可食用，0为不可食用），对于每个人来说，只要他买了一个非食用物品，在他的购物车中所有的物品中最便宜的那个，打五折。问最少花多少钱。思路:我们呢还是反着看吧，我们最多省多少钱。对于每个人来说，买了非食用物品的话，实际上省钱的最大值为（购买了的各非食用物品价值的最小值与各食用物品最小值 之间较小的一个），唔是不是很绕，这么说吧，买一个非食用之后，无论买啥都不如单单买它一个折扣低（理由见前言），为了省钱最大，我们把非食用排个序，食用排个序，前n-1个人依次购买非食用物品中剩下的最大值，仅买这一个（当非食用物品买完了，那就break掉吧，因为已经不会再有折扣了），最后一个人买完剩下的所有东西（为什么有种强烈的“啊我就是这最后一个人”的既视感），最后一个人的折扣值取决于他的购物车里还有没有非食用物品，以及购物车中最便宜的物品是什么。Code：#include <cstdio>#include <string>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;double fd[10086],nfd[10086];bool cmp(const double a,const double b){    return a - b > 0.0;}int main(){    freopen("D.in","r",stdin);    int T; scanf("%d",&T);    for(int _T=0;_T<T;_T++)    {        int n,m,posf=0,posn=0;        double sum=0.0;        scanf("%d%d",&n,&m);        memset(fd,0,sizeof fd);        memset(nfd,0,sizeof nfd);        for(int i=0;i<m;i++)        {            int p,t;            scanf("%d%d",&p,&t);            if(t==1)            {                fd[posf++]=(double)p*0.8;                sum+=(double)p*0.8;            }            else            {                nfd[posn++]=(double)p;                sum+=(double)p;            }        }        sort(fd,fd+posf,cmp);        sort(nfd,nfd+posn,cmp);        int lenf=posf,lenn=posn;        posf=posn=0;        for(int i=0;i<n;i++)        {            if(posn==lenn)break;            if(i==n-1)            {                if(posf==lenf)sum-=nfd[lenn-1]/2.0;                else sum-=min(nfd[lenn-1],fd[lenf-1])/2.0;            }            else            {                sum-=(nfd[posn]/2.0);                posn++;            }        }        printf("%.2f\n",sum);    }    return 0;}嗯，关于变量名，fd是food，nfd是non-food，lenf是length_of_food，lenn是length_of_non-food，啊，别打我，现场赛想不出好名字…… Problem_[E]agle Eyetime limit 2 seconds / memorylimit 256 megabytes Description鹰眼是美国漫威漫画公司旗下的超级英雄。本名克林顿·法兰西斯·巴顿，小名克林特，曾化名为歌利亚与浪人，是个在马戏团长大的孤儿，师从剑客和捷射，天赋异常，少年时便获得“鹰眼“和“世界最佳狙击手”的称号，因在某次演出时看到钢铁侠救人的一幕后，决心利用自己的能力成为超级英雄，后加入复仇者联盟，成为其中重要的一份子。在复仇者集结之前，鹰眼为神盾局工作。在九头蛇的猛烈进攻下，鹰眼接到守卫一个神盾局秘密地下基地的任务：秘密基地中有N个密室，这N个密室间共有N-1条1个单位长度的通道相连,任意两个不同的密室都相互可达（或需要穿过其他的密室）。神盾局需要鹰眼以及一些神盾局特工呆在部分密室中（不可移动）来保护这全部N个密室。鹰眼由于其特殊的能力，他能够守卫自己所在的密室以及距离他所在密室不超过K个单位长度距离的所有密室。其他特工能够守卫自己所在的密室以及距离他所在密室不超过1个单位长度距离的所有密室。鹰眼希望你帮助他计算出要保护所有N个密室最少需要派遣多少名神盾局特工（鹰眼自身不计算在内）。 Input第一行一个正正数T(T<=100)，描述测试数据组数。接下来每行描述一组测试数据：每组测试数据第1行2个整数，依次为N(1<=N<=1000)表示密室数量, K（1<K<=5）表示鹰眼守卫范围；每组测试数据第2至N行每行两个整数X Y，描述一条密室通道，说明密室X与密室Y间存在一条通道(1<=X, Y<=N, X!=Y)，保证输入数据满足题意限制。 Output对于每组测试数据，输出一个非负整数即最少派遣特工的数量。每组测试数据的输出独占一行(即每个非负整数之后需要换行，详如Sample)。 Sample Input:Sample Output:19 21 22 33 44 53 66 76 88 91 梗：Marvel-复仇者联盟-鹰眼 / 神盾局特工题意：有一棵所有通路权值都为1的树，超级英雄鹰眼站在其中一个节点上，然后距离k以内的都被控制住，除此之外，放置有限数量个特工（每个人可以控制距离1以内的节点），为最少需要多少个特工才能把这棵树的所有节点变为可控。据说一种解法是枚举鹰眼的位置然后树形dp，由于这题我并没有做出来……放上教主的标程。Code： By Jki#include <cstdio>#include <cstring>#define V 11000#define E 21000#define S 3int n, m, ans;int nbs[V], nxt[E], dst[E], enm;int f[V][S];const int inf=10086;template<class T> inline void updmin(T &x, const T y){ if(x>y)x=y; }template<class T> inline void updmax(T &x, const T y){ if(x<y)x=y; }inline void add_edge(const int u, const int v){nxt[++enm]=nbs[u]; nbs[u]=enm; dst[enm]=v;nxt[++enm]=nbs[v]; nbs[v]=enm; dst[enm]=u;}int dp_entry(const int u, const int p, const int d){int sum=0;for(int i=nbs[u]; i; i=nxt[i]){int v=dst[i];if(v==p)continue;sum+=dp_entry(v, u, d+1);}f[u][0]=0;f[u][1]=0;f[u][2]=1;int bst=inf;for(int i=nbs[u]; i; i=nxt[i]){int v=dst[i];if(v==p)continue;f[u][0]+=f[v][1];f[u][1]+=f[v][1];updmin(bst, f[v][2]-f[v][1]);f[u][2]+=f[v][0];}f[u][1]+=bst;updmin(f[u][1], f[u][2]);updmin(f[u][0], f[u][1]);if(d<m){return sum;}else return f[u][0];}int main(){int T;if(!scanf("%d", &T))return 1;while(T--){if(scanf("%d%d", &n, &m)!=2)return 1;memset(nbs, 0, sizeof(nbs));enm=0;for(int i=1; i<n; i++){int u, v;if(scanf("%d%d", &u, &v)!=2)return 1;u--;v--;add_edge(u, v);}ans=inf;for(int i=0; i<n; i++){updmin(ans, dp_entry(i, -1, 0));}printf("%d\n", ans);}}Faster Code: By Jki#include <cstdio>#include <cstring>#define N 11000#define E 21000#define M 8#define B 2const int INF=10086;int n, m;int nbs[N], nxt[E], dst[E], enm;int f[N][B][B][M], ans;template<class T> void updmax(T &x, const T y){ if(x<y)x=y; }template<class T> void updmin(T &x, const T y){ if(x>y)x=y; }void add_edge(const int u, const int v){nxt[++enm]=nbs[u];nbs[u]=enm;dst[enm]=v;nxt[++enm]=nbs[v];nbs[v]=enm;dst[enm]=u;}void dp_entry(const int u, const int p){for(int i=nbs[u]; i; i=nxt[i]){int v=dst[i];if(v==p)continue;dp_entry(v, u);}/* GUARDED *///+EEf[u][1][1][m]=0;for(int i=nbs[u]; i; i=nxt[i]){int v=dst[i];if(v==p)continue;f[u][1][1][m]+=f[v][0][0][m];}//1EEfor(int k=m-1; k>=0; k--){updmin(f[u][1][1][k], f[u][1][1][k+1]);//0AGENTint buf=0, bst=INF;for(int i=nbs[u]; i; i=nxt[i]){int v=dst[i];if(v==p)continue;updmin(bst, f[v][1][1][k+1]-f[v][0][0][k]);buf+=f[v][0][0][k];}updmin(f[u][1][1][k], buf+bst);if(k==1){//+AGENTbuf=0; bst=INF;for(int i=nbs[u]; i; i=nxt[i]){int v=dst[i];if(v==p)continue;updmin(bst, f[v][0][1][1]-f[v][0][0][1]);buf+=f[v][0][0][1];}updmin(f[u][1][1][1], buf+bst+1);}else if(k==0){int x_fir, x_sec;int y_fir, y_sec;x_fir=x_sec=y_fir=y_sec=-1;buf=0;for(int i=nbs[u]; i; i=nxt[i]){int v=dst[i];if(v==p)continue;buf+=f[v][1][0][0];if(x_fir<0 || f[x_fir][1][1][0]-f[x_fir][1][0][0]>=f[v][1][1][0]-f[v][1][0][0]){x_sec=x_fir; x_fir=v;}else if(x_sec<0 || f[x_sec][1][1][0]-f[x_sec][1][0][0]>f[v][1][1][0]-f[v][1][0][0]){x_sec=v;}if(y_fir<0 || f[y_fir][1][0][1]-f[y_fir][1][0][0]>=f[v][1][0][1]-f[v][1][0][0]){y_sec=y_fir; y_fir=v;}else if(y_sec<0 || f[y_sec][1][0][1]-f[y_sec][1][0][0]>f[v][1][0][1]-f[v][1][0][0]){y_sec=v;}}if(~x_fir && ~y_fir){if(x_fir!=y_fir){updmin(f[u][1][1][0], buf+f[x_fir][1][1][0]-f[x_fir][1][0][0]+f[y_fir][1][0][1]-f[y_fir][1][0][0]);}else{if(~x_sec){updmin(f[u][1][1][0], buf+f[x_sec][1][1][0]-f[x_sec][1][0][0]+f[y_fir][1][0][1]-f[y_fir][1][0][0]);}if(~y_sec){updmin(f[u][1][1][0], buf+f[x_fir][1][1][0]-f[x_fir][1][0][0]+f[y_sec][1][0][1]-f[y_sec][1][0][0]);}}}}}updmin(f[u][0][1][0], f[u][1][1][0]);//0EE//+AGENTint buf=0, bst=INF;for(int i=nbs[u]; i; i=nxt[i]){int v=dst[i];if(v==p)continue;buf+=f[v][0][0][1];}updmin(f[u][1][0][1], buf+1);//0AGENTupdmin(f[u][1][0][0], f[u][1][0][1]);buf=0; bst=INF;for(int i=nbs[u]; i; i=nxt[i]){int v=dst[i];if(v==p)continue;updmin(bst, f[v][1][0][1]-f[v][1][0][0]);buf+=f[v][1][0][0];}updmin(f[u][1][0][0], buf+bst);updmin(f[u][0][0][0], f[u][1][0][0]);/* DANGER *///1EEfor(int k=1; k<=m; k++){updmin(f[u][0][1][k], f[u][0][1][k-1]);//0AGENTint buf=0, bst=INF;for(int i=nbs[u]; i; i=nxt[i]){int v=dst[i];if(v==p)continue;updmin(bst, f[v][0][1][k-1]-f[v][0][0][k-1]);buf+=f[v][0][0][k-1];}updmin(f[u][0][1][k], buf+bst);}//0EEfor(int k=1; k<=m; k++){//0AGENTupdmin(f[u][0][0][k], f[u][0][0][k-1]);int buf=0;for(int i=nbs[u]; i; i=nxt[i]){int v=dst[i];if(v==p)continue;buf+=f[v][0][0][k-1];}updmin(f[u][0][0][k], buf);}}int main(){int T;scanf("%d", &T);while(T--){scanf("%d%d", &n, &m);memset(nbs, 0, sizeof(nbs));enm=0;for(int i=1; i<n; i++){int u, v;scanf("%d%d", &u, &v);u--;v--;add_edge(u, v);}for(int w=0; w<n; w++){for(int x=0; x<B; x++){for(int y=0; y<B; y++){for(int z=0; z<=m; z++){f[w][x][y][z]=INF;}}}}dp_entry(0, -1);ans=f[0][1][1][0];printf("%d\n", ans);}return 0;}Problem_[F]riendstimelimit 2 seconds / memory limit 256 megabytes DescriptionThese is an unusual social network. User can not add friends manually in this social network. Friends’ relationship are determined by the system automatically in the following way: Assuming that user X had sent user Y a post at time T1, and user Y sent user X a message at time T2. If T2 > T1 and T2 - T1 <= D,then system determine X and Y is a pair of friends because of that it seems the user Y replied the post which had been sent by X in time.You are given the log of post-contains N post-records-in chronological order and a number D. Find the number of pairs of users who will be determined to be friends. InputThe first line of the INPUT contain a positive integer T(T<=10) which denotes the number of test cases.The first line of each case contains two integers N and D (1 ≤ n, d ≤ 1000).The next N lines of each case contain the post log. The i-th line contains one line of the log formatted as "Xi Yi Ti", which means that user Xi sent a post to user Yi at time Ti (1 ≤ i ≤ n). Xi and Yi are non-empty strings at most 20 characters long, consisting of lowercase letters, and Ti is an integer(0 ≤ Ti ≤ 10000). It is guaranteed that the lines are given in non-decreasing order of Ti's and that no user sent a message to himself. The elements in the lines are separated by single spaces. OutputIn each line print an integer k — the number of pairs of friends for each case. Sample Input:Sample Output:34 3jki curabis 7curabis jki 8masoshonen jki 9jki masoshonen 151 1000masoshonen masoshojo 06 2a b 1b a 2a c 3a b 4c a 5c a 5102 梗:  ACG-动漫-这不是僵尸吗-魔装少年 /  谁能告诉我Curabis是啥……（我只知道酷拉皮卡） <Update: 哈哈哈哈果然是博熊~~ 感谢教主的解答~~~>题意：有n条信息发送的指令，从name1发送到name2，发送时间是t，倘若name2在（t, t+d] 时间范围内发送回一条信息，我们称他们两个是盆友（看到了没，回复我信息回复慢了的才不是朋友呢），问在这n条指令中我们能看出有几对朋友。思路：这里我用到了map的数据结构，map<pair<string,string>,int>，其实只需要用二维数组friends[a][b]=1则代表其为朋友就可以啦（这里我写的有点浪费，f[a][b]=f[b][a]其实不必要，只要时刻将字典序小的作为第一下标就可以了），mpi[a][b]为a给b发送的最后一条信息的时间（这里切记需要注意，时间是可以为0的，需要特判，Sample2就是一个很贴心的提示，因为数组或者各种数据结构初始会默认赋值为0，这样像Sample2这样的就会被判定为有一对朋友）。使用map的话可以直接通过size()函数来获得朋友的组数，数组的话遍历一下就可以啦~，切记当a和b已经是朋友的时候不要再多算一次哦。Code：#include <map>#include <cstdio>#include <string>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;typedef pair<string,string> pss;map<pss,int> mpi;map<pss,int> friends;void update(string a,string b){    pss f1=make_pair(a,b),f2=make_pair(b,a);    if(friends[f1]==0 && friends[f2]==0)    {        friends[f1]=friends[f2]=1;        //cout<<a<<":"<<b<<endl;    }}int main(){    freopen("F.in","r",stdin);    int T; scanf("%d",&T);    for(int _T=0;_T<T;_T++)    {        mpi.clear();        friends.clear();        int n,d;    scanf("%d%d",&n,&d);        for(int i=0;i<n;i++)        {            string a,b;            int t;            cin>>a>>b>>t;            pss tmp= make_pair(a,b);            pss ask= make_pair(b,a);            if(mpi[ask]!=0)            {                if(mpi[ask]==-1)                {                    if(t-(mpi[ask]+1)<=d && t-(mpi[ask]+1)>0)   //shenti!!! [a!=b]                    update(a,b);                }                else if(t-mpi[ask]<=d && t-mpi[ask]>0)                {                    update(a,b);                }            }            if(t!=0)mpi[tmp]=t;            else mpi[tmp]=-1;        }        //for(map<pss,int>::iterator it=friends.begin();it!=friends.end();++it)        printf("%d\n",friends.size()/2);    }    return 0;}标程Code：#include<cstdio>#include<cstring>#include<string>#include<map>using namespace std;#define N 2048int n, m, idx, ans;int x[N], y[N], t[N];int mrk[N][N], rig[N][N];string sx[N], sy[N];map<string, int> s;char buf[32];template<class T> inline void SWAP(T &x, T &y){ T z=x;x=y;y=z; }int main(){int T;scanf("%d", &T);while(T--){scanf("%d%d", &n, &m);s.clear(); idx=0;for(int i=0; i<n; i++){scanf("%s", buf);sx[i]=buf;s.insert(make_pair(sx[i], 0));scanf("%s", buf);sy[i]=buf;s.insert(make_pair(sy[i], 0));scanf("%d", &t[i]);}for(map<string, int>::iterator it=s.begin(); it!=s.end(); it++){it->second=idx++;}memset(mrk, 0, sizeof(mrk));memset(rig, 0xc0, sizeof(rig));ans=0;for(int i=0; i<n; i++){x[i]=s[sx[i]];y[i]=s[sy[i]];if(i && t[i]>t[i-1]){for(int j=i-1; j>=0 && t[j]==t[i-1]; j--){rig[x[j]][y[j]]=t[j];}}if(t[i]-rig[y[i]][x[i]]<=m){int u=x[i], v=y[i];if(u>v)SWAP(u, v);if(!mrk[u][v]){mrk[u][v]=1;ans++;}}}printf("%d\n", ans);}return 0;}Problem_[G]raphictimelimit 2 seconds / memory limit 256 megabytes DescriptionCurabis always do excellent job on computation geometry problems. Indeed, he has acquired the first solution award about the computation geometry problems in the ACM-ICPC Asia Regional several times. However, JKi, his stupid teammate, do it much worse. In order to help poor JKi, Curabis decide provide him with some practice problem set about computation geometry.One of those problems is this:Give a set of N2d-points on the plane, is there any three 2d-points of the 2d-point set areable to constructive an triangle, and all 2d-points of this set are either inside of the triangle or on the edge of the triangle?Would you please help JKi finishing this program? InputThe first line of the INPUT contain a positive integer T(T<=20) which denotes the number of test cases.The first line of each case contains an integer N.The next N(3<=N<=1000) lines of each case contain the 2d-points set. The i-th line contains two real numbers Xi, Yi denote the position of the 2d-point.It is guaranteed that -1000.00<= Xi, Yi <=1000.00, and all real numbers in the input keep two decimal places exactly.It is guaranteed that all 2d-points in any case can not stand on one straight line over all. OutputIn each line print an upper-case letter — ‘Y’ for the triangle is existed, otherwise ‘N’ instead. Sample Input:Sample Output:340.00 0.000.00 2.002.00 0.000.50 0.5040.00 0.000.00 2.002.00 0.002.00 2.0050.00 0.000.00 0.001.00 0.002.00 0.001.00 1.00YNY 梗: 其实我想说这个是不是博熊的ID啊…… <Update>啊啦被我猜对了~~题意：有好多个点，给所有点的坐标，问是否存在三个点，他们构成的三角形可以包住所有的点（在线上和在点上也算包住）思路：啊，包住，凸包嘛~ 题目等效于，这些点的凸包定点数是否不大于3，是的话输出Y，反之输出N（可以作为凸包模板哟）Code：#include <cmath>#include <cstdio>#include <vector>#include <string>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;const double EPS=1e-10;double add(double a,double b){    if( fabs(a+b) < EPS*( abs(a)+abs(b)) )return 0;    return a+b;}struct P{    double x;    double y;    P(){}    P(double x,double y):x(x),y(y){}    P operator+ (P p)    {return P(add(x,p.x),add(y,p.y));}    P operator- (P p)    {return P(add(x,-p.x),add(y,-p.y));}    P operator* (double d)    {return P(x*d,y*d);}    double dot(P p)//neiji    {return add(x*p.x,y*p.y);}    double det(P p)//waiji    {return add(x*p.y,-y*p.x);}};bool cmp_x(const P& p,const P& q){    if(p.x != q.x) return p.x<q.x;    return p.y<q.y;}vector<P> convex_hull(P* ps,int n){    sort(ps,ps+n,cmp_x);    //for(int i=0;i<n;i++){cout<<ps[i].x<<":"<<ps[i].y<<endl;}    int k=0;    vector<P> qs(n<<1);    for(int i=0;i<n;i++)    {        while( k>1 && (qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0 )k--;        qs[k++]=ps[i];    }    for(int i=n-2,t=k; i>=0; i--)    {        while( k>t && (qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0 )k--;        qs[k++]=ps[i];    }    qs.resize(k-1);    return qs;}int N;P ps[1024];void solve(){    vector<P> qs = convex_hull(ps,N);    //cout<<qs.size()<<endl;    if(qs.size()<=3)printf("Y\n");    else printf("N\n");}int main(){    freopen("G.in","r",stdin);    int T; scanf("%d",&T);    for(int _T=0;_T<T;_T++)    {        double tx,ty;        scanf("%d",&N);        memset(ps,0,sizeof ps);        for(int i=0;i<N;i++)        {            cin>>tx>>ty;            //cout<<tx<<":"<<ty<<endl;            ps[i].x=tx;            ps[i].y=ty;        }        solve();    }    return 0;}教主标程Code：#include<iostream>#include<cstdio>#include<cstdlib>#include<ctime>#include<cstring>#include<cmath>#include<algorithm>#include<set>#include<map>#include<vector>using namespace std;#define N 1010const double eps = 1e-9;struct pnt{double x, y;pnt operator+(const pnt &p) const {pnt ret; ret.x=x+p.x;ret.y=y+p.y; return ret;}pnt operator-(const pnt &p) const {pnt ret; ret.x=x-p.x;ret.y=y-p.y; return ret;}pnt operator*(const double c) const {pnt ret; ret.x=x*c;ret.y=y*c; return ret;}pnt operator/(const double c) const {pnt ret; ret.x=x/c;ret.y=y/c; return ret;}} p[N];inline double submul(const pnt &p1, const pnt &p2) { return p1.x*p2.y-p2.x*p1.y; }inline double dist2(const pnt &p1, const pnt &p2){ return (p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y); }int main(){int T;scanf("%d", &T);while(T--){int n, a, b, c;scanf("%d", &n);for(int i=0; i<n; i++)scanf("%lf%lf", &p[i].x, &p[i].y);for(int i=a=0; i<n; i++){if (p[i].y-p[a].y<-eps || (p[i].y-p[a].y<eps && p[i].x-p[a].x<-eps))a=i;}for(int i=b=c=0; i<n; i++){if (i==0 && a==0){ i++; b++; c++; }double sib=submul(p[i]-p[a], p[b]-p[a]);if(sib>eps || (sib>-eps && dist2(p[i], p[a])-dist2(p[b], p[a])>eps))b=i;double sic=submul(p[i]-p[a], p[c]-p[a]);if(sic<-eps || (sic<eps && dist2(p[i], p[a])-dist2(p[c], p[a])>eps))c=i;}int flag=1;for (int i=0; i<n; i++){if (submul(p[c]-p[b], p[i]-p[b])<-eps){flag=0;break;}}if(flag){printf("Y\n");}else printf("N\n");}return 0;}关于标程，有一个地方没能弄明白……submul(p[c]-p[b], p[i]-p[b])<-eps这里的<-符号并没有见过，如果有人知道这个的意思请务必告诉我，谢谢~~<Update> 教主亲切的给出了答复……  啊啊啊啊啊居然是小于负的eps，脸都丢尽了啊啊啊啊啊…… 啊啦啦~如果有什么我写的不够清楚的或者还有什么想要问的想要提的建议，请务必回复告知我~我会在看到的第一时间为您解答~版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/46273797	前言ACM/ICPC(Association for Computing Machinery – International Collegiate Programming Contest, 美国计算机协会-国际大学生程序设计竞赛)是由国际计算机界历史悠久、颇具权威性的组织ACM主办的年度竞赛活动，是世界上公认规模最大、水平最高的国际大学生程序设计竞赛。经ACM/ICPC授权，华东理工大学于2015年5月23、24日举办“2015ACM国际大学生程序设计竞赛上海大都会赛”。正在敲的那个就是我啦~ 话说居然就给了我个背影 不开心！学校新闻网给我们写的新闻~http://news.cqu.edu.cn/news/article/show.php?itemid=68397这次于2015年5月23日至24日在华东理工大学举行。来自重庆大学、上海交通大学、北京航空航天大学、复旦大学、中国科技大学等91个高校的190余支队伍参加此项赛事。咳咳，那么严肃多不好玩，啦啦啦我们拿了银牌~~ 我们总共出了BEFGJ五道题，其中吾辈出了BEF三道，G题出自@suyuxuan，J题出自@KingLizard，他们的代码也将贴在下方，并辅以解释。虽然还远远不及前面巨巨们伟岸的身影，但我们也继续努力着，期望以后能获得更好的成绩。（如若下文中有说得不对的地方，请予以指出，我会在看到后第一时间进行修正，谢谢^_^）解题报告啊话说代码啥的我放到GitHub上了，也可以去那里看以及下载代码：https://github.com/okcd00/ACM_Road/tree/master/ACM_Contest/Shanghai_20150525A. ArticleQWZeng学长的解题报告：传送门题意：“这是一道概率dp+贪心题；建立状态dp[i]， 表示敲出i个字符的期望次数， 那么有 dp[i] = dp[i-1] + p*(1 + dp[i]) + (1-p);解释一下： 敲出i个字符， 首先得敲出i-1个字符， 所以有第一部分的dp[i-1]； 然后敲下一个字符时， 有两种可能， p概率会丢失， （1-p)概率不会丢失, 对于丢失的情况就还得重新敲dp[i]次了（期望次数）， 不丢失的情况就只有一次就成功了， 所以是(1-p) * 1。解出 dp[i] = （dp[i-1] + 1) / ( 1- p), dp部分就搞定了;接下来是贪心部分； 我们能够看出来dp[i]的导数是递增的， 也就是说dp[i]随i的增大， dp[i]增大的越快。 所以如果对于i个字符分两部分来完成的话， 两个部分尽量均匀才是最优的(高中数学， 画个图像也很容易理解)； 所以我们可以枚举保存的次数k, 保存k次就相当于把n个字符分成k部分来完成， 由上面结论可知， 这k部分尽量均匀。”   ——QWZeng代码如下： By @QWZengCode：#include<cstdio>#include<cstdlib>#include<cmath>#include<cstring>#include<iostream>#include<string>#include<vector>#include<algorithm>#include<vector>#include<map>#include<set>#include<queue>using namespace std;#define ll long long#define inf 0x3f3f3f3fconst int maxn = 110010;int n, x;double p, dp[maxn];double cal(int k) {    int len = n/k;    double ans = 0;    if(n%k) {        ans = (dp[len + 1] + x) * (n%k) + (dp[len] + x) * (k - n%k);    }    else {        ans = (dp[len] + x) * k;    }    return ans;}int main() {    int t; scanf("%d", &t);    for(int cas=1; cas<=t; cas++) {        printf("Case #%d: ", cas);        scanf("%d%lf%d", &n, &p, &x);        for(int i=1; i<=n+x; i++) dp[i] = (dp[i-1] + 1) / (1-p);        int k = 1;        for(; k<n; k++) {            if(dp[k+1] <= (dp[k] + x + dp[1])) continue;            else break;        }        double ans = dp[n] + x;        for(int i=2; i<=n; i++) ans = min(ans, cal(i));        printf("%.6f\n", ans);    }    return 0;}B. Base64题意：这道题是一个编码题，以现行的Base64加密方法（似乎是隔壁信息安全班似乎密码学课最简单的作业之一），将给定的字符串str，加密k次，输出得到的结果。关于Base64，实际上是这么个意思(默默说一句很多下载地址都是用这个方式加密的)：在给定字符串中每次取三个字符，他们用ASCII码表示是3个8位的二进制位，分成4个六位的小段落，每个小段代表的数字在下表中找到对应的，这四个字符就是这三个字符的Base64加密后的字符，然而字符串最末如果不足3个字符，先将有的字符转换成二进制位，六个二进制位作为一个字符，如果某一个小段不足六位补0，从下一个小段起补‘=’号，所以Base64密文的长度一定是4的倍数。代码如下：Code：#include<cstdio>#include<string>#include<cstring>#include<iostream>#include<algorithm>using namespace std;typedef long long ll;const string codec = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";int trans(string s){int ret=0;for(int i=0;i<s.length();i++){ret=ret<<8;int t=(int)s[i];ret+=t;}return ret;}string Base64(string str, int k){if(k==0) return str;int i=0,vplus=str.length()%3,zero=0;if(vplus) for(int v=0;v<3-vplus;v++) str+=(char)zero;string ret="";for(i=0; i+3<=str.length(); i+=3){int t=trans(str.substr(i,3));string tmp="";for(int j=0;j<4;j++){int code=t%(1<<6);t/=(1<<6);tmp=codec[code]+tmp;}ret+=tmp;}if(vplus==0) return Base64(ret,k-1);else if(vplus==1) return Base64(ret.substr(0,ret.length()-2)+"==",k-1);else return Base64(ret,substr(0,ret.length()-1+"=",k-1);}int main(){int T=0;cin>>T;for(int _T=1;_T<=T;_T++){int k;string str;scanf("%d",&k);getchar();getline(cin,str);cout<<"Case #"<<_T<<": "<<Base64(str,k)<<endl;}return 0;}这里我是直接不够的位数都补成0，然后根据字符串长度mod3的结果来将最后的1或2位置换为‘=’号啊对了，以及少量的位操作。E. Exam题意：啊啦，这个是个大家都深有体会的考前复习算法（噗，这也能叫算法）。以当前时刻起，告知有n场考试，每场考试有3个属性：r (Review: 通过这场考试所需要花费的时间)，e (Exam: 考试开始时间)，l (Last_time: 考试持续时间)问：能不能通过所有的考试这很明显是贪心吧（复习中谁用的不是贪心算法告诉我=-=）我们用rest代表我们所有的空闲时间，（每场考试开始时间减去前一场考试的结束时间，第一场考试视作第零场考试结束于0时）无考试的时间为空闲，加入rest中，和这场考试所需要的复习时间比较，如果够了则在rest中减去所需要的复习时间，反之，这场考试挂科妥妥的。代码如下：Code：#include<cstdio>#include<string>#include<cstring>#include<iostream>#include<algorithm>using namespace std;typedef long long ll;struct testBag{ll r;ll e;ll l;}test[100086];int cmp(const void *_a, const coid *_b){struct testBag *a = (testBag *)_a;struct testBag *b = (testBag *)_b;return a->e - b->e;}int main(){int T;cin>>T;for(int _T=1;_T<=T;_T++){int n=0;scanf("%d",&n);ll last=0, rest=0;int flag=1;//can pass;for(int i=0;i<n;i++){scanf("%lld%lld%lld",&test[i].r,&test[i].e,&test[i].l);}qsort(test,n,sizeof(test[0]),cmp);for(int i=0;i<n;i++){ll r,e,l;//review,exam,lastr=test[i].r;e=test[i].e;l=test[i].l;if(flag!=1) continue;rest += (e-last);if(rest<r) flag=0;else{rest-=r;last=e+l;}}printf("Case #%d: ",_T);if(flag==1) printf("YES\n");else printf("NO\n);}return 0;}用到了结构体排序，啊啦啊啦第一次在正式比赛用结构体排序，心里还是略微有点抖~~~结构体排序是个很方便的东西，大家可以记录下来以后用~F. Friends题意：给了一个惊天地泣鬼神的Venn图，问有多少种满足这个Venn图的取值。纠结了半天之后发现是32的n次方。啊啦大数据走起，JAVA里的BigInteger大家要会用才行哦~代码如下：Code：import java.util.Scanner;import java.math.BigInteger;public class Main{public static void main(String[] args){Scanner sc=new Scanner(System.in);int t=sc.nextInt();if(k==0) System.out.println("Case #"+z+": "+"1");else{BigInteger ans=BigInteger.valueOf(1);for(int i=1;i<=k;i++) ans=ans.multiply(BigInteger.valueOf(32));System.out.println("Case #"+z+": "+ans);}}}G. Game题意："题意就是一棵树，然后每个点上有一个值，每个值只能取一次 然后进行k此搜索，每次只能从树根往下，不能回头 问你最大能够取多少" ——Suyuxuan“解法的话，对于每个叶子节点设立一个潜力值，这个值等于从树根一直走到它能够取到的值 根据潜力值给叶子进行倒叙排序 之后，再从叶子向根上回溯即可，注意走过的点做标记，碰到标记了的点就停止 再取前k大的求和即可”  ——Suyuxuan代码如下（@Suyuxuan）Code:#include <iostream>#include <cstdio>#include <cstring>#include <queue>#include <vector>#include <cmath>#include <cstdlib>#include <string>#include <map>#include <set>#include <algorithm>#include <functional>#define rep(i,a,b) for (int i=a;i<((b)+1);i++)#define Rep(i,a,b) for (int i=a;i>=b;i--)#define foreach(e,x) for (__typeof(x.begin()) e=x.begin();e!=x.end();e++)#define mid ((l+r)>>1)  //segement tree#define lson (k<<1)     //segement tree#define rson (k<<1|1)   //segement tree#define MEM(a,x) memset(a,x,sizeof a)#define L ch[r][0]                  //splay tree#define R ch[r][1]                  //splay tree#define keyvalue ch[ch[root][1]][0] //splay treeusing namespace std;const int N=1000050;const long long Mod=1e9+7;const int inf=0x3f3f3f3f;typedef pair<int, int> pii;typedef long long ll;int pnt[N],head[N],nxt[N],cnt,fa[N],a[N],n,m,k;bool vis[N];struct P{    int u;ll w;    P(){}    P(int _u,ll _w) {        u=_u;w=_w;    }};void addedge(int u,int v) {    pnt[cnt]=v;nxt[cnt]=head[u];head[u]=cnt++;}vector<P>   vt;bool cmp(const P &a,const P &b) {    return a.w>b.w;}void dfs(int u,int f,ll w) {    bool flag=true;    fa[u]=f;    for (int i=head[u];i!=-1;i=nxt[i]) {        int v=pnt[i];        if (v==f)   continue;        flag=false;        dfs(v,u,w+a[v]);    }    if (flag)   vt.push_back(P(u,w));}int main(int argc, const char * argv[]) {    int T;    scanf("%d",&T);    rep(z,1,T) {        scanf("%d%d",&n,&k);        MEM(head,-1);MEM(vis,false);        cnt=0;        rep(i,1,n)  scanf("%d",&a[i]);        rep(i,1,n-1) {            int u,v;            scanf("%d%d",&u,&v);            addedge(u, v);            addedge(v, u);        }        dfs(1,1,a[1]);        sort(vt.begin(),vt.end(),cmp);        ll ans=0;        priority_queue<ll,vector<ll>,less<ll> > p;        rep(i,0,vt.size()-1) {            P cur=vt[i];            ll tmp=0;int u=cur.u;            while (!vis[u]) {                tmp+=a[u];                vis[u]=true;                u=fa[u];            }            p.push(tmp);        }        rep(i,1,k) {            if (p.empty())  break;            ans+=p.top();p.pop();        }        printf("Case #%d: %lld\n",z,ans);    }    return 0;}J. Joyful题意：关于算法，KingLizard这样说：“算每个点被选中的期望，然后加起来即可：对每个点，先算出不能覆盖该点的概率，然后求出k次都不能覆盖该点的概率，然后用1减”代码如下（@KingLizard）Code:#include<cstdio>#include<iostream>#include<algorithm>#define rep(i,a,b) for(int i=a;i<b+1;i++)#define lson (k<<1)#define rson (k<<1|1)#define mid ((l+r)>>1)using namespace std;typedef long long ll;int n,m,k;double pow(double a,int b){double res=1.0;while(b>0){if(b&1) res=res*a;a=a*a;b>>=1;}return res;}int main(){int T;scanf("%d",&T);rep(z,1,T){scanf("%d%d%d",&n,&m,&k);double ans=0.0;for(double x=1.0; x<=(double)n; x+=1)for(double y=1.0; y<=(double)m; y+=1){double temp=0.0;temp+=(x-1)/n*(x-1)/n + (y-1)/m*(y-1)/m + (n-x)/n*(n-x)/n + (m-y)/m*(m-y)/m;temp-=(x-1)/n*(y-1)/m*(x-1)/n*(y-1)/m + (x-1)/n*(m-y)/m*(x-1)/n*(m-y)/m;temp-=(n-x)/n*(y-1)/m*(n-x)/n*(y-1)/m + (n-x)/n*(m-y)/m*(n-x)/n*(m-y)/m;double tmp=pow(temp,k); ans+=1-tmp;}printf("Case #%d: %.f\n",z,ans);}return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/45889195	Censored!Time Limit: 5000MS Memory Limit: 10000KTotal Submissions: 8623 Accepted: 2341DescriptionThe alphabet of Freeland consists of exactly N letters. Each sentence of Freeland language (also known as Freish) consists of exactly M letters without word breaks. So, there exist exactly N^M different Freish sentences. But after recent election of Mr. Grass Jr. as Freeland president some words offending him were declared unprintable and all sentences containing at least one of them were forbidden. The sentence S contains a word W if W is a substring of S i.e. exists such k >= 1 that S[k] = W[1], S[k+1] = W[2], ...,S[k+len(W)-1] = W[len(W)], where k+len(W)-1 <= M and len(W) denotes length of W. Everyone who uses a forbidden sentence is to be put to jail for 10 years. Find out how many different sentences can be used now by freelanders without risk to be put to jail for using it. InputThe first line of the input file contains three integer numbers: N -- the number of letters in Freish alphabet, M -- the length of all Freish sentences and P -- the number of forbidden words (1 <= N <= 50, 1 <= M <= 50, 0 <= P <= 10). The second line contains exactly N different characters -- the letters of the Freish alphabet (all with ASCII code greater than 32). The following P lines contain forbidden words, each not longer than min(M, 10) characters, all containing only letters of Freish alphabet. OutputOutput the only integer number -- the number of different sentences freelanders can safely use.Sample Input2 3 1abbbSample Output5SourceNortheastern Europe 2001, Northern SubregionKuang神说:"AC自动机+DP+高精度好题"最近在啃AC自动机，代码理解上尚可，但是似乎有很多变型，多看多理解才是最重要的。转载用意：DP学习+AC自动机（含矩阵加速）学习备看 & 大数据模板记录Code By Kuangbin:#include <queue>#include <cstdio>#include <string>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#include <map>map<char,int>mp;int N,M,P;struct Matrix{    int mat[110][110];    int n;    Matrix(){}    Matrix(int _n)    {        n=_n;        for(int i = 0;i < n;i++)            for(int j = 0;j < n;j++)                mat[i][j] = 0;    }};struct Trie{    int next[110][256], fail[110];    bool end[110];    int L,root;    int newnode()    {        for(int i = 0;i < 256;i++)            next[L][i] = -1;        end[L++] = false;        return L-1;    }    void init()    {        L = 0;        root = newnode();    }    void insert(char buf[])    {        int len = strlen(buf);        int now = root;        for(int i = 0;i < len;i++)        {            if(next[now][mp[buf[i]]] == -1)                next[now][mp[buf[i]]] = newnode();            now = next[now][mp[buf[i]]];        }        end[now] = true;    }    void build()    {        queue<int>Q;        fail[root] = root;        for(int i = 0;i < 256;i++)            if(next[root][i] == -1)                next[root][i] = root;            else            {                fail[next[root][i]] = root;                Q.push(next[root][i]);            }        while(!Q.empty())        {            int now = Q.front(); Q.pop();            if(end[fail[now]]==true)end[now]=true;            for(int i = 0;i < 256;i++)                if(next[now][i] == -1)                    next[now][i] = next[fail[now]][i];                else                {                    fail[next[now][i]] = next[fail[now]][i];                    Q.push(next[now][i]);                }        }    }    Matrix getMatrix()    {        Matrix res = Matrix(L);        for(int i = 0;i < L;i++)            for(int j = 0;j < N;j++)                if(end[next[i][j]]==false)                    res.mat[i][next[i][j]]++;        return res;    }    void debug()    {        for(int i = 0;i < L;i++)        {            printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],end[i]);            for(int j = 0;j < 26;j++)                printf("%2d",next[i][j]);            printf("]\n");        }    }};/* * 高精度，支持乘法和加法 */struct BigInt{    const static int mod = 10000;    const static int DLEN = 4;//per 4 digit for a section    int a[600],len;    BigInt()    {        memset(a,0,sizeof(a));        len = 1;    }    BigInt(int v)    {        memset(a,0,sizeof(a));        len = 0;        do        {            a[len++] = v%mod;            v /= mod;        }while(v);    }    BigInt(const char s[])    {        memset(a,0,sizeof(a));        int L = strlen(s);        len = L/DLEN;        if(L%DLEN) len++;        int index = 0;        for(int i = L-1;i >= 0;i -= DLEN)        {            int t = 0,k = i - DLEN + 1;            if(k < 0) k = 0;            for(int j = k;j <= i;j++)                t = t*10 + s[j] - '0';            a[index++] = t;        }    }    BigInt operator +(const BigInt &b)const    {        BigInt res;        res.len = max(len,b.len);        for(int i = 0;i <= res.len;i++)            res.a[i] = 0;        for(int i = 0;i < res.len;i++)        {            res.a[i] += ((i < len)?a[i]:0)+((i < b.len)?b.a[i]:0);            res.a[i+1] += res.a[i]/mod;            res.a[i] %= mod;        }        if(res.a[res.len] > 0)res.len++;        return res;    }    BigInt operator *(const BigInt &b)const    {        BigInt res;        for(int i = 0; i < len;i++)        {            int up = 0;            for(int j = 0;j < b.len;j++)            {                int temp = a[i]*b.a[j] + res.a[i+j] + up;                res.a[i+j] = temp%mod;                up = temp/mod;            }            if(up != 0) res.a[i + b.len] = up;        }        res.len = len + b.len;        while(res.a[res.len - 1] == 0 &&res.len > 1) res.len--;        return res;    }    void output()    {        printf("%d",a[len-1]);        for(int i = len-2;i >=0 ;i--)            printf("%04d",a[i]);        printf("\n");    }};char buf[1010];BigInt dp[2][110];Trie ac;int main(){//    freopen("in.txt","r",stdin);//    freopen("out.txt","w",stdout);    while(scanf("%d%d%d",&N,&M,&P)==3)    {        gets(buf);        gets(buf);        mp.clear();        int len = strlen(buf);        for(int i = 0;i < len;i++)            mp[buf[i]]=i;        ac.init();        for(int i = 0;i < P;i++)        {            gets(buf);            ac.insert(buf);        }        ac.build();//        ac.debug();        Matrix a= ac.getMatrix();//        for(int i = 0;i <a.n;i++)//        {//            for(int j=0;j<a.n;j++)printf("%d ",a.mat[i][j]);//            cout<<endl;//        }        int now = 0;        dp[now][0] = 1;        for(int i = 1;i < a.n;i++)            dp[now][i] = 0;        for(int i = 0;i < M;i++)        {            now^=1;            for(int j = 0;j < a.n;j++)                dp[now][j] = 0;            for(int j = 0;j < a.n;j++)                for(int k = 0;k < a.n;k++)                    if(a.mat[j][k] > 0)                        dp[now][k] = dp[now][k]+dp[now^1][j]*a.mat[j][k];//            for(int j = 0;j < a.n;j++)//                dp[now][j].output();        }        BigInt ans = 0;        for(int i = 0;i < a.n;i++)            ans = ans + dp[now][i];        ans.output();    }    return 0;}
http://blog.csdn.net/okcd00/article/details/45833227	Aho-Corasick automation该算法在1975年产生于贝尔实验室，是著名的多模匹配算法之一。一个常见的例子就是给出n个单词，再给出一段包含m个字符的文章，让你找出有多少个单词在文章里出现过。要搞懂AC自动机，先得有模式树（字典树）Trie和KMP模式匹配算法的基础知识。AC自动机算法分为3步：构造一棵Trie树，构造失败指针和模式匹配过程。看了下Cnblog上Booble的讲解，又去瞄了瞄Kuangbin的AC自动机专题，被这个算法深深的折服了（这两个链接点进去都是不错的讲解，记录于此备查备学）AC自动机其实就是在Trie树上实现KMP，可以完成多模式串的匹配，常用指数高，是个需要被尽可能早日啃透的算法。Keywords SearchTime Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 41555    Accepted Submission(s): 13179Problem DescriptionIn the modern time, Search engine came into the life of everybody like Google, Baidu, etc.Wiskey also wants to bring this feature to his image retrieval system.Every image have a long description, when users type some keywords to find the image, the system will match the keywords with description of image and show the image which the most keywords be matched.To simplify the problem, giving you a description of image, and some keywords, you should tell me how many keywords will be match. InputFirst line will contain one integer means how many cases will follow by.Each case will contain two integers N means the number of keywords and N keywords follow. (N <= 10000)Each keyword will only contains characters 'a'-'z', and the length will be not longer than 50.The last line is the description, and the length will be not longer than 1000000. OutputPrint how many keywords are contained in the description. Sample Input15shehesayshrheryasherhs Sample Output3 AuthorWiskey Recommendlcy   |   We have carefully selected several similar problems for you:  2896 3065 2243 2825 3341  先毕恭毕敬奉上邝神的代码：#include <queue>#include <cstdio>#include <string>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Maxn 500010//Max number of n #define bk 26 //Branch-kind numberstruct Trie//AcMachine Trie Tree {    int next[Maxn][bk], fail[Maxn], end[Maxn];    int root,L;    int newnode()    {        for(int i=0;i<bk;i++) next[L][i]=-1;//init *Next        end[L++] = 0;        return L-1;    }    void init()    {        L = 0;        root = newnode();    }    void insert(char buf[])    {        int len = strlen(buf);        int now = root;        for(int i = 0;i < len;i++)        {            if(next[now][buf[i]-'a'] == -1)                next[now][buf[i]-'a'] = newnode();            now = next[now][buf[i]-'a'];        }        end[now]++;    }    void build()    {        queue<int> Q;        fail[root] = root;        for(int i = 0;i < bk;i++)            if(next[root][i] == -1)                next[root][i] = root;            else            {                fail[next[root][i]] = root;                Q.push(next[root][i]);            }        while( !Q.empty() )        {            int now = Q.front();            Q.pop();            for(int i = 0;i < bk;i++)                if(next[now][i] == -1)                    next[now][i] = next[fail[now]][i];                else                {                    fail[next[now][i]]=next[fail[now]][i];                    Q.push(next[now][i]);                }        }    }    int query(char buf[])    {        int len = strlen(buf),        now = root,        res = 0;        for(int i = 0;i < len;i++)        {            now = next[now][buf[i]-'a'];            int temp = now;            while( temp != root )            {                res += end[temp];                end[temp] = 0;                temp = fail[temp];            }        }        return res;    }    void debug()    {        for(int i=0;i<L;i++)        {            printf("id = %3d,fail = %3d,end = %3d,\nchi = [",i,fail[i],end[i]);            for(int j = 0;j < 26;j++) printf("%2d",next[i][j]);            printf("]\n");        }    }};char buf[Maxn*2];Trie ac;int main(){    int T,n;    scanf("%d",&T);    for(int _T=1; _T<=T; _T++)    {        scanf("%d",&n);        ac.init();        for(int i = 0;i < n;i++)        {            scanf("%s",buf);            ac.insert(buf);        }        ac.build();        scanf("%s",buf);        printf("%d\n",ac.query(buf));        //ac.debug();    }    return 0;}这个所有操作都在Trie树中封装好的Struct写法实在是高超而精简，争取早日啃透然后灵活运用起来~~Code：然后上个ACCODE：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))#define N 500010#define Maxn 51char str[N*2], keyword[Maxn];int head, tail;struct node{node *fail;node *next[26];int count;node() //init{fail = NULL;count = 0;for(int i = 0; i < 26; ++i)next[i] = NULL;}}*q[N], *root;void insert(char *str) //Insert into Trie{int temp, len;node *p = root;len = strlen(str);for(int i = 0; i < len; ++i){temp = str[i] - 'a';if(p->next[temp] == NULL)p->next[temp] = new node();p = p->next[temp];}p->count++;}void build_ac() //Init Fail_Pointer ,then BFS{q[tail++] = root;while(head != tail){node *p = q[head++]; //get the headnode *temp = NULL;for(int i = 0; i < 26; ++i){if(p->next[i] != NULL){if(p == root) //If failed at 1st Letter, jump to root.p->next[i]->fail = root;else{temp = p->fail; //'Temp' to mark Fail-Pointerwhile(temp != NULL) //break if Find the Match Or Match-sequence is Null{if(temp->next[i] != NULL) //Find the Match{p->next[i]->fail = temp->next[i];break;}temp = temp->fail;}if(temp == NULL) //If Null,p->next[i]->fail = root;}q[tail++] = p->next[i]; //enqueue}}}}int query() //return appearance time{int index, len, result;node *p = root; //Trie Entranceresult = 0;len = strlen(str);for(int i = 0; i < len; ++i){index = str[i] - 'a';while(p->next[index] == NULL && p != root) //jump to Fail_Pointerp = p->fail;p = p->next[index];if(p == NULL) p = root;node *temp = p; //Let temp record p's location. Then calc it.while(temp != root && temp->count != -1){result += temp->count;temp->count = -1;temp = temp->fail;}}return result;}int main(){int ncase, num;scanf("%d", &ncase);for(int _case=1;_case<=ncase;_case++){head= tail = 0;root = new node();scanf("%d", &num);getchar();for(int i = 0; i < num; ++i){gets(keyword);insert(keyword);}build_ac();scanf("%s", str);printf("%d\n", query());}return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/45726137	环境：Hex Workshop先解决DOS头。在弹出的对话框中选择十六进制，字节数量填40。点确定，40h就是DOS头的大小。光标插到第一字节前，输入4D5A，对应ASCII码MZ，这是DOS可执行文件标志。如图，最后四个字节用来指示PE文件头开始的地址，我们的PE头将从00000040位置开始，所以把最后四个字节改为40 00 00 00（低低高高对应关系）。DOS头完成了，是不是很简单啊！―――――――――――――――――――――――――――――――――――下面就是PE头，不过它比较复杂，在讲PE头之前我们先看几个重要的概念：文件偏移地址和相对虚似地址，上图黄色框中所示的就是文件偏移地址。即某个数据位置相对于文件头的偏移量。文件执行过程中会把文件映射到内存中，在内存中文件头被映射到某一位置。其它字节的位置相对于头部映射的位置被称为相对虚似地址（RVA）。文件从磁盘到内存映射过程中发生了一些变化。也就是怎样“对齐”的概念。比如，一本书如果用32K的纸来印刷的话，假设一页32K的纸能容纳100个字，假设第一章有113个字，那么需要一页多一点的纸张（但下一章必须从新的一页开始），多出的地方就是空白（相当于文件中用0填充），所以第一章会占两页32K的纸。假如现在用8K的纸来印刷的话，假设一页8K的纸能容纳400个字，那么第一章只用一页8K纸可以了。（因为第二章将从新一页开始），没字的部分就是空白（相当于文件中用0填充）。在文件中“1页纸”一般200字节，在内存中一般1000字节。 ―――――――――――――――――――――――――――――――――――让我们继续吧！PE头我们分成二块来讲。第一部分：在空白的地方如前面的方法，插入18H个字节的0。需要修改的字节如图所示：①处4个字节PE文件头的标志对应ASCII：PE\0\0；②处2个字节说明运行平台，014c表示intel处理器；③区块个数，相当于一本书多少章；④PE头第二部分的大小（可选头文件大小）⑤文件属性，普通exe文件一般是010f。第二部分：插入E0h个字节。需要修改的字节如图所示：①标志字，普通可执行映像一般是010B。②程序入口RVA，对应.text块的RVA，一般是1000。③文件装入内存的起始地址，一般是00400000。④内存对齐，1000，很重要。⑤磁盘对齐，是200，很重要。⑥要求最低子系统版本的主版本号，一设为0004对应win32子系统。⑦文件装入内存后的总大小，内存对齐是1000。DOS头＋PE头＋块表占1000字节；.text、.rdata、.data块分别占1000字节。所以这儿填4000。⑧DOS头＋PE头＋块表在磁盘中所占大小，磁盘对齐是200，这儿填00 02 00 00⑨这个可执行文件所期待的子系统，02为图形接口子系统。⑩ 对应最下面红框中数据的个数（8字节一组），PE文件基本都是10h。―――――――――――――――――――――――――――――――下面是块表块表是对块的位置、大小以及一些属性的说明。每个块表一共占28h个字节，一共3个块，新插入78h.。我们以.text块表为例，①处共8个字节是块名，以“.”开头，后面填充0。 ②区块的实际大小，这儿是26h（请改成27），后面我们会知道他是怎么得出的。 ③.text块的RAV是1000，对应前面讲的程序入口地址。(后面的.rdata区块是2000，.data区块是3000) ④ 在磁盘文件上大小，200h(后面的.rdata和.data区块都是200) ⑤在磁盘文件上偏移，200(后面的.rdata区块是400，.data区块是600) ⑥块属性，具体请有兴趣的参考相关资料。 前言与目录结束了，还有最后一件事，DOS头＋PE头＋块表在磁盘中所占大小是以200字节对齐的，而现在还没到200字节，所以后面我们还要填50h字节的0。 下面是三个区块，首先是200字节的.text区。填充200字节的0再填充200字节的0，作为.rdata。再填充200字节的0，作为.data。 .data块主要用来存放数据，我们一共有二个字符串要存储。就是MessageBox的标题和上面显示的文字。 记住它们首地址偏移分别是00403000和00403017一会有用。（这些都是RVA，前面讲PE头时，我们设文件装入内存的起始地址是00400000，.data块的RVA是3000，下面都会算了吧^-^）因为我们要显示一个消息框，所以要从外部导入user32.dll库中的MessageBox函数，程序退出要导入kernel32.dll库中的ExitProcess函数。怎么导入呢，这就和输入表有关啦。前面讲PE头第二部分有个标A的地方没讲，还有印像吗？那8个字节的数据就和输入表有关，前4个字节是输入表地址，后面是大小。每导入一个DLL，我们就需要一个导入表。这个程序我们从2个DLL中导入函数，所以要2个输入表。那第一个输入表是不是从.rdata块首地址开始呢？不是这样的，这里有个规律，我们要导入多少个函数，那么就要空出8乘以导入函数的个数，这儿就空出16个字节，PE头中我们定义输入表的RAV是00 00 20 10对应。如图每个输入表占14h个字节，最后以一个空表作为结束标志。我们以输入表1为例来分析下输入表，输入表前4个字节所表示的地址指向一组指针，这些指针指向我们引用的所有引用的函数的名称。这些指针位于输入表空表之后，偏移为0000044c的位置，这个是磁盘偏移，转化为RAV为0000204c。从044c位置空出4个字节写指针（上面所知，该程序一个DLL对应一个函数），空出4个字节置0，作为结束的标志。输入表2和输入表1一样，也会占用8个字节。从044c开始再空出10h的字节，这就到了045c了。从这儿开始输入我们要调用的函数名和对应该的DLL名称，函数名前空出两个字节。结果如图所示！！字符串写好后，就可以把044c处的指针填上了！输入表1的②四个字节对应该输入表DLL名称的RAV，如图，在磁盘上偏移是046A 这里是user32.dll，将这儿046A转化为RAV为206A，所以这儿填6A 20 00 00。③处三个字节同①一样，指向一组指针，这些指针指向我们引用的所有引用的函数的名称。这些指针就放在我们前面刚空出的10h个字节。―――――――――――――――――――――――――――――――现在解决.text区块了代码如下：压参数：Push 0Push 00403000Push 00403013Push 0Call dword ptr ds:[402008]Push 0Call dword ptr ds:[402000]jmp dword ptr [402008]jmp dword ptr [402000]附上HEX程序码00000000 4D 5A 00 00 00 00 00 00 00 00 00 00 00 00 00 00 MZ..............00000010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000030 00 00 00 00 00 00 00 00 00 00 00 00 40 00 00 00 ............@...00000040 50 45 00 00 4C 01 03 00 00 00 00 00 00 00 00 00 PE..L...........00000050 00 00 00 00 E0 00 0F 01 0B 01 00 00 00 00 00 00 ................00000060 00 00 00 00 00 00 00 00 00 10 00 00 00 00 00 00 ................00000070 00 00 00 00 00 00 40 00 00 10 00 00 00 02 00 00 ......@.........00000080 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ................00000090 00 40 00 00 00 02 00 00 00 00 00 00 02 00 00 00 .@..............000000A0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000000B0 00 00 00 00 10 00 00 00 00 00 00 00 00 00 00 00 ................000000C0 10 20 00 00 3C 00 00 00 00 00 00 00 00 00 00 00 . ..<...........000000D0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000000E0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000000F0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000100 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000110 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000120 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000130 00 00 00 00 00 00 00 00 2E 74 65 78 74 00 00 00 .........text...00000140 26 00 00 00 00 10 00 00 00 02 00 00 00 02 00 00 &...............00000150 00 00 00 00 00 00 00 00 00 00 00 00 20 00 00 60 ............ ..`00000160 2E 72 64 61 74 61 00 00 92 00 00 00 00 20 00 00 .rdata....... ..00000170 00 02 00 00 00 04 00 00 00 00 00 00 00 00 00 00 ................00000180 00 00 00 00 40 00 00 40 2E 64 61 74 61 00 00 00 ....@..@.data...00000190 3E 00 00 00 00 30 00 00 00 02 00 00 00 06 00 00 >....0..........000001A0 00 00 00 00 00 00 00 00 00 00 00 00 40 00 00 C0 ............@...000001B0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000001C0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000001D0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000001E0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000001F0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000200 6A 00 68 00 30 40 00 68 11 30 40 00 6A 00 FF 15 j.h.0@.h.0@.j...00000210 08 20 40 00 6A 00 FF 15 00 20 40 00 FF 25 08 20 . @.j.... @..%. 00000220 40 00 FF 25 00 20 40 00 00 00 00 00 00 00 00 00 @..%. @.........00000230 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000240 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000250 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000260 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000270 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000280 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000290 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000002A0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000002B0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000002C0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000002D0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000002E0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000002F0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000300 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000310 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000320 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000330 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000340 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000350 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000360 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000370 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000380 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000390 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000003A0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000003B0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000003C0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000003D0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000003E0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000003F0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000400 5C 20 00 00 00 00 00 00 78 20 00 00 00 00 00 00 \ ......x ......00000410 4C 20 00 00 00 00 00 00 00 00 00 00 6A 20 00 00 L ..........j ..00000420 00 20 00 00 54 20 00 00 00 00 00 00 00 00 00 00 . ..T ..........00000430 86 20 00 00 08 20 00 00 00 00 00 00 00 00 00 00 . ... ..........00000440 00 00 00 00 00 00 00 00 00 00 00 00 5C 20 00 00 ............\ ..00000450 00 00 00 00 78 20 00 00 00 00 00 00 80 00 45 78 ....x ........Ex00000460 69 74 50 72 6F 63 65 73 73 00 6B 65 72 6E 65 6C itProcess.kernel00000470 33 32 2E 64 6C 6C 00 00 9D 01 4D 65 73 73 61 67 32.dll....Messag00000480 65 42 6F 78 41 00 75 73 65 72 33 32 2E 64 6C 6C eBoxA.user32.dll00000490 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000004A0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000004B0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000004C0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000004D0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000004E0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000004F0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000500 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000510 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000520 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000530 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000540 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000550 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000560 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000570 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000580 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000590 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000005A0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000005B0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000005C0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000005D0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000005E0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000005F0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000600 49 63 7A 65 6C 69 6F 6E 20 54 75 74 6F 72 69 61 Iczelion Tutoria00000610 6C 20 4E 6F 2E 32 00 57 69 6E 33 32 20 41 73 73 l No.2.Win32 Ass00000620 65 6D 62 6C 79 20 69 73 20 47 72 65 61 74 21 00 embly is Great!.00000630 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000640 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000650 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000660 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000670 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000680 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000690 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000006A0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000006B0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000006C0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000006D0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000006E0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000006F0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000700 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000710 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000720 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000730 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000740 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000750 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000760 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000770 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000780 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000790 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000007A0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000007B0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000007C0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000007D0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000007E0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000007F0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/45565997	继TX之后，我迎来了我的第二次面试。这次尝试的是阿里巴巴的 【算法工程师】->【研发工程师C/C++】仔细的阅读了各种规章以及面试的时候发的纸张，确认了没有禁止对面试进行描述，没有禁止对面试题目的提及（自然我也不会精确详尽的说明每个问题，重点在于寻找可能错误的地方）之后，打算趁现在用沉重的心情做一个总结，毕竟即便失败了，大公司的面试经验也是一次宝贵的财富。希望能一点点的完善自己的不足，好好巩固各种缺陷和漏洞，这才算是最好的对待这样一场大型的面试。首先是算法岗：对于每个问题，我觉得我答得速度都并不很慢，写代码的过程中自己写的还算有效率，几个问题都想出了时间复杂度O(n)的算法解答，其中前k大的算法使用到不少次，而这个我在竞赛中有使用过，所以还算比较熟练，之后也讨论了一些其他的算法，问到是否参加天池大数据竞赛的时候，如实的回答了我有申请加入，但可惜在数据挖掘、机器学习方面所知不足，所以在自学并打算加入次年的大数据比赛。算法岗的面试官说“太可惜了”，算法工程师要求较高的是大数据算法，我的算法能力尚可，但是对于大数据方面不足，推荐去尝试研发岗。然后因为对数据挖掘和机器学习的熟练度并不够，被算法岗的面试官亲切的推荐到【研发工程师C/C++】于是一段时间的等待后是研发岗：因为讲过一遍的话短时间内再重复一遍会感觉很奇怪……于是这是我的第一个错误，在新的面试官面前我想要尽量使用之前算法岗面试的地方没有说过的东西，尽可能的不重复，这造成了新的研发岗面试官询问问题的时候没有得到全面的回答，当我意识到这个问题的时候，我说到“啊这个部分刚刚在那个面试官面前说过了”，当发现面前的面试官似乎并不知道我面试过一次而且是另外的岗位的时候，我开始慌张的解释我原先报的是算法后来被推荐过来的，同时心里深深的担忧，之前的面试官应该没有时间把我先前的表现以及信息告知新的面试官，而我之前自以为他们通过网络互通了信息……不确定的事情一定要问啊。然后，研发岗的面试官问了很多算法和数据结构相关的东西。因为平时有自己做过一些研究，关于红黑树、大文件排序、变量存放等问题还是有知道的，但是我的思维模式有些固化，回答每一个的时候都喜欢加上铺垫以及引用，这在时间上造成了极大的拖延，往往没有回答完毕就被告知“就到这里吧不用继续说了”……其中，要求我随意的写出3种排序，并告知时间复杂度，因为我写了一个基数排序，突然被告知要时间复杂度的时候我就慌了，因为基数排序我其实并不知道时间复杂度……临时赶紧凑了几个测试样例，思考了一下，姑且算了一下时间复杂度……提交的时候心也很抖……时间耽误的也比较久，对大家都觉得是基础的排序算法的时间复杂度却花了这么长时间，被误以为在演或者在装或者甚至连这么简单的都不会都是在正常不过了的吧……不会的还是最好当场说出来，不要拖延时间（无论是不是有意的），而且发现自己会的题目不要太过于喜形于色地说，注意语速是否能让对方听清，逻辑是否正确，时刻不要让面试官觉得你是一个急躁、不够冷静的人。（这正是我自认为面试过程之中我所表现出来的……）之后有几个有点烧脑子的题目，可惜似乎我回答的有点快，没有留下什么印象……但我所留下的印象是，似乎我都太急了，没有足够的思考，事后想起来没有考虑特殊用例，太紧张了反而平时养成习惯的校验查特例都忘记了……我觉得最重要的，以及在这次经历中学到最多的……就是最后的那个问题……“你经常在网络上看，比如ＣＳＤＮ之类的，你知道现在的潮流导向吗？”“物联网，信息安全和固态存储？”“比如……大数据，数据挖掘，机器学习……　那么在这么多方向当中，你有属于自己的方向吗？”哑口无言……一向将“什么都想要尝试一下，什么都想要学习”作为自己的理念……然而……并没有一个固定的专精的目标……　想起来，为了“拒绝平庸”广而习之，反而因为没有目标，而变得平庸……需要一个目标，并且把今后的学习，都朝着这个目标前进……为什么！为什么我以前都没有觉察到！好希望，能再从大一开始一次……最后，非常感谢，研发岗的面试官……　虽说您不可能看得到这篇文章，虽然没能进入您所在的公司进行实习，但是，学到了很多，真的，谢谢。版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/45484491	前言这次作为嵌入式系统与应用的中期考试，老师要求写一个红绿灯的程序（包括车辆&行人），要求在单片机上可持续合理化运行简化如下：十字路口中，南北方向与东西方向均只考虑直行，行人红绿灯仅考虑东侧的南北向人行道话说……实验要求什么的看起来似乎很长哎…… 如果不想看那么长的实验要求的话，推荐用书签直接跳转到想看的地方去~实验要求文档PREPARATIONYou will need aLaunchPad, a three switches, three 10kΩ resistors, six LEDs, and six 470Ωresistors. Run the Lab10 starter file in the simulator and on the realboard just to make sure the configurations are correct. Download the data sheetfor the LED HLMP-4700.pdfSTARTER PROJECTLab10_TrafficLightPURPOSEThis lab hasthese major objectives: 1) the understanding and implementing of indexed datastructures; 2) learning how to create a segmented software system; and 3) thestudy of real-time synchronization by designing a finite state machinecontroller. Software skills you will learn include advanced indexed addressing,linked data structures, creating fixed-time delays using the SysTick timer, anddebugging real-time systems. Please read the entire lab before starting.SYSTEM REQUIREMENTSConsider a4-corner intersection as shown in Figure 10.1. There are two one-way streetsare labeled South (cars travel South) and West (cars travel West). There arethree inputs to your LaunchPad, two are car sensors, and one is a pedestriansensor. The South car sensor will be true (3.3V) if one or more cars are nearthe intersection on the South road. Similarly, the West car sensor will be true(3.3V) if one or more cars are near the intersection on the West road. The Walksensor will be true (3.3V) if a pedestrian is present and he or she wishes tocross in any direction. This walk sensor is different from a walk button onmost real intersections. This means when you are testing the system, you mustpush and hold the walk sensor until the FSM recognizes the presence of thepedestrian. Similarly, you will have to push and hold the car sensor until theFSM recognizes the presence of the car. In this simple system, if the walksensor is +3.3V, there is pedestrian to service, and if the walk sensor is 0V,there are no people who wish to walk. In a similar fashion, when a car sensoris 0V, it means no cars are waiting to enter the intersection. You willinterface 6 LEDs that represent the two Red-Yellow-Green traffic lights, andyou will use the PF3 green LED for the “walk” light and the PF1 red LED for the“don’t walk” light. When the “walk” condition is signified, pedestrians areallowed to cross. When the “don’t walk” light flashes (and the two trafficsignals are red), pedestrians should hurry up and finish crossing. When the“don’t walk” condition is on steady, pedestrians should not enter theintersection.Figure 10.1.Traffic Light Intersection.Traffic shouldnot be allowed to crash. I.e., there should not be only a green or only ayellow LED on one road at the same time there is only a green or only a yellowLED on the other road. You should exercise common sense when assigning thelength of time that the traffic light will spend in each state; so that thegrading engine can complete the testing in a reasonable amount of time. Eachtraffic light pattern must be on for at least ½ second but for at most 5seconds. (During simulation grading, we suggest you make all times less than 1second.) Cars should not be allowed to hit the pedestrians. The walk sequenceshould be realistic, showing three separate conditions: 1) “walk”, 2) “hurryup” using a flashing LED, and 3) “don’t walk”. You may assume the three sensorsremain active for as long as service is required. The “hurry up” flashingshould occur at least twice but at most 4 times.The automaticgrader can only check for function (does a pattern of inputs, resultin the correct outputs.) In particular, the grader performs these checks:0) At all times,there should be exactly one of the {red, yellow, green} traffic lights activeon the south road. At all times, there should be exactly one of the {red,yellow, green} traffic lights active on the west road. To switch a light fromgreen to red it must be yellow for at least ½ sec. The grader checks for theproper sequence of output patterns but does not measure the time the FSM spendsin each state. The “walk” and “don’t walk” lights should never both be on atthe same time.1) Do not allowcars to crash into each other. This means there can never be a green or yellowon one road at the same time as a green or yellow on the other road. Engineersdo not want people to get hurt.2) Do not allowpedestrians to walk while any cars are allowed to go. This means there cannever be a green or yellow on either road at the same time as a “walk” light.Furthermore, there can never be a green or yellow on either road at the sametime as the “don’t walk” light is flashing. If a green light is active on oneof the roads, the “don’t walk” should be solid red. Engineers do not wantpeople to get hurt.3) If just thesouth sensor is active (no walk and no west sensor), the lights should adjustso the south has a green light within 5 seconds (I know this value isunrealistically short, but it makes the grading faster). The south light shouldstay green for as long as just the south sensor is active.4) If just thewest sensor is active (no walk and no south sensor), the lights should adjustso the west has a green light within 5 seconds. The west light should staygreen for as long as just the west sensor is active.5) If just thewalk sensor is active (no west and no south sensor), the lights should adjustso the “walk” light is green within 5 seconds. The “walk” light should staygreen for as long as just the walk sensor is active.6) If all threesensors are active, the lights should go into a pattern such within one20-second period that the west light is green for at least 1 second, the southlight is green for at least 1 second and the “walk” light is green for at least1 second.The gradingengine can only check for function, not for the quality of your software. Thissection describes, in qualitative manner, what we think is good design. Thereis no single, “best” way to implement your system. A “good” solution will haveabout 9 to 30 states in the finite state machine, and provides for inputdependence. Try not to focus on the civil engineering issues. I.e., first builda quality computer engineering solution that is easy to understand and easy tochange, and then adjust the state graph so it passes the functional tests ofthe automatic grader. Because we have three inputs, there will be 8 next statelinks. One way to draw the FSM graph to make it easier to read is to use X tosignify don’t care. For example, compare the two FSM graphs in Figure 10.2.Drawing two arrows labeled 01 and 11 is thesame as drawing one arrow with the label X1. When we implement thedata structure, however, we will expand the shorthand and explicitly list allpossible next states.Figure 10.2. FSMfrom Chapter 10 redrawn with a short hand format.The followingare some qualitative requirements, which we think are important, but for whichthe automatic grader may or may not be able to evaluate.0) The systemprovides for input dependence. This means each state has 8 arrows such that thenext state depends on the current state and the input. This means you cannotsolve the problem by simply cycling through all the states regardless of theinput.1) Because wethink being in a state is defined by the output pattern, we think you shouldimplement a Moore and not a Mealy machine. However, your scheme should use alinked data structure stored in ROM.2) There shouldbe a 1-1 mapping between FSM graph and data structure. For a Moore machine,this means each state in the graph has a name, an output, a time to wait, and 8next state links (one for each input). The data structure has exactly thesecomponents: a name, an output, a time to wait, and 8 next state pointers (onefor each input). There is no more or no less information in the data structurethen the information in the state graph.3) There can beno conditional branches in program, other than the while in SysTick_Wait andthe for inSysTick_Wait10ms. This willsimplify debugging make the FSM engine trivial.4) The stategraph defines exactly what the system does in a clear and unambiguous fashion.In other words, do not embed functionality (e.g., flash 3 times) into thesoftware that is not explicitly defined in the state graph.5) Each statehas the same format of each state. This means every state has exact one name,one 8-bit output (could be stored as one or two fields in the struct), one timeto wait, and 8 next indices.6) Please usegood names and labels (easy to understand and easy to change). Examples of badstate names are S0 and S1.7) There shouldbe 9 to 30 states with a Moore finite state machine. If your machine has morethan 30 states, you have made it more complicated than we had in mind. Usuallystudents with less than 9 states did not flash the “don’t walk” light, or theyflashed the lights using a counter.  Counters and variables violatethe “no conditional branch” requirement.In real productsthat we market to consumers, we put the executable instructions and the finitestate machine linked data structure into the nonvolatile memory such as flashEEPROM. A good implementation will allow minor changes to the finite machine(adding states, modifying times, removing states, moving transition arrows,changing the initial state) simply by changing the linked data structure,without changing the executable instructions. Making changes to executable coderequires you to debug/verify the system again. If there is a 1-1 mapping fromFSM to linked data structure, then if we just change the state graph and followthe 1-1 mapping, we can be confident our new system operate the new FSMproperly. Obviously, if we add another input sensor or output light, it may benecessary to update the executable part of the software, re-assemble and retestthe system.The grader willactivate the PLL so the system runs at 80 MHz, you must not modify this rate.There aremany civil engineering questions that students ask. How youchoose to answer these questions will determine how good a civil engineer youare but should not affect your grade on this lab. For each question, there aremany possible answers, and you are free to choose how you want to answer it.0) How longshould I wait in each state?  Possible answer: traffic lightsat 1 to 2 seconds of real people time.Flashing “don’t walk” on for½ sec, off for a ½ sec and repeat 3 times.1) What happensif I push 2 or 3 buttons at a time? Required operation: cyclethrough the requests servicing them in a round robin fashion.2) What if Ipush the walk button, but release it before the light turns to walk? Possibleanswer: ignore the request as if it never happened. Possible answer:service it or ignore it depending on exactly when it occurred.3) What if Ipush a car button, but release it before it is serviced? Possibleanswer: ignore the request as if it never happened (e.g., car came to a redlight, came to a full stop, and then made a legal turn).  Possibleanswer: service the request or ignore it depending on when it occurred.4) Assume thereare no cars and the light is green on the North, what if a car now comes on theEast? Do I have to recognize a new input right away or wait until the end ofthe wait time? Possible answer: no, just wait until the end ofthe current wait, then service it. Possible answer: yes; breakstates with long waits into multiple states with same output but shorter waits.5) What if thewalk button is pushed while the don’t walk light is flashing? Possibleanswer: ignore it, go to a green light state and if the walk button isstill pushed, then go to walk state again. Possible answer: ifno cars are waiting, go back to the walk state. Possible answer:remember that the button was pushed, and go to a walk state after the nextgreen light state.6) Does the walkoccur on just one street or both? Required operation: stop all carsand let people walk across either or both streets. A green (or yellow) light inany direction while the “walk” light is on will cause the automatic grader topenalize you for failing check #2. The pedestrian sensor does not know whichstreet the pedestrian(s) want to cross, so you must direct all cars to stopwhile pedestrians may be in the road. You are not allowed to add additionalpedestrian sensor because the automatic grader is built to handle only theconfiguration shown in Figure 10.1. Let's walkthrough the steps of building a state transition table.  Astate transition table has exactly the same information as the state transitiongraph, but in tabular form. Let's begin with the format of the table. Therewill be a column for the state number; we will number the states sequentiallyfrom 0. We will skip the state name for now, and come back to it later. Thenext two columns will define the output patterns for six traffic lights and twowalk lights. In this table we specified the output for the 6 LEDs as "WestGreen", but once we translate it to software we will replace "WestGreen" with the explicit value to output, e.g., 0x0C . Often we will needto have multiple states with the same output value, but for now we will simplyadd a state for each possible output pattern, and later we will add additionrows as needed. The next column is the time to wait with this output. The lasteight columns will be the next states for each possible input pattern. Recallthe FSM controller will 1) output, 2) wait, 3)  input, and 4) change tothe next state depending on the current state and the input. So notice thecolumns of this table are given in this 1,2,4 order. NumName6-LEDPF3,PF1TimeIn=0In=1In=2In=3In=4In=5In=6In=70GoWestWest greenRed         1 West yellowRed         2 South greenRed         3 South yellowRed         4 All redGreen         5 All redRed         6 All redoff         Each stateshould have a descriptive name. These names will be labels in the C code, souse no spaces or special characters. The name should be short. Most importantlythe state name should describe the state of the system, or what youbelieve to the true. For example, GoWest could mean carscan go on the west road. Make the times short for this lab, neither graderchecks the times. It can be short (100ms) in simulation and 500ms on the realboard. Next, fill what to do for each input. The in=0 field iseasy (0 means no cars or people). For example, what should you do if the westroad is green and there are no cars or people?  Another easy one is in=7 (busywith cars and people). For in=7, we need to cycle through west,south and walk: {west green, west yellow, south green, south, yellow, walk,don't walk, walk off, don't walk, walk off}. To make the don't walk light flashtwice, we will need to add two more states 7,8 (rows in the table). State 7will have the road outputs red and the don't walk.  State 8  willhave the road outputs red and the walk LEDs off. In summary, the in=7 inputpattern will cycle through states 0,1,2,3,4,5,6,7,8.Once you havethis table, you convert it to C code. This is the structure from Program 10.4struct State {  unsigned long Out;   unsigned long Time;  unsigned long Next[4];};Modify thisstructure adding a line for Outputs to PF3, PF1. Change the 4 to 8, becausewith 3 inputs, each state needs 8 possible next states.  Convert the abovestate table into the FSM structure. The engine will execute 1) Output 6-LEDs2) Output PF3, PF13) Wait time4) Input from sensors5) Go to next stateThis C code will be similar to the Traffic FSM example in the Program 10.4  #define SENSOR  (*((volatile unsigned long *)0x4002400C))#define LIGHT   (*((volatile unsigned long *)0x400050FC))// Linked data structurestruct State {  unsigned long Out;   unsigned long Time;    unsigned long Next[4];}; typedef const struct State STyp;#define goN   0#define waitN 1#define goE   2#define waitE 3STyp FSM[4]={ {0x21,3000,{goN,waitN,goN,waitN}},  {0x22, 500,{goE,goE,goE,goE}}, {0x0C,3000,{goE,goE,waitE,waitE}}, {0x14, 500,{goN,goN,goN,goN}}};unsigned long S;  // index to the current state unsigned long Input; int main(void){ volatile unsigned long delay;  PLL_Init();       // 80 MHz, Program 10.1  SysTick_Init();   // Program 10.2  SYSCTL_RCGC2_R |= 0x12;      // 1) B E  delay = SYSCTL_RCGC2_R;      // 2) no need tounlock  GPIO_PORTE_AMSEL_R &= ~0x03; // 3) disable analog function on PE1-0  GPIO_PORTE_PCTL_R &=~0x000000FF; // 4) enable regular GPIO  GPIO_PORTE_DIR_R &= ~0x03;   // 5) inputs on PE1-0  GPIO_PORTE_AFSEL_R &=~0x03; // 6) regular function on PE1-0  GPIO_PORTE_DEN_R |= 0x03;    // 7) enable digital onPE1-0  GPIO_PORTB_AMSEL_R &= ~0x3F; // 3) disable analog function on PB5-0  GPIO_PORTB_PCTL_R &= ~0x00FFFFFF; // 4) enable regular GPIO  GPIO_PORTB_DIR_R |= 0x3F;    // 5) outputs on PB5-0  GPIO_PORTB_AFSEL_R &= ~0x3F; // 6) regular function on PB5-0  GPIO_PORTB_DEN_R |= 0x3F;    // 7) enable digital onPB5-0  S = goN;    while(1){    LIGHT = FSM[S].Out;  // set lights    SysTick_Wait10ms(FSM[S].Time);    Input = SENSOR;     // read sensors    S = FSM[S].Next[Input];    }}Program 10.4. Linked data structureimplementation of the traffic light controller (C10_TableTrafficLight)PROCEDURER9, R10, R25, and R29 are zero-ohmresistors on the LaunchPad. Notice in Figure 10.3 that R9 shorts PD0 to PB6,R10 shorts PD1 to PB7, R25 connects PB0 to the USB device header, and R29connects PB1 to +5V. If you use PB1 or PB0, make sure R26 and R29 are removed.If you use both PD0 and PB6, remove R9. If you use both PD1 and PB7, removeR10.  R25 and R29 are not on the older LM4F120 LaunchPads, just the newTM4C123 LaunchPads. The TM4C123 LaunchPads I bought over summer 2013 did nothave R25 and R29 soldered on, so I just had to worry about R9 and R10.Figure 10.3. Switch and LED interfaces on the Tiva LaunchPadEvaluation Board. The zero ohm resistors can be removed so the correspondingpin can be used for its regular purpose.We posted a version 1.0.0.6 which is littlemore reasonable about what it passes and what it fails. As with all graders, itbegins by checking initialization registers. During the I/O portion of thegrading, we get a notification whenever you write to either of the outputports. The grader checks for valid output pattern sequences. We have defined9valid output patterns, listed below. For each valid output pattern, there area only finite number of valid output patterns that could be next.Pattern 1) All lights are red. Once the output is at this pattern,the valid next patterns are {1,2,4,6,7,8,9} Pattern 2) West is green,south is red, don’t walk is red. Oncethe output is at this pattern, the valid next patterns are {2,3} Pattern 3) West is yellow,south is red, don’t walk is red. Oncethe output is at this pattern, the valid next patterns are {1,3,4,6} Pattern 4) South is green,west is red, don’t walk is red. Oncethe output is at this pattern, the valid next patterns are {4,5} Pattern 5) South isyellow, west is red, don’t walk is red. Once the output is at this pattern,the valid next patterns are {1,2,5,6} Pattern 6) Walk is green,south is red, west is red. Oncethe output is at this pattern, the valid next patterns are {1,6,7} Pattern 7) Don’t Walk isoff, south is red, west is red. Once the output is at this pattern,the valid next patterns are {1,2,4,6,7,8,9}Pattern 8) Don’t Walk isoff, west is red, south isgreen. Once theoutput is at this pattern, the valid next patterns are {4,5} Pattern 9) Don’t Walk isoff, west is green,south is red. Once theoutput is at this pattern, the valid next patterns are {2,3}There are a couple of consequences of thisgrading algorithm:1) You should output to the road lights first and then to the walk lights,2) You should output to the walk and don't walk lights at the same time3) For simulation, we do not check for timing, so make the delays short duringsimulation testing.Most microcontrollershave a rich set of timer functions. For this lab, you will the PLL and SysTicktimer to wait a prescribed amount of time.The basic approach tothis lab will be to first develop and debug your system using the simulator.After the software is debugged, you will interface actual lights and switchesto the LaunchPad and run your software on the real microcontroller. As you haveexperienced, the simulator requires different amount of actual time as comparedto simulated time. On the other hand, the correct simulation time is maintainedin the SysTick timer, which is decremented every cycle of simulation time. Thesimulator speed depends on the amount of information it needs to update intothe windows.   Because we do not want to wait the minutes required foran actual intersection, the cars in this traffic intersection travel muchfaster than “real” cars.  In other words, you are encouraged to adjust thetime delays so that the operation of your machine is convenient for you todebug and for the grading engine to observe during demonstration.Part a) Decide which port pins you will use for the inputs and outputs.Avoid the pins with hardware already connected. Run the starter code in thesimulator to see which ports are available for the lights and switches; thesechoices are listed in Tables 10.1 and 10.2. The “don’t walk” and “walk” lightsmust be PF1 and PF3 respectively, but where to attach the others have someflexibility. In particular, Table 10.1 shows you three possibilities for howyou can connect the six LEDs that form the traffic lights.Table 10.2 shows youthree possibilities for how you can connect the three positive logic switchesthat constitute the input sensors. Obviously, you will not connect both inputsand outputs to the same pin. Red east/westPA7PB5PE5Yellow east/westPA6PB4PE4Green east/westPA5PB3PE3Red north/southPA4PB2PE2Yellow north/southPA3PB1PE1Green north/southPA2PB0PE0Table 10.1. Possible ports to interface the traffic lights(yellow is suggested or default). Walk sensor          PA4PB2PE2North/south sensorPA3PB1PE1East/west sensorPA2PB0PE0Table 10.2. Possible ports to interface the sensors (yellow issuggested or default). Part b) Design a finite state machine that implements a good trafficlight system. Draw a graphical picture of your finite state machine showing thevarious states, inputs, outputs, wait times and transitions.Part c) Write and debug the C code that implements the traffic lightcontrol system. During the debugging phase with the simulator, use the logicanalyzer to visualize the input/output behavior of your system. Anotherdebugging technique is to dump {the state index, the input, the output} eachtime through the FSM controller to create a log of the operationDuring the simulationgrading I will automatically set the inputs and check your outputs. Hint: I recommend reducing thewait times for all states to be less than a second, so the simulation gradingruns faster.Once you get a 100 in simulation, you can increasethe wait times for the real board to be more reasonable. 实验代码我只想说：高详细注解版你们开不开心！好吧……其实并没有人来看……Code：// ***** 0. Documentation Section *****  // TableTrafficLight.c for Lab 10  // Runs on LM4F120/TM4C123  // Index implementation of a Moore finite state machine to operate a traffic light.    // Daniel Valvano, Jonathan Valvano  // November 7, 2013    // east/west red light connected to PB5  // east/west yellow light connected to PB4  // east/west green light connected to PB3  // north/south facing red light connected to PB2  // north/south facing yellow light connected to PB1  // north/south facing green light connected to PB0    // pedestrian detector connected to PE2 (1=pedestrian present)  // north/south car detector connected to PE1 (1=car present)  // east/west car detector connected to PE0 (1=car present)    // "walk" light connected to PF3 (built-in green LED)  // "don't walk" light connected to PF1 (built-in red LED)    // ***** 1. Pre-processor Directives Section *****  #include "TExaS.h"  #include "tm4c123gh6pm.h"    // ***** 2. Global Declarations Section *****  #define SENSOR  (*((volatile unsigned long *)0x4002400C))  #define LIGHT   (*((volatile unsigned long *)0x400050FC))    // Linked data structure  struct State   {  unsigned long Out;            //Lights_Set  unsigned long OutPF;          //Walk_Set  unsigned long Time;           //Time Duration  unsigned long Next[8];        //Next[X] X means PE2-0 (0x07-0x00)  };    typedef const struct State STyp;    #define goW         0             #define waitW       1                 #define goS         2                 #define waitS       3                 #define walk        4                 #define notWalk     5         #define walkOff     6             #define notWalk2  7           #define walkOff2  8             STyp FSM[9]=  {     //{OUT,OutPF,Time,{    None, PE0,     PE1,   PE1&0,     PE2,   PE2&0,   PE2&1, PE2&1&0}} {0x0C, 0x02, 100,{     goW,     goW,   waitW,   waitW,   waitW,   waitW,   waitW,   waitW}},   //goW   {0x14, 0x02, 60, {   waitW,     goW,     goS,     goS,    walk,    walk,     goS,     goS}},   //waitW   {0x21, 0x02, 100,{     goS,   waitS,     goS,   waitS,   waitS,   waitS,   waitS,   waitS}},   //goS   {0x22, 0x02, 60, {   waitS,     goW,     goS,     goW,    walk,    walk,    walk,    walk}},   //waitS   {0x24, 0x08, 100,{    walk, notWalk, notWalk, notWalk,    walk, notWalk, notWalk, notWalk}},   //walk   {0x24, 0x02, 60, { notWalk, walkOff, walkOff, walkOff, walkOff, walkOff, walkOff, walkOff}},   //notWalk   {0x24, 0x00, 60, { walkOff,notWalk2,notWalk2,notWalk2,notWalk2,notWalk2,notWalk2,notWalk2}},   //walkOff   {0x24, 0x02, 60, {notWalk2,walkOff2,walkOff2,walkOff2,walkOff2,walkOff2,walkOff2,walkOff2}},   //notWalk2   {0x24, 0x00, 60, {walkOff2,     goW,     goS,     goW,    walk,     goW,     goS,     goW}}    //walkOff2  };    unsigned long S;  // index to the current state  unsigned long Input;    // FUNCTION PROTOTYPES: Each subroutine defined  void DisableInterrupts(void); // Disable interrupts  void EnableInterrupts(void);  // Enable interrupts    // ***** 3. Subroutines Section *****    void SysTick_Init(void){  NVIC_ST_CTRL_R = 0;               // disable SysTick during setup  NVIC_ST_CTRL_R = 0x00000005;      // enable SysTick with core clock  }    // The delay parameter is in units of the 80 MHz core clock. (12.5 ns)  void SysTick_Wait(unsigned long delay)  {  NVIC_ST_RELOAD_R = delay-1; // number of counts to wait  NVIC_ST_CURRENT_R = 0;       // any value written to CURRENT clears  while((NVIC_ST_CTRL_R&0x00010000)==0){} // wait for count flag  }    // 800000*12.5ns equals 10ms  void SysTick_Wait10ms(unsigned long delay){  unsigned long i;  for(i=0; i<delay; i++)SysTick_Wait(800000);  // wait 10ms  }    void PortBEF_Init(void){ volatile unsigned long delay;  SYSCTL_RCGC2_R |= 0x32;                   // 1) B E F  delay = SYSCTL_RCGC2_R;                   // 2) no need to unlock        GPIO_PORTE_AMSEL_R    &= ~0x07;           // 3) disable analog function on PE2-0  GPIO_PORTE_PCTL_R     &= ~0x00000FFF; // 4) enable regular GPIO  GPIO_PORTE_DIR_R      &= ~0x07;       // 5) inputs on PE2-0  GPIO_PORTE_AFSEL_R    &= ~0x07;         // 6) regular function on PE2-0  GPIO_PORTE_DEN_R      |=  0x07;         // 7) enable digital on PE2-0    GPIO_PORTB_AMSEL_R    &= ~0x3F;           // 3) disable analog function on PB5-0  GPIO_PORTB_PCTL_R     &= ~0x00FFFFFF; // 4) enable regular GPIO  GPIO_PORTB_DIR_R      |=  0x3F;           // 5) outputs on PB5-0  GPIO_PORTB_AFSEL_R    &= ~0x3F;           // 6) regular function on PB5-0  GPIO_PORTB_DEN_R      |=  0x3F;           // 7) enable digital on PB5-0    GPIO_PORTF_AMSEL_R    &= ~0x0A;       // 3) disable analog on PF1, PF3  GPIO_PORTF_PCTL_R     &= ~0x0000F0F0; // 4) PCTL GPIO on PF1, PF3  GPIO_PORTF_DIR_R      |=  0x0A;       // 5) PF3, PF1 out  GPIO_PORTF_AFSEL_R    &= ~0x0A;       // 6) disable alt funct on PF1, PF3  GPIO_PORTF_DEN_R      |=  0x0A;       // 7) enable digital I/O on PF1, PF3  }    int main(void){   TExaS_Init(SW_PIN_PE210, LED_PIN_PB543210); // activate grader and set system clock to 80 MHz  SysTick_Init();     PortBEF_Init();   // initialize PB,PE,PF  S = goW;                // let goW be First State  EnableInterrupts();  while(1)  {  LIGHT = FSM[S].Out;                               // set lights  GPIO_PORTF_DATA_R =                                // set PFs into PortF's Data  (GPIO_PORTF_DATA_R & (~0x0A)) | FSM[S].OutPF;             SysTick_Wait10ms(FSM[S].Time);          // Wait a Duration to show this state            Input = GPIO_PORTE_DATA_R;                  // Get Sensor Info  S = FSM[S].Next[Input];                         // Change the FSM  }return 0;}  调试及机器检验过程Running with Code Size Limit: 32KLoad "F:\\【资料】重大教学资料\\嵌入式系统及应用\\Labware\\Lab10_TrafficLight\\Lab10.axf" *** Restricted Version with 32768 Byte Code Size Limit*** Currently used: 18876 Bytes (57%)Start gradingClock rate appears to be : 80 MHzRunning 5 tests0) Initialization tests : - (PE2-0) have been selected as the input pins - Verifying input configuration...   Pass: PORTE DEN bits (2-0) are high   Pass: PORTE DIR bits (2-0) are low   Pass: PORTE AFSEL bits (2-0) are low   Pass: PORTE AMSEL bits (2-0) are low   Pass: PORTE PCTL bits (11-0) are low - (PB5-0) have been selected as the output pins - Verifying output configuration...   Pass: PORTB DEN bits (5-0) are high   Pass: PORTB DIR bits (5-0) are high   Pass: PORTB AFSEL bits (5-0) are low   Pass: PORTB AMSEL bits (5-0) are low   Pass: PORTB PCTL bits (23-0) are low1) Servicing all 3 requests, lights should make a complete cycle   FSM: Transition: 2 to 3   FSM: Transition: 3 to 4   FSM: Transition: 4 to 5   FSM: Transition: 5 to 1   FSM: Transition: 1 to 6   FSM: Transition: 6 to 1   FSM: Transition: 1 to 7   FSM: Transition: 7 to 1   FSM: Transition: 1 to 7   FSM: Transition: 7 to 9   FSM: Transition: 9 to 2   Pass: All requests were serviced   Pass: South request was serviced   Pass: West request was serviced   Pass: Walk request was serviced - Test PASSED2) Servicing walk button, walk light should come on   FSM: Transition: 2 to 3   FSM: Transition: 3 to 1   FSM: Transition: 1 to 6   Pass: All requests were serviced   Pass: Walk request was serviced - Test PASSED3) Servicing west button, west green light should come on   FSM: Transition: 6 to 1   FSM: Transition: 1 to 7   FSM: Transition: 7 to 1   FSM: Transition: 1 to 7   FSM: Transition: 7 to 9   FSM: Transition: 9 to 2   Pass: All requests were serviced   Pass: West request was serviced - Test PASSED4) Servicing south button, south green light should come on   FSM: Transition: 2 to 3   FSM: Transition: 3 to 4   Pass: All requests were serviced   Pass: South request was serviced - Test PASSEDDone grading. Score is 100版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/45452373	Round 1B 2015 - The top-scoring 1000 contestants will advance to Round 2  All Scores Friends Closest Competitors    Time Submitted  Solution DownloadContest finished A. Counter CultureB. Noisy NeighborsC. Hiking DeerRank ContestantScorePenalty11pt14pt12pt15pt13pt16pt19ptProblem statistics4:383105/5308 correct15:25962/1400 correct12:242329/3171 correct13:22562/772 correct24:53651/1158 correct25:16132/237 correct47:3352/88 correct706 jki14371:27:2723:20  1:27:27  50:03  --------1008 okcd00Me372:41:501:14:03 2 wrong tries 1:14:49  2:25:50 2 wrong tries Time expired------今天是GoogleCodeJam初赛的1B场次，前1000名可以进入Round2凌晨打这场比赛，困得有点厉害，不过还是坚持着打下来…… 中途在B题上老是找不到错误来，很伤心很难过，然后就放弃了，结果后来突然又想到了问题所在，比赛的最后五分钟提交，过了……大数据抓紧修改，但是已经无济于事、于事无补了…… 永远不要放弃的太早…… 就算少错那么1次，就算早交那么一分钟……就差8名就能过的痛楚有谁能懂……<Update on 2015 7th May>然而一切都那么突然…… 突然被告知……我以九百多名的成绩进了Round2……Problem A. Counter CultureThis contest is open for practice. You can try every problem as many times as you like, though we won't keep track of which problems you solve. Read the Quick-Start Guide to get started.Small input11 pointsSolve A-smallLarge input14 pointsSolve A-largeProblemIn the Counting Poetry Slam, a performer takes the microphone, chooses a number N, and counts aloud from 1 to N. That is, she starts by saying 1, and then repeatedly says the number that is 1 greater than the previous number she said, stopping after she has said N.It's your turn to perform, but you find this process tedious, and you want to add a twist to speed it up: sometimes, instead of adding 1 to the previous number, you might reverse the digits of the number (removing any leading zeroes that this creates). For example, after saying "16", you could next say either "17" or "61"; after saying "2300", you could next say either "2301" or "32". You may reverse as many times as you want (or not at all) within a performance.The first number you say must be 1; what is the fewest number of numbers you will need to say in order to reach the number N? 1 and N count toward this total. If you say the same number multiple times, each of those times counts separately.InputThe first line of the input gives the number of test cases, T. T lines follow. Each has one integer N, the number you must reach.OutputFor each test case, output one line containing "Case #x: y", where x is the test case number (starting from 1) and y is the minimum number of numbers you need to say.Limits1 ≤ T ≤ 100.Small dataset1 ≤ N ≤ 106.Large dataset1 ≤ N ≤ 1014.SampleInput  Output  311923Case #1: 1Case #2: 19Case #3: 15In Case #2, flipping does not help and the optimal strategy is to just count up to 19.In Case #3, the optimal strategy is to count up to 12, flip to 21, and then continue counting up to 23. That is, the numbers you will say are 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 21, 22, 23.从1开始报数，每次可以选择比上次的数大1个，或者把上次的数反转过来，问报到N这个数字的时候最少需要报数多少次。由于可以反转，我们要最大化利用的话自然是要把左边一半的数字在右边出现其反序时进行反转（别忘了反转也是一次报数要加一），然后再从"...001"开始把后面的数补齐。1》反转并不能改变数字的位数，所以我们要考虑到每一次的升位都是9999+1得到的2》升位时为了最大化效率，我们往往将后一半全变为9，反转再次全变为9的方法来由1..00获得9...993》到达目标相同位数时，先获得左一半的数的反序，然后通过一次报数反转，再获得右一半的数，获得的和即为所求。看起来并不困难，但是为什么并不能那么轻易的AC呢，其实有这么两种情况需要注意：1） 当数字为10023这样的前一半的反序为00..1(全零末位1)的时候，由于不需要反转所以反转的1不要加上；2） 当数字为12000这样的后一半的正序为00..0(各位全为0)的时候，由于达到这个位数的时候一定是10000，所以反过来就一定从1开始，末尾为全0的时候要考虑为减1的数字加1来得到（比如12000考虑为11999+1）；代码如下Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}ll getNum(string s, int l, int r){ll ret=0;while(l<=r){ret=ret*10LL;ret=ret+(s[l]-'0');l++;}return ret;}ll getReverseNum(string s, int l, int r){ll ret=0;while(r>=l){ret=ret*10LL;ret=ret+(s[r]-'0');r--;}return ret;}ll change(string dist){ll ret=0;int len=dist.length();int mid=dist.length()/2;ll a=0,b=0;if(mid<=len-1){b=getNum(dist,mid,len-1);}if(0<=mid-1){a=getReverseNum(dist,0,mid-1);//start from 1} if(a==1) a--;else if(b==0){int pos=0;for(pos=len-1;pos>=0 &&  dist[pos]=='0';pos--){dist[pos]='9';}dist[pos]=dist[pos]-1;return (change(dist)+1);} //cout<<dist<<":"<<a<<":"<<b<<endl;return ret+a+b;}ll pls(int n){ll ret=0;string t="";for(int i=1;i<n;i++){t=t+"9";ret+=change(t)+1;}return ret;}ll solve(string n){ll ret=0;ret+=pls(n.length());ret+=change(n);return ret; } int main(){freopen("A-large.in","r",stdin);freopen("A-large.out","w",stdout);int cases=0;scanf("%d",&cases);for(int _case=1;_case<=cases;_case++){ll ans=0;string n;cin>>n; ans=solve(n);printf("Case #%d: %I64d\n",_case,ans);}return 0;}Problem B. Noisy NeighborsThis contest is open for practice. You can try every problem as many times as you like, though we won't keep track of which problems you solve. Read the Quick-Start Guide to get started.Small input12 pointsSolve B-smallLarge input15 pointsSolve B-largeProblemYou are a landlord who owns a building that is an R x C grid of apartments; each apartment is a unit square cell with four walls. You want to rent out N of these apartments to tenants, with exactly one tenant per apartment, and leave the others empty. Unfortunately, all of your potential tenants are noisy, so whenever any two occupied apartments share a wall (and not just a corner), this will add one point of unhappiness to the building. For example, a 2x2 building in which every apartment is occupied has four walls that are shared by neighboring tenants, and so the building's unhappiness score is 4.If you place your N tenants optimally, what is the minimum unhappiness value for your building?InputThe first line of the input gives the number of test cases, T. T lines follow; each contains three space-separated integers: R, C, and N.OutputFor each test case, output one line containing "Case #x: y", where x is the test case number (starting from 1) and y is the minimum possible unhappiness for the building.Limits1 ≤ T ≤ 1000.0 ≤ N ≤ R*C.Small dataset1 ≤ R*C ≤ 16.Large dataset1 ≤ R*C ≤ 10000.SampleInput  Output  42 3 64 1 23 3 85 2 0Case #1: 7Case #2: 0Case #3: 8Case #4: 0In Case #1, every room is occupied by a tenant and all seven internal walls have tenants on either side.In Case #2, there are various ways to place the two tenants so that they do not share a wall. One is illustrated below.In Case #3, the optimal strategy is to place the eight tenants in a ring, leaving the middle apartment unoccupied.Here are illustrations of sample cases 1-3. Each red wall adds a point of unhappiness.有一个R行C列的方格图，要向里面放N个点（每个格子最多只能放一个点），如果某面墙的两侧均有点，则这面墙会增加1点的”不开心值“，如果通过最优的放置，可以获得的最小的”不开心值“为多少。易得，当点数N不大于格子数R*C的一半时，不开心值最小必然为0（黑白相间染色可证）P.S.此处黑白染色记最左上点为黑首先我们看到小数据时总格子数目不会超过16，小数据时我们自然想到希望通过贪心，先把所有格子放上点，然后拿走直到点数为N，每次拿走的都是减少最多不开心值的格子，此处为了判别某个格子当前剩余共有墙方向，使用了状态压缩，不过看来是想得复杂了些。这种思路即便是小数据也是无法AC，因为有这样一组数据：【3X5的格子，放9个】没错，在这种情况下，满放撤回贪心，反而不如白全放剩余点数贪心的算法，白全放+2个角放点，结果为4，比起满放撤回贪心的6自然是要更优，结果也如所料，将这一条特判之后拿到了AC……紧接着，比赛的最后2分钟我所想出的大数据的算法是：黑白染色后，1）黑全放，剩余点数贪心，2）白全放，剩余点数贪心，3）所有格子全放，撤回棋子贪心，三者取最值……姑且先不论对错（当然如果读我的文章的您有这道题的正确解法，希望可以告诉我，非常感谢！），我连写完都没有做到……永远，不要放弃的太早……血泪的教训……小数据骗分代码如下Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))const int up=1<<3, lef=1<<2, rig=1<<1, dwn=1<<0;bool cmp(const int a, const int b){return a > b;}int getp(int x){return (x&up?1:0)+(x&lef?1:0)+(x&rig?1:0)+(x&dwn?1:0); }int solve(int r, int c, int n){int ret=r*(c-1)+c*(r-1);int rest=r*c-n;int ns[16][16]={0}; // 0x1111 means Up Left Right Downfor(int i=0;i<r;i++)//Init{for(int j=0;j<c;j++){if(i>0) ns[i][j]+=up;if(i<r-1) ns[i][j]+=dwn;if(j>0) ns[i][j]+=lef;if(j<c-1)  ns[i][j]+=rig;}}while(rest--){int x=0,y=0,maxp=0;for(int i=0;i<r;i++){for(int j=0;j<c;j++){int now=getp(ns[i][j]);if(now>maxp) x=i,y=j,maxp=now;}}//cout<<maxp<<"  "<<x<<":"<<y<<endl;ret-=maxp;ns[x][y]=0;if(x>0) ns[x-1][y]&=~dwn;if(x<r-1)ns[x+1][y]&=~up;if(y>0) ns[x][y-1]&=~rig;if(y<c-1) ns[x][y+1]&=~lef;}return ret;}int main(){freopen("B-large.in","r",stdin);freopen("B-large.out","w",stdout);int cases=0;scanf("%d",&cases);for(int _case=1;_case<=cases;_case++){int ans=0;int r,c,n;scanf("%d%d%d",&r,&c,&n);//cout<<r<<":"<<c<<":"<<n<<endl;if (max(r,c)==5 && min(r,c)==3 && n==9) ans=3;else if(n<=(r*c+1)/2) ans=0;else ans=solve(r,c,n);printf("Case #%d: %d\n",_case,ans);}return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/45369169	前言近些日子猛然发现自己新技能Get的太少了……随着这个念头的出现，便开始了又一次的技能发掘。这次给自己的任务是：使用安卓虚拟机，完成翻墙，搭建谷歌框架，实现虚拟机下的谷歌服务的完整实现。P.S. 不要流口水啦，Ingress无法在VM下跑起的哟，在很早的更新中Google的猩猩大大们早就把这个解决掉啦~（在我进入这个游戏之前这个漏洞就被修复了到底算是好事还是不好呢……）从头到尾都是自己一个人倒腾出来的，没有依赖询问任何人哦~~ 得瑟得瑟~~o(^▽^)o嘛不管啦，毕竟花了我10个小时左右，做个成果汇总，流程处理记录一下也作为今后备忘吧——结果展示：本次流程中所使用的物品清单：重要物品：》梯子 此处使用的是SS-Shadowsocks 》Wiki 类情报搜集能力所需程序：》Genymotion  //速度极快的PC端安卓模拟器》Oracle VM VirtualBox //》Fiddler Web Debugger //》Genymotion-ARM-Translation.zip //》com.muzhiwan.gsfinstaller.apk //不同的环境下可能会用到的程序：》NetworkLocation.apk》Genymotion-Uninstall》Gapp本次试验所使用环境：》Win8.1 Professional x64》Google Galaxy Nexus - 4.1.1 - API16 - 720x1280 （VM配置）图文流程及坑点解说最初就是这仨兄弟了，他们是可以一起获得的，在Genymotion官网上注册一个账号，然后在下载页面下载，选择自己的操作系统环境，以及为了获得VM的VirtualBox，我们选择稍微大一点的那个 Get Genymotion (117.47MB)下载安装完成之后打开Genymotion，在Add里可以选择你想要的模拟的安卓机类型，这里就需要刚刚我们用到的那个账户，登录之后，这里就有好多机型供你选择啦，我随手选了个GoogleGalaxy，大家按理说可以随意选择的呆胶布~~ 啊对了，要记住你选择的安卓版本哦~安卓机跑起来之后呢，在文件夹里把事先下载好的 Genymotion-ARM-Translation.zip 拖动到窗口中，会出现上述的【正在文件传输】以及【要不要安装】（抱歉我英语不太好），点击ok，如果显示Success，那么关掉虚拟机重启即可，如果出现Failed（这里我Failed了快几万次了……），那么请下载个新的试试，我装国内论坛里给的百度网盘下载出来的就都Failed，然后搬了个梯子在墙外下了个就正常了我也是无奈呀……P.S. 但是无论墙内墙外，“gapps-jb-20121011-signed”和“gapps-jb-20130813-signed”都是万年Failed，所以我才放弃了通过拖动zip的方法来获得谷歌框架，那么我们该怎么弄呢？别着急，看下一步~我们可以通过可以安装的apk来帮助我们进行安装，我的第一反应是使用和我的Note一样用小米的谷歌安装器，就是红色图标的那个，但无奈于总是说apk包有问题不让装，于是这里我用了那个拇指玩的谷歌安装器，在我的环境下，这个是成功可行的，拖动上来之后就扔给他我不管了……这一过程中似乎有需要架梯（fan）子（qiang）的部分，所以在这一步之前，我就先把墙的问题解决了，具体如下这个软件叫做Fiddler，是一个较为常用的代理用软件，与我们日常所见到的不同，这个的好处是可以将自己电脑的网络共享给虚拟机中使用，注意这点:虚拟机同时共享电脑上正在使用的VPN，可以访问墙外。事先将电脑使用Shadowsocks进行架梯，由于现在似乎不让详细说关于架梯子的事情这里就一笔带过，总之就是无论什么方法先让电脑翻过去，然后打开fiddler。PC端这边设置好了，虚拟机那里自然也是要设置的。虚拟机中的网络是通过NAT（网络地址转换）经由ＰＣ的网络进行供给的，所以时刻处于链接在“WiredSSID“下，我们需要做的是长按，修改设置，将代理设置为手动，服务器主机名为10.0.3.2，端口随意，什么你问我为什么？我要模仿我看到这条情报的时候，那个帖子主所说的话来回复你们”这是固定搭配，懂吗？固定搭配！“网络设置好的话，按理说安装器们会尽职尽责的帮你弄好Market的，在所有任务全都完成之后，点击Market，输入你的GoogleID，此处如果使用我刚刚所说的方法架梯出墙，是可以很快获得回应并成功登上的。没有架梯的情况下……我等了一段时间没有回复就没有继续等了，也不知道能不能好……<! --- if you are a ingresser:如果有玩Ingress的孩纸们看到这里我觉得可能会蠢蠢欲动想用这个做点什么，友情告诉你们哟，在VM下，商店中不提供Ingress的下载~ 什么？你说你拆了可用的包强行装进去？哈哈，还是不行哦，VM下根本无法打开呢~ 什么？你还想用VM原生的GPS组件替换掉NetworkLocation，哈哈哈，依然不行哦，这里并不是谷歌服务的问题，文章开头就给你们展示了可以经由谷歌服务下通过VM更改GPS读入数据，以更改终端当前所在位置GPS，但是，游戏依然是不会让进的哟~ 和Permission无关，所以去改rw-r--r--没有意义，由于和GPS来源无关，所以替换/修改/改名 Location的APK没有意义，是在游戏包内部的代码中有所判断，所以不重写重新打包都是没用的哟~啊对了，重新打包的时候如果你没有NIA的数字签名也是无法游戏的，(●'◡'●)　所以～咱们公平友善地游戏吧~ 别想歪门邪道咯~ 啊对了上面这段如果有哪里不对请评论OR私信我哟~若有判断不对或者语句不对的地方我会仔细倾听详细地理解然后立马更正的~~ 欢迎点评指教~ >版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/45292189	# 25个人, 每5人1个跑道, 最少经过几次赛跑, 得到前3名 #今天突然看到别人的博客中说到这个问题，然后觉得挺有趣的，就仔细想了想，由于身边没有纸笔恼火了5分多钟，最终终于想到了最终的答案，特记录于此，答案为7次。*具体如下：5》 25个人分为五组进行比赛，决出每组的第一名6》 用这五个第一名进行一次比赛，依照顺序称呼为A、B、C、D、E7》 由于需要前三名，所以D、E所在的组已经没有意义了（他们组的人都比他们慢），B、C 与 A所在组的第二名第三名（可能A所在组的前三名就是25人中的前三名），再加上B所在组的第二名（可能为A、B + B组第二），五人进行比赛，决出的前两个即为25人中的第二与第三。答毕，综上所述，共为7次。# 微信用户都是双向的好友，a是b的好友，那么b一定是a的。给定一个用户列表，有些用户是好友，有些不是 ## 请判断，这些用户是否可以划分为两组，每组内的用 户，互相都不是好友。如果能，请给出这个划分 #然而同一篇博文下又看到了这个，顺手也放在这里写下很明显：【二分图】无向图G为二分图的充分必要条件是，G至少有两个顶点，且其所有回路的长度均为偶数。对于这一点，网络上的证明如下：证先证必要性。设G为二分图<X，E，Y>。由于X，Y非空，故G至少有两个顶点。若C为G中任一回路，令C = (v0,v 1,v2，…，v l-1,v l = v0)其中诸vi (i = 0,1，…，l）必定相间出现于X及Y中，不妨设{v0,v2,v4，…，v l = v0} &Iacute; X{v1,v3,v5，…，v l-1} &Iacute; Y因此l必为偶数，从而C中有偶数条边。再证充分性。设G的所有回路具有偶数长度，并设G为连通图（不失一般性，若G不连通，则可对G的各连通分支作下述讨论）。令G的顶点集为V，边集为E，现构作X，Y，使<X，E，Y> = G。取v0&Icirc;V，置X = {v | v= v0或v到v0有偶数长度的通路}Y = V-XX显然非空。现需证Y非空，且没有任何边的两个端点都在X中或都在Y中。由于|V|≥2并且G为一连通图，因此v0必定有相邻顶点，设为v1，那么v1&Icirc;Y；故Y不空。设有边（u,v），使u&Icirc;X，v&Icirc;X。那么，v0到u有偶数长度的通路，或u = v0；v0到v有偶数长度的通路，或v = v0。无论何种情况，均有一条从v0到v0的奇数长度的闭路径，因而有从v0到v0的奇数长度的回路（因从闭路径上可能删去的回路长度总为偶数），与题设矛盾。故不可能有边（u,v）使u,v均在X中。P.S. 对于二分图匹配，有个比较常用且容易理解的算法叫做匈牙利算法。版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/45288993	序言2015 编程之美挑战赛·初赛结束了，小伙伴们似乎都在Hihocoder上愉快的玩耍……只有我一个人默默地打着Code Hunt…… 啊对了，默默的全题3SP的AK了哟……来逐题写下题解和解题源码吧…… （P.S 有什么不好的或者说得不对的地方请告诉我哦，我会立马改正的~(●'◡'●)）《Update Apr.27th Result》完整代码及博文中使用无水印图片可以在这里下载（0积分）：http://download.csdn.net/detail/okcd00/8634751Section 00 BAIYUN00.01 Tutorial 教程点进去会有一个小动画，亲切的告诉你玩法，新手们可以看看这个哦~~00.02 求最值Math里有这样一个函数，返回a与b之间的最值：Math.Max(a,b)//00.02using System;public class Program {  public static int Puzzle(int a, int b) {    return Math.Max(a,b);  }}00.03 找规律给了两个数对，仔细观察得知（好吧其实我做过所以有经验了）答案是<a1b2+a2b1, a2b2>//00.03using System;public class Program {    // Each array contains two elements    public static int[] Puzzle(int[] a, int[] b) {      int[] t=new int[2];      t[0]=a[0]*b[1]+a[1]*b[0];      t[1]=a[1]*b[1];      return t;    }}00.04 进制转换（十进制转二进制）进制转换的话，至少十进制为源数的情况下是很方便的有相应的函数的：以前的文章里也有提到过：Here以及还写过一个C++的模板：Here//00.04using System;public class Program {  public static string Puzzle(int n) {    string j = Convert.ToString(n, 2);    return j;  }}00.05 元素前移这题是把字符串用空格分隔开，每一个部分作为一个元素，循环左移n位（当然等效于n%元素个数 位），得到的新字符串。其中，分隔通过Split函数实现，循环左移可以通过 newArr[i]=oldArr[(i+n)/len]来实现最终把string数组连起来的时候中间还需要加空格，这时需要用到的就是Join(a,b)函数，将数组b中的数连起来，两两之间用a分隔。//00.05using System;public class Program {    public static string Puzzle(string s, int n)     {      string[] sArr=new string[100];      sArr=s.Split(' ');       int len=sArr.Length;      string[] ss=new string[len];      for(int i=0;i<len;i++) ss[i]=sArr[(n+i)%len];      return String.Join(" ",ss);    }}Section 01 BAOBAO01.01 判断元素是否完全相同为了判断元素是否完全一致，我用了Linq里的集合操作，简单的说，找 （a集合的非交集部分）与（b集合的非交集部分）的并集，如果这个集合没有东西，那就是完全相等咯~//01.01using System;using System.Linq;public class Program {  public static bool Puzzle(int[] a, int[] b)   {    int[] result=a.Except(b).Concat(b.Except(a)).ToArray();    return result.Length==0;  }}01.02 ISBN校验没错，看到茫茫多的这东西……我第一反应跟大家一样：这是神马玩意!不过还是非常良心的每个字符串前面都有个”978-“用来提醒大家，也就是说，给的是一个完整的ISBN。我们需要判断的True/False，其实是：这个是不是一个合格的ISBN码，判断标准是，从前向后看，前12位，奇数位乘以1，偶数位乘以3，结果对10取模，如果校验码第13位数和这个模加起来刚好是10或者0，这个ISBN校验就成立。（不太理解的话下面有例子）为了检验题目中给出的是不是这个ISBN，还专门写了个C++程序来做判断：#include <iostream>#include <cstring>#include <string>using namespace std;int n[13]={0};int main(){string s;while(cin>>s && s.length()){int pos=0,ans=0;for(int i=0;i<s.length();i++){if(s[i]!='-')n[pos++]=s[i]-'0'; } for(int i=0;i<12;i++){ans+=n[i]*(i%2?3:1);}ans%=10;ans=10-ans;cout<<ans<<endl;}return 0;}关于ISBN，详情请见维基百科：Here考虑到架梯子困难的同学，还是在这里贴张截图//01.02using System;public class Program {    public static bool Puzzle(string s)     {      int ans=0;      int pl=0;      char a='0';      s=s.Replace("-","");      for(int i=0;i<s.Length-1;i++)      {        if(i%2==0) pl=1;        else pl=3;        ans+=((int)s[i]-(int)a)*pl;      }      ans%=10; if(ans!=0) ans=10-ans;      return ans==(int)s[s.Length-1]-(int)a;    }}01.03 进制转换（十进制转四进制）当发现所有的数字都在0-3之间徘徊的时候大约就能感觉到是四进制数了，进制转换的实现并不困难：//01.03using System;public class Program {    public static string Puzzle(int n)     {      string s="";      while(true)      {        int r=n/4,m=n%4;        s=m.ToString()+s;        n=r;        if(n==0)break;      }      return s;    }}01.04 集合求交集这里也用到了Linq中的函数，求集合交集，这里需要注意的地方在于直接求交集并不能返回int[]类型，我们需要再加上ToArray()//01.04using System;using System.Linq;public class Program {    public static int[] Puzzle(int[] a, int[] b)     {        return a.Intersect(b).ToArray();    }}至此，解题报告及完整代码说明完毕，若有不明白的或者我有哪里说得不对的，亦或是你有什么更好的算法，请务必在下面评论告诉我o(^▽^)o ~~我们大家一起努力，一起进步吧~By okcd00（糖果天王）题目截图大家可能想看看题目的数据或者检查下是不是真的3SP之类的，每道题的3SP截图如下所示：Section 00Section 01可怕的01.02测试数据版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/45271067	CodeHunt里有个进制转换的36进制转换，以前在清澄做过，但是可惜没放在CSDN过，这个着实是暴力的进制转换没有错，但是为了以后的速度，还是在这里存一份好了……顺便提一句，特别地，对十六进制的转换时：http://blog.csdn.net/okcd00/article/details/45196255 对于任何一个数字，及10-36间的进制基数，接口 TBase(n,m)【n】 long long 长度的原十进制整数【m】 进制基数BaseCode：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}string TBase(ll in,int m){string s="";ll n=in;while(n){ll mod=n%m;if(mod) s+= (mod<10)? '0'+mod : 'A'+mod-1 ;n/=m;if(!n) break;}return s;}int main(){ll n;int m;cin>>n>>m;cout<<"Trans "<< n <<" to Base-"<< m <<" ："<<TBase(n,m); return 0;}几年前清澄上吾辈的C语言代码，怀念~ ~ 贴一下：#include<stdio.h>#include<string.h>int str[10000];int main(){    int n,m,len=1;    scanf("%d %d",&n,&m);    if(!n) {    printf("0\n");    return 0;}    while(n)    {        int mod=n%m;        str[len++]=mod;        n=(n-mod)/m;        if(!n) break;    }    while(--len)    {        if(str[len]<10) printf("%d",str[len]);        else printf("%c",str[len]-10+'A');    }}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/45196255	今天在网上GET了一个相当棒的存在，"llx"和"I64x"，是一种可以将一个long long长度的十进制整数直接转化为十六进制存于buffer中的方式，曾经有了解过sscanf和sprintf，但这次这个方式的发现着实非常令人开心，回来再学一次，作为一种技巧好好收着~P.S. 通过更改x的大小写可以决定十六进制的大写/小写表示哦~Code：#include<cmath>#include<cstdio>#include<iostream>#include<algorithm>using namespace std;int main(){char buffer[1024];unsigned long long ull=2222222222222222222;sprintf (buffer, "%llx", ull);//sprintf (buffer, "%I64x", ull);//sprintf (buffer, "%llX", ull);//sprintf (buffer, "%I64X", ull);cout<<buffer<<endl;return 0;}前两种输出为：1ed6eb565788e38e后两种输出为：1ED6EB565788E38E版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/45195879	制作起因：便签纸上一直有这一行【>整理模逆元 exgcd / 大数同余模运算】今天嵌入式专业课一狠心一咬牙，把它完成！给它打上勾！于是—— 还真被我弄出来了……模板来源：依照以前Astar第二场的AC代码敲了半天，捣鼓出来一个大数组合数模运算代码，提供外接接口，可用部分包括：求模逆元，扩展GCD，大数同余模运算，大数组合数计算。（转载请注明okcd00哟~）参数说明：T：数据组数lim:：取模的模值Jval[x]：x的阶乘模lim后的值n：组合数的下标m：组合数的上标_Ni（x，m）：x对于m的模逆元C（n，m）：下标为n，上标为m的组合数Code：#include<cmath>  #include<cstdio>  #include<string>  #include<vector>  #include<cstring>  #include<iostream>  #include<algorithm>  using namespace std;  typedef long long ll;  const ll lim=1000000007;  //lim := vmod  ll Jval[2000001];void Jc_init() //初始化阶乘值的数组  {      Jval[0]=1;      for(int i=1;i<=2000000;i++)      Jval[i]=(i*Jval[i-1])%lim;  }    //三元组gcd(a,b) == ax +by == d;     struct gcdstruct //定义结构体存储(_Ni的计算){             ll d;            ll x;            ll y;    };    gcdstruct EXTENDED_EUCLID(ll a,ll b)  //EUCLID算法  {        gcdstruct aa,bb;        if(b==0){    aa.d = a;        aa.x = 1;        aa.y = 0;            return aa;        }        else{        bb = EXTENDED_EUCLID(b,a%b);             aa.d = bb.d;            aa.x = bb.y;            aa.y = bb.x - bb.y * (a/b);        }        return aa;    }           ll _Ni(ll a,ll m)  //获得a对m的模逆元   {          ll x;          gcdstruct aa;          aa = EXTENDED_EUCLID(a,m);          return aa.x;    }           ll C(ll n,ll m) //获得C(n,m) 的组合数结果 := n!/((n-m)!*m!){       llCans=(Jval[n]*_Ni(Jval[m],lim) +lim) %lim;  // Get n!/m!     Cans=(Cans*_Ni(Jval[n-m],lim) +lim   ) %lim;  // Get Cans/(n-m)!     return (Cans+lim)%lim ;   }  int main()  {      int T=0;scanf("%d",&T);     ll n=0,m=0;Jc_init();       for(int cnt=1;cnt<=T;cnt++)       {          scanf("%I64d%I64d",&n,&m);          printf("Case #%d: \n",cnt);        cout<<"===<Jval>===\n n!="<<Jval[n]<<"; m!="<<Jval[m]<<endl;        cout<<"===<_Ni>===\n m!^-1="<<_Ni(Jval[m],lim)        <<"; (n-m)!^-1="<<_Ni(Jval[n-m],lim)<<endl;        printf("C(%d,%d) = %I64d (Mod lim)\n",n,m,C(n,m));      }            return 0;  }   版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/45182819	还是不自己写一写自己心里不踏实呀……首先是理论: (此处引用 DM张鹏飞 @cnBlog 的总结)SPFA算法是1994年西南交通大学段凡丁提出，只要最短路径存在，SPFA算法必定能求出最小值，SPFA对Bellman-Ford算法优化的关键之处在于意识到：只有那些在前一遍松弛中改变了距离估计值的点，才可能引起他们的邻接点的距离估计值的改变。为什么队列为空就不改变了呢？就是因为要到下一点必须经过它的前一个邻接点。。SPFA可以处理负权边。很多时候，给定的图存在负权边，这时类似Dijkstra等算法便没有了用武之地，而Bellman-Ford算法的复杂度又过高，SPFA算法便派上用场了。简洁起见，我们约定有向加权图G不存在负权回路，即最短路径一定存在。当然，我们可以在执行该算法前做一次拓扑排序，以判断是否存在负权回路。        初始化： dis数组全部赋值为Inf(无穷大，不能是map[s][i]),path数组全部赋值为s（即源点），或者赋值为-1，表示还没有知道前驱,然后dis[s]=0;  表示源点不用求最短路径，或者说最短路就是0。将源点入队；另外记住在整个算法中有顶点入队了要记得标记vis数组，有顶点出队了记得消除那个标记(可能多次入队)。        核心：读取队头顶点u，并将队头顶点u出队（记得消除标记）；将与点u相连的所有点v进行松弛操作，如果能更新估计值（即令d[v]变小），那么就更新，另外，如果点v没有在队列中，那么要将点v入队（记得标记），如果已经在队列中了，那么就不用入队以此循环，直到队空为止就完成了单源最短路的求解。        判断有无负环：如果某个点进入队列的次数超过N次则存在负环(SPFA无法处理带负环的图)，假设这个节点的入度是k(无向权则就是这个节点的连接的边)如果进入这个队列超过k,说明必然有某个边重复了，即成环；换一种思路：用DFS，假设存在负环a1->a2->…->an->a1。那么当从a1深搜下去时又遇到了a1，那么直接可以判断负环了所有用。当某个节点n次进入队列，则存在负环，此时时间复杂度为O(n*m),n为节点，m为边。        SPFA算法有两个优化算法 SLF 和 LLL： SLF：Small Label First 策略，设要加入的节点是j，队首元素为i，若dist(j)<dist(i)，则将j插入队首，否则插入队尾。 LLL：Large Label Last 策略，设队首元素为i，队列中所有dist值的平均值为x，若dist(i)>x则将i插入到队尾，查找下一元素，直到找到某一i使得dist(i)<=x，则将i出对进行松弛操作。 SLF 可使速度提高 15 ~ 20%；SLF + LLL 可提高约 50%。 在实际的应用中SPFA的算法时间效率不是很稳定，为了避免最坏情况的出现，通常使用效率更加稳定的Dijkstra算法。个人觉得LLL优化每次要求平均值，不太好，为了简单，我们可以之间用c++STL里面的优先队列来进行SLF优化。然后还是看看代码的好：首先是SPFA的无附加空白模板：应用于，Ｎ点Ｍ边，依次输入从ａ到ｂ的权值为ｗ的有向边，最终输出从１到Ｎ点的最短路权值。Code：#include <cmath> #include <queue> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Maxn 100#define Maxm 10000#define Max 10000int used[Maxn],outqueue[Maxn],head[Maxn],low[Maxn],n,m;struct Edge{int to,w,next;}edge[Maxm];bool SPFA (int start){     queue<int> a;     used[start] = 1;     low[start] = 0;     a.push(start);     while (!a.empty())     {           int top = a.front();           a.pop();           outqueue[top]++;           if (outqueue[top] > n) return false;           for (int k = head[top]; k!= -1; k = edge[k].next)           {               if (low[edge[k].to] > low[top] + edge[k].w)                  low[edge[k].to] = low[top] + edge[k].w;               if (!used[edge[k].to])               {                   used[edge[k].to] = 1;                   a.push(edge[k].to);               }           }     }     return true;}    int main(){    while (scanf ("%d%d", &n ,&m) != EOF)    {          memset (used, 0 ,sizeof(used));          memset (head, -1 ,sizeof(head));          memset (outqueue, 0 ,sizeof(outqueue));          memset (low, Max, sizeof(low));          int k = 0;          while (m--)          {                int a,b,w;                scanf ("%d%d%d", &a, &b, &w);                edge[k].to = b;                edge[k].w = w;                edge[k].next = head[a];                head[a] = k++;          }          if (SPFA(1))             printf ("%d\n", low[n]);          else             printf ("不存在最短\n");    }}当然，白板肯定是不行的，至少有了有向边，也得考虑考虑无向边的想法嘛：要不然试着来道题？（HDU2544 最短路） 题目就赤裸裸的告诉你是最短路，而且还真的是个裸的最短路问题。最短路Time Limit: 5000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 37907    Accepted Submission(s): 16533Problem Description在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？ Input输入包括多组数据。每组数据第一行是两个整数N、M（N<=100，M<=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1<=A,B<=N,1<=C<=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。输入保证至少存在1条商店到赛场的路线。 Output对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间 Sample Input2 11 2 33 31 2 52 3 53 1 20 0 Sample Output32 SourceUESTC 6th Programming Contest Online Recommendlcy #include <cmath> #include <queue>#include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <memory.h>#include <iostream>#include <algorithm>using namespace std;const int N = 105;const int INF = 99999999;int map[N][N], dist[N];bool visit[N];int n, m;void init()     //初始化{    int i, j;    for(i = 1; i < N; i++)    {        for(j = 1; j < N; j++)        {            if(i == j) map[i][j] = 0;            else map[i][j] = map[j][i] = INF;        }    }}void input()    //输入函数{    int vi, vj, cost;    while(m--)    {        scanf("%d %d %d", &vi, &vj, &cost);        if(cost < map[vi][vj])            map[vi][vj] = map[vj][vi] = cost;    }}void floyd()    //Floyd算法{    int i, j, k;    for(k = 1; k <= n; k++)     //k为中间点        for(i = 1; i <= n; i++)            for(j = 1; j <= n; j++)                if(map[i][k] + map[k][j] <  map[i][j])                     map[i][j] = map[i][k] + map[k][j];}void dijk()     //Dijkstra算法{    int i, j, next, MIN;    memset(visit, false, sizeof(visit));    for(i = 1; i <= n; i++) dist[i] = INF;    dist[1] = 0;    for(i = 1; i <= n; i++)    {        MIN = INF;        for(j = 1; j <= n; j++)            if(!visit[j] && dist[j] <= MIN)                MIN = dist[next=j];        if(MIN == INF) break;        visit[next] = true;        for(j = 1; j <= n; j++)            if(!visit[j] && dist[j] > dist[next] + map[next][j])                dist[j] = dist[next] + map[next][j];    }}void spfa()     //SPFA算法{    int i, now;    memset(visit, false, sizeof(visit));    for(i = 1; i <= n; i++) dist[i] = INF;    dist[1] = 0;    queue<int> Q;    Q.push(1);    visit[1] = true;    while(!Q.empty())    {        now = Q.front();        Q.pop();        visit[now] = false;        for(i = 1; i <= n; i++)        {            if(dist[i] > dist[now] + map[now][i])            {                dist[i] = dist[now] + map[now][i];                if(visit[i] == 0)                {                    Q.push(i);                    visit[i] = true;                }            }        }    }}int main(){    while(scanf("%d %d", &n, &m) && n && m)    {        init();input();        //floyd();        //dijk();        spfa();//printf("%d\n", map[1][n]);        printf("%d\n", dist[n]);    }    return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/45169735	老说这个算法懂了，那个算法理解了，什么什么的总感觉底气不足，以后一点点要把自己懂了的算法找个几题写一些，不仅是算法，代码的构造也要了解透彻才能算作会了。今天就并查集好了，写个裸并查集，HDOJ1232 畅通工程畅通工程Time Limit: 4000/2000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 34734    Accepted Submission(s): 18365Problem Description某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？  Input测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( < 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。 注意:两个城市之间可以有多条道路相通,也就是说3 31 21 22 1这种输入也是合法的当N为0时，输入结束，该用例不被处理。  Output对每个测试用例，在1行里输出最少还需要建设的道路数目。  Sample Input4 21 34 33 31 21 32 35 21 23 5999 00 Sample Output102998HintHint Huge input, scanf is recommended. Source浙大计算机研究生复试上机考试-2005年 RecommendJGShining   |   We have carefully selected several similar problems for you:  1233 1272 1875 1879 1213  所谓并查集，就是要判断他们在不在同一个集合里（这里用STL的<set>会舒服些，但是为了熟手，还是敲一次的好），pre[i]是指当前节点的上级。这题主要是看经过link之后有多少棵树（集合），集合与集合间的一条线就能让他俩合并为一个集合，所以要求输出的其实是（集合数-1），这道题的话我们只要遍历一遍，找头头有多少个（即自己没有上级），即总共有多少个集合。#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}#define MAXN 1024int pre[MAXN]={0};//pre[i] : No.father of Node[i]void pre_init(int n){for(int i=0;i<=n;i++){pre[i]=i;}}void join(int a, int b){int tmpa=a,tmpb=b;while(pre[tmpa]!=tmpa) tmpa=pre[tmpa];while(pre[tmpb]!=tmpb) tmpb=pre[tmpb];if(tmpa!=tmpb)pre[tmpb]=tmpa;}int main(){int n=0,m=0;while(scanf("%d",&n) && n){int a,b;pre_init(n);scanf("%d",&m);for(int i=0;i<m;i++){scanf("%d%d",&a,&b);join(a,b);}int ans=0;for(int i=1;i<=n;i++){if(pre[i]==i)ans++;}printf("%d\n",ans-1);}return 0;}// <备忘> 并查集有路径压缩算法，意为上级即头头。暂存，日后更新。<Done on Apr.21th 2015>在Find的过程中，把路上捡起来的所有中间节点都前指到root即可。#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;int  pre[1050];//pre 上司节点 bool t[1050];//t 用于标记独立块的根结点int Find(int x)//获得x所在树的根节点 {int r=x, i=x, tmp;while(r!=pre[r]) r=pre[r];while(pre[i]!=r)//一路向上，把路上的所有上司直接前指向root {tmp=pre[i];pre[i]=r;i=tmp;}return r;}void mix(int x,int y){int fx=Find(x), fy=Find(y);if(fx!=fy)pre[fy]=fx;} int main(){int n,m,a,b,i,j,ans;while(scanf("%d",&n) && n){scanf("%d",&m); for(i=1;i<=n;i++) pre[i]=i;for(i=1;i<=m;i++)          //吸收并整理数据 {scanf("%d%d",&a,&b);mix(a,b);}memset(t,0,sizeof(t));for(i=1;i<=n;i++)          //标记根结点{int tf=Find(i);//cout<<i<<":"<<tf<<endl;t[tf]=1;}for(ans=0,i=1;i<=n;i++)if(t[i]) ans++;printf("%d\n",ans-1);}return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/45148179	啊啦，初赛也比完了，好厉害的样子我想说……JAVA真的有太多太多需要学的，以前我一直觉得，啊C#和C++差不多，JAVA和C#差不多，所以JAVA不难……事实证明我错了……各种好难好难因为基础不足都不知道，但也硬着头皮一点点做着题。初赛虽然事故频出，但至少还是完整的结束了战斗，做个小小的总结吧。由于比赛过程中网络问题颇于严重，截图将每道题发给同组的同学让其不用和时刻502的服务器作斗争，才有了如下回顾所用的素材。就算单单因为为了给大家看看而敲了这么多字，也得给个好评不是嘛【声明: 本人依照比赛中查阅资料获得的浅显理解进行说明，若有不对的地方，请在评论中指出指教，我将非常感谢并立马纠正错误】为了防止本人的理解失误导致误人子弟的现象，较多地放出直接运行看结果可以确定答案的题目（运行环境：Eclipse Standard/SDK Version: Luna Release (4.4.0)）P.S. 编程题的两道（29 & 31）赛中评测获得【完全正确】，品质有保障。02. 追踪程序流程package Test02;public class WanWanMeiXiangDao {    public static void main(String[] args) {        try (DaChuiCareer daChui = new DaChuiCareer()) {            daChui.happyLife();            return;        } catch (Exception e) {            System.out.println(e.getClass().getSimpleName());            return;        } finally {            System.out.println("story end");            return;        }    }    public static class DaChuiCareer implements AutoCloseable {        public DaChuiCareer() {            System.out.println("born");        }        public void happyLife() throws JoyfulException {            System.out.println("happy living");            throw new JoyfulException();        }        @Override        public void close() throws UnexpectedException {            System.out.println("unexpected");            throw new UnexpectedException();        }    }}class JoyfulException extends Exception { }class UnexpectedException extends Exception { }输出为：bornhappy livingunexpectedJoyfulExceptionstory end03. 静态与非静态package Test03;public class Test {void method() {    Object o = null;    try {        methodA();        methodB(o.toString());    } catch (InterruptedException | IOException e) {        System.out.println(e.getClass().getSimpleName());    }}void methodA() throws IOException {    throw new FileNotFoundException();}void methodB(String s) throws InterruptedException {    throw new IllegalArgumentException();}public static void main(String[] args) {method();}}结果：编译不通过Exception in thread "main" java.lang.Error: Unresolved compilation problem: Cannot make a static reference to the non-static method method() from the type Testat Test03.Test.main(Test.java:24)05. 时刻注意数据范围package Test05;class FruitNinjia {  public static void main(String [] args) {    System.out.println(new Ninjia().cut(300));  }}package Test05;class Ninjia {  String cut(short fruit) { return "piece of cake!"; }  String cut(short... fruits) { return "it is hard..."; }}这里的 cut(short... fruits) ，传参的数据类型为short，要知道short只能最多到128，必然出错。结果：编译出错Exception in thread "main" java.lang.Error: Unresolved compilation problem: The method cut(short) in the type Ninjia is not applicable for the arguments (int)at Test05.FruitNinjia.main(FruitNinjia.java:5)07. 子函数不会更改传参值package Test07;public class Test {public static void main(String[] args) {  int[] da1 = new int[]{1, 3, 5};  int[] da2 = new int[]{2, 4, 6};  System.out.print(da2[da1[0]]);  interchange(da1, da2);  System.out.print(da1[da2[0]]);}static void interchange(int[] da1, int[] da2) {  int[] dat = (int[]) da1.clone();  da1 = (int[]) da2.clone();  da2 = (int[]) dat.clone();}}虽然看起来interchange函数确实干了点什么事情，好像交换了da1和da2，但问题是，和C++中一样，在这个函数里改了并不会影响外部定义的这两个变量。输出：4508. INT型除法不要余数package Test08;public class Test {public static void main(String[] args) {int i = (2 ^ 4 | 1 >> 5 + 3 << 3 % 2) / 2;if (2.5 == i) {  System.out.println("ok");} else {  System.out.println("fail");}}}这个，玩C++的大家应该很懂吧，int型如果有个除以2的话，是不会出现2.5这样的小数的，除以2等效于右移一位，余数是被扔掉的。输出:fail10. 同名函数调用package Test10;public class MiniPad extends Pad {  public final void pad() {    System.out.println("Mini pad");  }  public static void main(String [] args) {    new MiniPad().pad();  }}package Test10;class Pad {  private final void pad() {    System.out.println("Big pad");  }}当一个类的继承类中有着和自身同名的类的时候，调用哪个，这往往是常常被问到的问题。不过这道题要知道Pad里的这个函数是private的……输出：Mini Pad11. Index Start With 0package Test11;public class HolyDays {public enum Days { SUN, MON, TUE, WED };public static void main(String[] args) {for (Days d : Days.values());     Days [] d = Days.values();     System.out.println(d[3]);   } }并不是很嗯那个理解考察点在哪里，可能是为了让大家知道，Index是从0开始的，所以3其实是第4个。输出：WED12. 线程运行package Test12;public class Sudo implements Runnable {  public static void main(String[] args) throws Exception {    Thread t = new Thread(new Sudo());    t.start();    System.out.print("Started");    t.join();    System.out.print("Complete");  }  public void run() {    for (int i = 0; i < 4; i++) {      System.out.print(i);    }  }}Java Thread中， join() 方法主要是让调用改方法的thread完成run方法里面的东西后， 在执行join()方法后面的代码。输出： Started0123Complete13.package Test13;public class Weibo {  private String content;  public String getContent() { return content; }  public void setContent(String d) { content = d; }  public static void modifyCont(Weibo weibo, String content) {    weibo = new Weibo();    weibo.setContent(content);  }  public static void main(String[] args) {    Weibo wb = new Weibo();    wb.setContent("javacontest");    Weibo wb2 = new Weibo();    wb2.setContent("jingkao");    modifyCont(wb, "sudocn");    System.out.println(wb.getContent());    System.out.println(wb2.getContent());  }}单单只是读一读代码，翻译过来好像就是 javacontest/jingkao 被修改成了 sudocn/jingkao这个似乎当时写错了，并不是很能理解，个人猜测可能是modifyCont操作并没有真正修改到值（有人能告诉我一下就非常感谢啦^_^）为啥Eclipse的输出是酱紫的：输出：javacontestjingkao14. 注意数据类型package Test14;public class Java {   Integer i;   int x;   public Java(int y) {     x = i + y;     System.out.println(x);   }   public static void main(String[] args) {     new Java(new Integer(4));   } }错在了 x=i+y 这一行，需要注意的是，i是Integer类的实例，而y是int整型的数值，以及这个Integer的声明之后似乎还没有被赋值过。结果：编译不通过Exception in thread "main" java.lang.NullPointerExceptionat Test14.Java.<init>(Java.java:7)at Test14.Java.main(Java.java:11)15. 优先队列package Test15;import java.util.PriorityQueue;public class Test {public static void main(String[] args) { PriorityQueue<String> pq = new PriorityQueue<String>(); pq.add("2"); pq.add("4"); System.out.print(pq.peek() + " "); pq.offer("1"); pq.add("3"); pq.remove("1"); System.out.print(pq.poll() + " "); if (pq.remove("2")) System.out.print(pq.poll() + " "); System.out.println(pq.poll() + " " + pq.peek());}}优先队列哎~ 这个我熟~~，优先队列的本质是堆，被当放入新的元素的时候它会自动排序。这里的顺序应该是 2 / 24 / 打印顶部2 / 1是个过客 / 234 / 依次输出2 3 4输出: 2 2 3 418. try...catchpackage Test18;class OhMyException {  static String s = "> ";  public static void main(String[] args) {    try {      throw new Exception();    } catch (Exception e) {      try {        try { throw new Exception(); }        catch (Exception ex) { s += "eric "; }        throw new Exception();      } catch (Exception x) { s += "michael "; }      finally { s += "fyi "; }    } finally { s += "chao "; }    System.out.println(s);  }}这是一个一环套一环，但是巧妙地全都用上了的try/catch机制示例输出：> eric michael fyi chao 20. 构造函数package Test20;class Fat {  String name = "No name";  public Fat(String nm) { name = nm; }}package Test20;public class FatTest {  public static void main(String[] args) {    Steven s = new Steven("90kg");    System.out.println(s.weight);  }}package Test20;class Steven extends Fat {String weight = "80kg";public Steven(String w){ weight = w; }}Class Steven中 public Steven(String w){weight=w;}这句，Steven(String w)下有红波浪线，编译错误：Implicit super constructor Fat() is undefined. Must explicitly invoke another constructor隐式的父级构造函数fat()是未定义的。必须显式地调用另一个构造函数21. 线程问题package Test21;public class Thread2 implements Runnable {  public void run() {    System.out.println("run.");    throw new RuntimeException("Problem");  }  public static void main(String[] args) {    Thread t = new Thread(new Thread2());    t.start();    System.out.println("End of method.");  }}存疑，这个部分理解得尚不透彻输出：（似乎有多种情况，输出其中一种）End of method.run.Exception in thread "Thread-0" java.lang.RuntimeException: Problemat Test21.Thread2.run(Thread2.java:6)at java.lang.Thread.run(Thread.java:745)24. 又一个线程问题package Test24;public class IncomprehensiveThread {  synchronized void a() { maybeBusy(); }  static synchronized void b() { maybeBusy(); }    static void maybeBusy() {    try { Thread.sleep(1000); }    catch (InterruptedException e) {}  }  public static void main(String[] args) {    final IncomprehensiveThread x = new IncomprehensiveThread();    final IncomprehensiveThread y = new IncomprehensiveThread();    Runnable runnable = new Runnable() {      public void run() {        int option = (int) (Math.random() * 4);        switch (option) {          case 0: x.a(); break;          case 1: x.b(); break;          case 2: y.a(); break;          case 3: y.b(); break;    } } };    Thread thread1 = new Thread(runnable);    Thread thread2 = new Thread(runnable);    thread1.start();    thread2.start();} }这个问题如果我没记错的话，问的是，x的a和b，与y的a和b，两两之间哪些不能同时运行。存疑。29. 编程题Apackage Test29;public class Adder {public static int add(int a,int b){return a+b;}public static double add(double a,double b){double result = Math.round(10*(a+b))/10.0;return result;}public static String add(String a,String b){return a+b;}}实现AdderTest里用到的所有复用，由于要求不能抛出异常，则每个按照异常中所要求的写好函数即可。30. 编程题B这题的难点在于串式调用以及省略号传参，可惜不懂得如何串式调用……31. 编程题Cpackage Test31;public class Person {String name;int age;public Person(String name, int age) {super();this.name = name;this.age = age;}public String getName() {return name;}public void setName(String name) {this.name = name;}public int getAge() {return age;}public void setAge(int age) {this.age = age;} public boolean equals(Object o)       {           if (this == o)           {               return true;           }           if (o.getClass() == Person.class)           {               Person n = (Person)o;               return n.name.equals(name)&&(n.age==age);           }           return false;       }  public int hashCode()       {          return (name+Integer.toString(age)).hashCode();       }        public String toString()       {           return "Name[name=" + name + ", age=" + age + "]";       }  }get/set无脑写上去，难点在哪里呢？ 对了，我们如果想用上哈希的话需要实现这三个： equals、hashCode 和 toString 方法。考虑到这个这题就差不多了。版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/45138293	Code Hunt 那真的是相当好玩~~ Section2 HuangHe（黄河Section）12分钟秒杀的快感，那种第一次看到数据闹钟就灵光一闪然后敲完直接3分的感觉简直欲罢不能~！赛时不敢写解题报告，比赛刚刚结束来写解题报告，结果……给锁住了不让看了……只好凭着记忆写一些给今后玩CH的自己，以及来看我博客的孩纸们耐心做个Hint了。小脑筋篇1. 给了也不用身边的好多同学都卡在了哪题呢？ return a[a.length-1]; 这题上，给了个数组，要求返回一个值，但是数组千奇百怪一时半会儿还真没看出问题来，但是……这题已经很良心了哟，Input的数组最后一个元素和Output离得那么近，就是提醒你，Output的不是数组内各种东西都用上，而是只要最后一个元素的值哦~除此之外印象中以前的CH也见过给三个数，只要用其中两个进行运算得到输出的题目存在。所以，不要傻乎乎的被给的那么多数据骗了哦~2. 常数去哪儿常常会有一个常数或者符号阻碍着获得分数的道路，还记得当年的 return 4/x; 么？还记得这次的 return(x*x*x-2*x)/2; 么？问题是他们是咋弄出来的呢？确实灵光一闪很重要，但其实如果真的想不出来，有个技巧是这样的（我们叫它骗数据法，想不出来的大家肯定都这么用过），没错，就是if/else大法，多刷点数据出来，当你一大排的if/else排的整整齐齐的时候，总能发现，等会这里有点蹊跷，或者说，啊怎么每一行我都得加一个取非逻辑运算呀，对了~这个就是关键，朝着共性去想吧~~~3.逻辑送分题一旦看到几个True/False输入，一个True/False输出，就该开心送分来了哇！为啥呢？直接能看出问题的咱忽略不计，要知道逻辑学里有一种传说级别的东西叫做真值表，咱就算打表也能轻松获得与非、与或非式不是么？当然个人还是觉得这是最终手段，咱还是猜着好玩是最有趣的~4.提示最亲切不说比赛，平日里打CodeHunt那14个Section的一堆题的时候，经常会有绿色的提示哦，往往里面会告诉你，学会某种函数会相当有好处，不要犹豫快去学就好~小函数篇1. 获得子串位置 s.IndexOf(String s);string s="this is a long string";int k=s.IndexOf("long");//k=10，索引从0开始，不包含则返回-12. 获得元素出现次数 Arr.Count(s=>s=="sth");int count = tmp.Count(s=>s=="example");3. 以子串开头/结尾 StartsWith(string value)/EndWith(string value);bool flag= s.StartWith("example");4. 连接数组，以某物做链接 s.Join(link_str,strArr);//Join, 哈哈哈还记得那个aXbXcXdXe怎么都不给3SP么，就是它！newStr="";String[] strArr={strA,strB};newStr=String.Join("^^",strArr);Console.WriteLine(newStr);//"Hello^^World"5.分隔字符串，以某物作分隔 public string[] Split(paramschar[] separator);//SplitnewStr="Hello^^World";char[] separator={'^'};String[] splitStrings=new String[100];splitStrings=newStr.Split(separator);inti=0;while(i<splitStrings.Length){<span style="white-space:pre"></span>Console.WriteLine("item{0}:{1}",i,splitStrings[i]);<span style="white-space:pre"></span>i++;}//输出结果如下：Item0:Hello Item1:  Item2:World6.插入填充字符串 str.Insert(pos,Insert_str);//InsertnewStr="";newStr=strA.Insert(1,strB);Console.WriteLine(newStr);//"HWorldello"，与Remove用法一致7. 进制转换int d = 10;//十进制转二进制字符串 Console.WriteLine(Convert.ToString(d,2));//输出: 1010//十进制转十六进制字符串Console.WriteLine(Convert.ToString(d,16));//输出: a//二进制字符串转十进制数string bin = "1010";Console.WriteLine(Convert.ToInt32(bin,2));//输出: 10//二进制字符串转十六进制数string bin = "1010";Console.WriteLine(string.Format("{0:x}",Convert.ToInt32(bin,2));//输出: a//十六进制转二进制字符串Console.WriteLine(Convert.ToString(0xa,2));//输出: 1010//十六进制转十进制数Console.WriteLine(Convert.ToString(0xa,10));//输出: 10int a = 188;  this.textBox1.Text = "";  this.textBox1.AppendText("a(10) = " + a.ToString() + "\n");  this.textBox1.AppendText("a(16) = " + a.ToString("x") + "\n");  this.textBox1.AppendText("a(16) = " + a.ToString("X") + "\n");  //输出a(10) = 188  a(16) = bc  a(16) = BC 8.二维数组定义int[][] ret= new int[m][];for(int i=0;i<m;i++){ ret[i]=new int[n]; for(int j=0;j<n;j++) ret[i][j]=(i+1)*(j+1);}return ret;来个错误示例：（在这里错了无数次，几近放弃）写的有些困了，今天先到这里吧，发几个当时瞬秒的题出来供大家参(de)考(se)参(de)考(se)。（最初一上来给的第一组数据为Attempt1，第一次提交时为Attempt2，所以这些尝试次数为2的代表了我看完第一次给的数据一次3SP通过~~~）以下为手气好+头脑灵光时刻的成就：Sec2 / 3SP连续秒杀纪念版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/45137461	题目1 : 2月29日时间限制:2000ms单点时限:1000ms内存限制:256MB描述给定两个日期，计算这两个日期之间有多少个2月29日（包括起始日期）。只有闰年有2月29日，满足以下一个条件的年份为闰年：1. 年份能被4整除但不能被100整除2. 年份能被400整除输入第一行为一个整数T，表示数据组数。之后每组数据包含两行。每一行格式为"month day, year"，表示一个日期。month为{"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November" , "December"}中的一个字符串。day与year为两个数字。数据保证给定的日期合法且第一个日期早于或等于第二个日期。输出对于每组数据输出一行，形如"Case #X: Y"。X为数据组数，从1开始，Y为答案。数据范围1 ≤ T ≤ 550小数据：2000 ≤ year ≤ 3000大数据：2000 ≤ year ≤ 2×109样例输入4January 12, 2012March 19, 2012August 12, 2899August 12, 2901August 12, 2000August 12, 2005February 29, 2004February 29, 2012样例输出Case #1: 1Case #2: 0Case #3: 1Case #4: 3这次在Hihocoder战场只看了两道题，两道都是1A，现在判定也结束了，两题的大小数据均AC，现在写一写题解作为备忘。首先就是这个第一题，给两个日期，问你两个日期之间经历了多少个闰年。首先，隔了那么几百万年我们肯定是不会逐年计算的对吧，我们要考虑到这一点才行哦~【每400年会经历97个闰年】（400/4）-（400/100）+（400/400）那么我们直接把后一个年份减去前一个年份对400取余，直接问题就简化成两者年份不大于400年之间有多少个闰年啦~但是这也不是一眼能看出来的哦~日期是不是很讨厌，如果所有的日期都在1月1日，那么是否只要考虑年份是否是闰年的年份就行了呢？那我们就把日期都变成下一年的1月1日吧（其实变成当年1月1日也一样，一个意思），用一个函数判断这样的日期推移会少算一个还是多算一个闰年，多退少补即可。然后~ 就从年份A到年份B数闰年吧~（其实直接对里面年份是4的倍数的进行判定就好，还能省一大半时间呢~）代码如下：Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))string m_name[12]={"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November" , "December"}; bool cmp(const int a, const int b){return a > b;}struct date_bag{int year;int month;int day;};int getM(string s){for(int i=0;i<12;i++){if(m_name[i]==s) return i+1;}return -1;}int jrun(int a){if(a%4==0 && a%100!=0) return 1;if(a%400==0) return 1;return 0;} int judge(date_bag db)//移至下一年 Jan.1st 是否会经历闰年 {if(jrun(db.year)==0) return 0;else{if(db.month>2) return 0;else return 1;}}int getrun(date_bag a,date_bag b){int cnt=0,y1=a.year+1,y2=b.year+1;if(jrun(b.year) && b.month==2 && b.day==29)cnt++;cnt+=judge(a);cnt-=judge(b);if(y1%4) y1+=4-y1%4;for(int i=y1;i<y2;i++){if(jrun(i))cnt++;}return cnt;}int main(){int cases=0;scanf("%d",&cases);for(int _case=1;_case<=cases;_case++){int ans=0;date_bag date[3];string m1,m2,d1,d2;cin>>m1>>d1>>date[1].year;cin>>m2>>d2>>date[2].year;date[1].month=getM(m1);date[2].month=getM(m2);if(d1.length()==2) date[1].day=d1[0]-'0';else date[1].day=(d1[0]-'0')*10 + (d1[1]-'0');if(d2.length()==2) date[2].day=d2[0]-'0';else date[2].day=(d2[0]-'0')*10 + (d2[1]-'0');if(date[2].year-date[1].year>400){int round=(date[2].year-date[1].year)/400;date[2].year-=round*400;ans+=round*97;}ans+=getrun(date[1],date[2]);printf("Case #%d: %d\n",_case,ans);}return 0;}题目2 : 回文字符序列时间限制:2000ms单点时限:1000ms内存限制:256MB描述给定字符串，求它的回文子序列个数。回文子序列反转字符顺序后仍然与原序列相同。例如字符串aba中，回文子序列为"a", "a", "aa", "b", "aba"，共5个。内容相同位置不同的子序列算不同的子序列。输入第一行一个整数T，表示数据组数。之后是T组数据，每组数据为一行字符串。输出对于每组数据输出一行，格式为"Case #X: Y"，X代表数据编号（从1开始），Y为答案。答案对100007取模。数据范围1 ≤ T ≤ 30小数据字符串长度 ≤ 25大数据字符串长度 ≤ 1000样例输入5abaabcbaddabcba12111112351121cccccccfdadfa样例输出Case #1: 5Case #2: 277Case #3: 1333Case #4: 127Case #5: 17给定一个字符串，问其中共有多少个回文子串（长度为1的也算），以及记得对100007取模。b数组是指，从s[i]到s[j]的回文子串数目，然后DP。具体的思路大概是这样。首先，i==j的时候就是说每一个单独的字符，是长度为1的回文子串，所以先做好b[i][i]=1初始化。然后，以每一个字符为中心位置，另一个变量枚举从0到len-i的位置进行更新，唔，感觉文字好难能讲的清楚，推荐在纸上画一下，照着下面的方程，状态转移方程如下：if(s[j]==s[i+j]) { b[j][i+j]=(b[j][i+j-1]+b[j+1][i+j]+1+vmod)%vmod; }else{tmp= (i+j-1<j+1)?0:b[j+1][i+j-1];b[j][i+j]=(b[j][i+j-1]+b[j+1][i+j]-tmp+vmod)%vmod; }大概是这种感觉。具体代码如下：Code:#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))int vmod=100007;int b[1024][1024];bool cmp(const int a, const int b){return a > b;}int solve(string s){int len=s.length();for(int i=0;i<len;i++) b[i][i]=1;//initfor(int i=1;i<len;i++)for(int j=0;j<len-i;j++){int tmp=0;if(s[j]==s[i+j]){b[j][i+j]=(b[j][i+j-1]+b[j+1][i+j]+1+vmod)%vmod;}else{tmp= (i+j-1<j+1)?0:b[j+1][i+j-1];b[j][i+j]=(b[j][i+j-1]+b[j+1][i+j]-tmp+vmod)%vmod;}}return (b[0][len-1]+vmod)%vmod;}int main(){int cases=0;scanf("%d",&cases);for(int _case=1;_case<=cases;_case++){memset(b,0,sizeof b);string s;cin>>s;int ans=0; ans=solve(s); printf("Case #%d: %d\n",_case,ans);}return 0;}题目3 : 基站选址时间限制:2000ms单点时限:1000ms内存限制:256MB描述需要在一个N × M的网格中建立一个通讯基站，通讯基站仅必须建立在格点上。网格中有A个用户，每个用户的通讯代价是用户到基站欧几里得距离的平方。网格中还有B个通讯公司，维护基站的代价是基站到最近的一个通讯公司的路程（路程定义为曼哈顿距离）。在网格中建立基站的总代价是用户通讯代价的总和加上维护基站的代价，最小总代价。输入第一行为一个整数T，表示数据组数。每组数据第一行为四个整数：N, M, A, B。接下来的A+B行每行两个整数x, y，代表一个坐标，前A行表示各用户的坐标，后B行表示各通讯公司的坐标。输出对于每组数据输出一行"Case #X: Y"，X代表数据编号（从1开始），Y代表所求最小代价。数据范围1 ≤ T ≤ 201 ≤ x ≤ N1 ≤ y ≤ M1 ≤ B ≤ 100小数据1 ≤ N, M ≤ 1001 ≤ A ≤ 100大数据1 ≤ N, M ≤ 1071 ≤ A ≤ 1000样例输入23 3 4 11 22 12 33 22 24 4 4 21 22 43 14 31 41 3样例输出Case #1: 4Case #2: 13想了想，虽然未能有勇气去挑战第三题，不过既然从童鞋那里获得了第三题的AC代码，还是贴于此可用于以后细细揣摩，善哉善哉。Code：#include <iostream>#include <cmath>#include <cstdio>#include <cstring>#include <algorithm>using namespace std;int num;typedef long long ll;ll res;int n,m,a,b;const double eps = 1e-8;int ax[1010], ay[1010];int bx[1010], by[1010];const ll INF = 0x3f3f3f3f3f3f3f3f;ll solve(int x, int y){ll res = 0;for(int i=1; i<=a; i++)res += (x-ax[i])*(x-ax[i]) + (y-ay[i])*(y-ay[i]);ll t = INF;for(int j=1; j<=b; j++){ll temp = abs(x - bx[j]) + abs(y-by[j]);t = min(temp, t);}res += t; return res;}ll sanfeny(int x){ll temp = INF;int l = 0;int r = m;while(l<r){int m1 = (r+l)/2;int m2 = (m1+r)/2;ll t1 = solve(x, m1);ll t2 = solve(x, m2);if(t1>t2)l = m1;elser = m2;temp = min(temp, min(t1,t2));}return temp;}int main(){cin>>num;int cn = 0;while(num--){res = INF;cin>>n>>m>>a>>b;for(int i=1; i<=a; i++)scanf("%d %d", ax+i, ay+i);for(int j=1; j<=b; j++)scanf("%d %d", bx+j, by+j);int l = 0;int r = n;while(l<r){int m1 = (l+r)>>1;int m2 = (m1+r)>>1;ll t1 = sanfeny(m1);ll t2 = sanfeny(m2);if(t1>t2)l = m1;elser = m2;res = min(res, min(t1, t2));}printf("Case #%d: ", ++cn);cout<<res<<endl;}return 0;} 把题目链接和结果放在这里，大家可以去Hiho上自己尝试一下哦~编号名称通过率通过人数提交人数A2月29日48%28275870B回文字符序列25%6842719C基站选址17%3301925版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/45114349	概述Failed Passing Tencent InterView由于报成了后台开发方向而不是程序设计软件开发……这便是我人生中的第一次面试么……( ▼-▼ )经历了一次相当不错的“这这这你问的都是什么没听说过”的笔试……然后通过了经历了一次相当不错的“救命你不要再问了我真的不懂啊”的初面……然后通过了……经历了一次相当不错的“哎被面试官吓得习惯了突然开始有个面色和蔼的面试官了哎”的终面……然后……等了12个小时之后得到的消息：您没有通过本轮面试哭……啊什么？程序设计软件开发考的都是C++、计网、算法数据结构…… 面试时流的血，都是选择方向时脑子进的水……与君共勉既然已经阵亡，那至少也得做个阵亡报告啊……<这些天有些太忙，过了3天才开始回忆感觉忘记得差不多了55555>先列个list暂作备忘，回忆起就立马写下来，想的差不多了之后将一个一个在网上找到相关的知识好好学一学，虽说方向不对，但是知道总比不知道好。<Updated 2015/04/18>笔试：TX的笔试是这样的：全程需要把目标焦点放在笔试主页面内，一旦鼠标点击了其他的地方，即便是同一个浏览器的其他选项卡，当前答题界面都会变成非激活状态，会有一个“请不要离开答题界面，三次将会视作作弊”的提示。大题都可以通过自己在纸上写好然后拍照下来上传到服务器的方式答题，除此之外，摄像头会全程开启，一直记录着做题中的你的一举一动。（其实说这么多我只想说，第一次看到这么厉害的东西我被吓到了所以完全不记得什么题目了o(^▽^)o）唔，仔细想想当时的附加题我每道题都写在纸上上传了来着，用这些来回忆了下~【代码】如何不用sizeof得到当前系统的INT整型长度【设计】对一个有负载上限的服务器，如何做到让其在过多的请求发送来的时候，拒绝超出其能力上限的服务请求。【知识】说出你所知道的IPC的种类及他们的优劣【内存】在一个stuct里有着几个不同数据类型的成员变量，问他们在内存中存在的形式初试：//项目经验及细节【基础】如何避免重复include【基础】如何定义一个常量，define和const的区别【经验】是否使用过GDB【协议】TCP/UDP区别【理论】对TCP协议的详细解释及过程说明Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/因特网互联协议，又名网络通讯协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。【原理】多线程，信号量【代码】折半查找复试：//自我介绍【区别】C++类构造函数、拷贝函数、运算符重载【环境】Linux环境下如何调试【协议】TCP/UDP区别【理论】static关键字的具体作用【协议】滑动窗口协议【协议】UDP具体流程【知识】信号量意义【代码】字符串最高频次字符及次数版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/45049565	写到第100000B次还在写Div2的感觉着实有点丢人…… 只能怪我的成长速度不如cf的题目难度提升速度了……果然，还是太弱了……这次绝对觉得E题是非常有希望出的，结果果然还是想多了……就算到现在都是出AC的最少的题…… 事实是白白消耗了比赛中七成的时间……Problems  #Name  AExamstandard input/output1 s, 256 MB  x3149BCovered Pathstandard input/output1 s, 256 MB  x2105CPolycarpus' Dicestandard input/output1 s, 256 MB  x1582DHandshakesstandard input/output1 s, 256 MB  x716EBerland Local Positioning Systemstandard input/output2 s, 256 MB  x103A. Examtime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputAn exam for n students will take place in a long and narrow room, so the students will sit in a line in some order. The teacher suspects that students with adjacent numbers (i and i + 1) always studied side by side and became friends and if they take an exam sitting next to each other, they will help each other for sure.Your task is to choose the maximum number of students and make such an arrangement of students in the room that no two students with adjacent numbers sit side by side.InputA single line contains integer n (1 ≤ n ≤ 5000) — the number of students at an exam.OutputIn the first line print integer k — the maximum number of students who can be seated so that no two students with adjacent numbers sit next to each other.In the second line print k distinct integers a1, a2, ..., ak (1 ≤ ai ≤ n), where ai is the number of the student on the i-th position. The students on adjacent positions mustn't have adjacent numbers. Formally, the following should be true: |ai - ai + 1| ≠ 1 for all i from 1 tok - 1.If there are several possible answers, output any of them.Sample test(s)input6output61 5 3 6 2 4input3output21 3有n个数字，要求任意相邻的两个不能是相邻的数（即差值的绝对值大于1），随意输出一种排列的方法。我们选取最中间的一个数，偶数的话取中位数左右两侧任意选一个，它就是MID，放在末尾的那个了，一边儿呆着去，然后从这个MID的左右开始，左一个，右一个，左一个，右一个，直到放完（这里要注意哦，左右有的时候不会同时取完哦，当n是偶数的时候一边会比另一边多一个），当（左边到了0&&右边到了n）的时候，结束for，把MID输出出来。ok啦~啊对了，n=2的时候除外哦。Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int main(){int n;cin>>n;if(n==1 || n==2) cout<<1<<endl<<1<<endl;else if(n==3) cout<<2<<endl<<"1 3"<<endl;else {printf("%d\n",n);int mid=n/2+1;for(int i=1;mid-i>0 || mid+i<=n;i++){if(mid-i>0) printf("%d ",mid-i);if(mid+i<=n) printf("%d ",mid+i);}printf("%d",n/2+1);}return 0;}B. Covered Pathtime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputThe on-board computer on Polycarp's car measured that the car speed at the beginning of some section of the path equals v1 meters per second, and in the end it is v2 meters per second. We know that this section of the route took exactly t seconds to pass.Assuming that at each of the seconds the speed is constant, and between seconds the speed can change at most by d meters per second in absolute value (i.e., the difference in the speed of any two adjacent seconds does not exceed d in absolute value), find the maximum possible length of the path section in meters.InputThe first line contains two integers v1 and v2 (1 ≤ v1, v2 ≤ 100) — the speeds in meters per second at the beginning of the segment and at the end of the segment, respectively.The second line contains two integers t (2 ≤ t ≤ 100) — the time when the car moves along the segment in seconds, d (0 ≤ d ≤ 10) — the maximum value of the speed change between adjacent seconds.It is guaranteed that there is a way to complete the segment so that:the speed in the first second equals v1,the speed in the last second equals v2,the absolute value of difference of speeds between any two adjacent seconds doesn't exceed d.OutputPrint the maximum possible length of the path segment in meters.Sample test(s)input5 64 2output26input10 1010 0output100NoteIn the first sample the sequence of speeds of Polycarpus' car can look as follows: 5, 7, 8, 6. Thus, the total path is 5 + 7 + 8 + 6 = 26meters.In the second sample, as d = 0, the car covers the whole segment at constant speed v = 10. In t = 10 seconds it covers the distance of 100 meters.第一眼看以为是物理吓我一跳……初速度是v1，末速度是v2，这个车最快的速度变量（注意不是加速度，这车的速度是瞬间变化的，厉害吧）绝对值不大于d，问在t秒的范围内，车最多走多远。我们知道，总路程=Sum（每秒钟的当前秒速）所以在保证每两个相邻秒内速度差的绝对值不大于d的同时，尽可能让他们大，就行了。据说叫尺取法？这个名词没有很懂呢，有懂的麻烦告诉我一声哦~我是在起点和终点两端开始，同时向中间走，每次+d，到了中间碰头（啊奇数的时候我处理了一下，左边的递增序列拿到中位数的那个点），然后开始while(1)判断，当左线的末端与右线的末端差值的绝对值不大于d时结束。否则哪边高了哪边就退一步让矮的那边来升一步，这道题说一定有解就说明这种方法一定会获得解，如果不一定有解的话，聪明的小读者（哈哈哈我早就想这么说一次了）你们会进行怎样的改动呢？Code:#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int v[128]={0};int getsum(int t){int s=0;//就这里忘了初始化0，就给我算错么Q^Q for(int i=0;i<t;i++){s+=v[i];//cout<<i<<":"<<v[i]<<endl;}return s;}int main(){int v1=0,v2=0,t=0,d=0,l=0,r=0;scanf("%d%d%d%d",&v1,&v2,&t,&d);v[0]=v1,v[t-1]=v2,r=t-1;//r=t-1 forgottenfor(int i=1;i<t-i-1;i++){l=i,r=t-i-1;v[l]=v[l-1]+d;v[r]=v[r+1]+d;//cout<<v[l]<<":"<<v[r]<<endl;}if(t%2){l++;v[l]=v[l-1]+d;}//cout<<l<<":"<<r<<endl;while(abs(v[l]-v[r])>d){if(v[l]>v[r]) v[l--]=v[r--]+d;else v[r++]=v[l++]+d;}cout<<getsum(t)<<endl;return 0;}C. Polycarpus' Dicetime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputPolycarp has n dice d1, d2, ..., dn. The i-th dice shows numbers from 1 to di. Polycarp rolled all the dice and the sum of numbers they showed is A. Agrippina didn't see which dice showed what number, she knows only the sum A and the values d1, d2, ..., dn. However, she finds it enough to make a series of statements of the following type: dice i couldn't show number r. For example, if Polycarp had two six-faced dice and the total sum is A = 11, then Agrippina can state that each of the two dice couldn't show a value less than five (otherwise, the remaining dice must have a value of at least seven, which is impossible).For each dice find the number of values for which it can be guaranteed that the dice couldn't show these values if the sum of the shown values is A.InputThe first line contains two integers n, A (1 ≤ n ≤ 2·105, n ≤ A ≤ s) — the number of dice and the sum of shown values where s = d1 + d2 + ... + dn.The second line contains n integers d1, d2, ..., dn (1 ≤ di ≤ 106), where di is the maximum value that the i-th dice can show.OutputPrint n integers b1, b2, ..., bn, where bi is the number of values for which it is guaranteed that the i-th dice couldn't show them.Sample test(s)input2 84 4output3 3 input1 35output4 input2 32 3output0 1 NoteIn the first sample from the statement A equal to 8 could be obtained in the only case when both the first and the second dice show 4. Correspondingly, both dice couldn't show values 1, 2 or 3.In the second sample from the statement A equal to 3 could be obtained when the single dice shows 3. Correspondingly, it couldn't show 1, 2, 4 or 5.In the third sample from the statement A equal to 3 could be obtained when one dice shows 1 and the other dice shows 2. That's why the first dice doesn't have any values it couldn't show and the second dice couldn't show 3.有n个骰子，他们掷出的点数和为A。然后告诉你每个骰子的最大点数di（意为他们的点数只能在1-di间取得）。问，对于每个骰子，它绝对不可能是的点数有多少种情况。我们记di的总和为s我们要这么想：对于某个骰子，除去它以外，别的骰子的点数和的取值区间，应该是不小于骰子数（n-1），不大于除去当前骰子以外的最大点数和（s-di），能想到这一步的话，不能掷出的点数种类数就明了了吧？好吧还是不清楚么？当前骰子总共有di种点数，其中它不能太小，小到其它骰子都是最大点数都不够到A，也不能太大，大到其他骰子都是最小点数1也超过A了。Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int n=0,d[200086]={0};ll  a=0,b[200086]={0},s=0;int main(){scanf("%d%I64d",&n,&a);for(int i=0;i<n;i++){scanf("%d",&d[i]);s+=d[i];}for(int i=0;i<n;i++){//不能取的有两种情况： ll si=a-s+d[i]-1; //small_impossible=其他都取最大时，不能小于某值 ll bi=d[i]-a+n-1;//big_impossible=其他都取最小值1时，不能大于某值 ll ai=0LL;//all_impossible if(si>=0 && bi>=0) ai=si+bi;else if(si>=0) ai=si;else if(bi>=0) ai=bi;else ai=0LL;b[i]=max(0LL,ai);printf("%I64d",b[i]);if(i<n-1)printf(" "); }return 0;}以及悲惨的自以为能过的E题……因为错了还是不说解题思路了，因为可能思路就是错的……Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}ll ans=0LL,tmp=0LL;ll dp[200086]={0};int mrk[200086]={0},tmrk[200086]={0};int main(){int n=0, now=0, i=0;cin>>n;for(i=1;i<=n;i++){scanf("%I64d",&dp[i]);}int m=0;cin>>m;for(i=0;i<m;i++){scanf("%d",&now);mrk[now]++;tmrk[now]++;}if(n==2){printf("%I64d",(dp[2]-dp[1])*(mrk[1]+mrk[2]-1));return 0;}int mr=min(mrk[1],mrk[n]);for(int i=2;i<=n-1;i++){tmrk[i]/=2;mr=min(mr,tmrk[i]);} if(mrk[1]>1 || mrk[n]>1 || mr>=1){int round=min(mrk[1],mrk[n]);round=min(mr,round);mrk[1]-=round; mrk[n]-=round;for(int i=2;i<=n-1;i++)mrk[i]-=round*2;ans+=(dp[n]-dp[1])*2*round;//cout<<round<<":"<<mrk[1]<<mrk[2]<<mrk[3];//cout<<"now"<<ans<<endl;}if(m==n*2-2){ll dist=dp[2]-dp[1];if(n!=2) for(int i=3;i<=n;i++){if(dp[i]-dp[i-1]!=dist){printf("-1");return 0;}}cout<<(ll)(dp[n]-dp[1])*2LL-dist<<endl;return 0;}int f1=0,f2l=0,f2r=0;int l1=0,l2=0,r1=0,r2=0;i=1;while(mrk[i]==0)i++; if(mrk[1]==1 && mrk[2]==2){mrk[1]=2;f2l=l2=1;while(mrk[l2]==2 && l2<=n)l2++;l2--;} if(mrk[n]==1 && mrk[n-1]==2){mrk[n]=2;f2r=1;r2=n;while(mrk[r2]==2 && r2>=1)r2--;r2++;}for(i=max(l2,i);i<=n;i++){if(f1==0 && mrk[i]==1){f1=1;l1=r1=i;while(mrk[r1]==1 && r1<=n) r1++;r1--;}}//ALLl2===================r2 <already considered>//f2l\f2r\f1 =========l2/l1--------------r1/r2============//f2l==========l2//f2rr2========== //f1\f2r     l1-------------r1/r2=============//f1\f2l============l2/l1------------//f1l1---------------------l2//cout<<l1<<":"<<r1<<"  "<<l2<<":"<<r2<<endl;if(f1) ans+=(ll)(dp[r1]-dp[l1]);if(f2l) ans+=(ll)(dp[l2]-dp[1])*2LL;if(f2r) ans+=(ll)(dp[n]-dp[r2])*2LL;if(f1&&f2l) ans+=(ll)(dp[l1]-dp[l1-1]);if(f1&&f2r) ans+=(ll)(dp[r1+1]-dp[r1]);cout<<ans<<endl;return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/44993421	今天Oracle来了一次赛前试考呢~吾辈的JAVA算是漏洞百出的菜鸟了，也凭着坚毅的意志（和高人@ZoeCur 的指点）完成了试考呢~选择题看似是问分隔之后有多少份，但实际上是问text.split的作用——先给个完整源码吧：package Test01;public class Test {public static void main(String[] args){String text = "Welcome to Java contest";String[] words = text.split("\s");System.out.println(words.length);}}编译时，在“\s"的部分会报错：Invalid escape sequence (valid ones are  \b  \t  \n  \f  \r  \"  \'  \\ )关于Split的使用，MSDN上给出了这样的源码（Language：C#）： 【看到了不错的点子，可以用这个去过CodeHunt那道AEIOU的题了】using System;public class SplitTest {    public static void Main() {        string words = "This is a list of words, with: a bit of punctuation" +                       "\tand a tab character.";        string [] split = words.Split(new Char [] {' ', ',', '.', ':', '\t' });        foreach (string s in split) {            if (s.Trim() != "")                Console.WriteLine(s);        }    }}// The example displays the following output to the console://       This//       is//       a//       list//       of//       words//       with//       a//       bit//       of//       punctuation//       and//       a//       tab//       character返回的数组元素中不包含分隔符字符。如果此实例不包含 separator 中的任何字符，则返回的数组由包含此实例的单个元素组成。如果 separator 参数为 null 或不包含任何字符，则采用空白字符作为分隔符。 空白字符由 Unicode 标准定义，如果将它们传递给Char.IsWhiteSpace 方法，将返回 true。separator 的每一个元素都定义一个单独的分隔符字符。 如果两个分隔符相邻，或者在此实例的开头或末尾找到分隔符，则相对应的数组元素包含 Empty。 下表提供了示例：字符串值Separator返回的数组"42, 12, 19"new Char[] {',', ' '} (C#)Char() = {","c, " "c}) (Visual Basic){"42", "", "12", "", "19"}"42..12..19"new Char[] {'.'} (C#)Char() = {"."c} (Visual Basic){"42", "", "12", "", "19"}"Banana"new Char[] {'.'} (C#)Char() = {"."c} (Visual Basic){"Banana"}"Darb\nSmarba" (C#)"Darb" & vbLf & "Smarba" (Visual Basic)new Char[] {} (C#)Char() = {} (Visual Basic){"Darb", "Smarba"}"Darb\nSmarba" (C#)"Darb" & vbLf & "Smarba" (Visual Basic)null (C#)Nothing (Visual Basic){"Darb", "Smarba"}然后就是那些呆萌呆萌的编程题咯~为啥我敢在这写……就不怕错了误导大家嘛？哈哈~~ 每道题我都从【等待评判中】一直等到了【完全正确】才写的下一题哦~嘛，话不多说，这次大概能学到东西的就是继承与实现了（前两道抄答案的题目如果都有人写错我就没话说了哟~）先给了一个抽象类，里头一个抽象函数，让你写一个公开矩形类继承它，需要构造函数和长宽的Get\Set函数package Test02;public abstract class Shape {abstract public int getArea();}这是个抽象类，是个抽象类，因为很重要所以说两次。抽象类里的东西继承类里你要是不给它写出来，你告诉我你Eclipse老提醒你要加abstract在你的public class前头，想想看，让你写的就是实现它要不然Shape类里抽象它干啥？关于Get\Set，Eclipse里有一键添加的快捷键哦~ 不要告诉别人我没提醒你哦~构造函数，花括号里的东西应该会写吧……为了方便理解还是贴个代码好了：package Test02;public class Rectangle extends Shape{int width;int height;Rectangle(int w,int h){width=w; height=h;}public int getWidth() {return width;}public void setWidth(int width) {this.width = width;}public int getHeight() {return height;}public void setHeight(int height) {this.height = height;}public int getArea(){return width * height;}public static void main(String[] args){}}然后是要一个接口的实现类……当时就懵掉了，啥，接口是啥，实现类又是啥，能吃么？后来问了大神，啊，关键字implements，然后构造函数是要new一个IList，那就声明一个IList，然后为它new一个写在构造函数里就好啦~接口如下：package Test03;public interface IList {void add(Object elem);Object get(int index);int size();void clear();}实现类如下：package Test03;public class MyList implements IList{public IList list;MyList(){list = new MyList();}public void add(Object elem){list.add(elem);}public Object get(int index){Object obj = list.get(index);return obj;}public int size(){return list.size();}public void clear(){list.clear();}public static void main(String[] args){}}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/44929233	竞赛考查参赛选手在Java技术和程序设计方面的综合技能，竞赛内容大纲如下：程序的构建，包括编译、运行、打包和文档生成等。语言基础，包括语法、变量、数组、流程控制、方法、包、类、枚举、接口等。面向对象特性，包括继承、封装、多态、抽象、访问控制。相关运行机制，包括异常、断言、垃圾收集等。常用工具库，包括线程及并发控制、文件及IO处理、泛型和集合类等。常用的类和接口，包括Object、字符串、序列化、比较、克隆等。竞赛题型包含客观题（单选、多选、填空）和编程题，采用自动评判系统客观评分，以保证竞赛的公平性和公正性。对于编程题，竞赛系统会对选手的答案进行即时评判，并将评判结果提示给参赛选手。选手可以在交卷前重复提交编程题的答案。甲骨文Oracle的JAVA比赛，嘛，我去报了个名参与下玩玩看，今天试了试模考，模拟一把看看感觉。然后发现……哭……这都是啥啦……和Ｃ＋＋差别好大，好可怕……暂记录过程中一些记忆较为深刻的部分于此，便于以后的查询以及进一步学习。package Test_3;public class ComplexCalc {public int value;public void calc() {value += 5;}}public class MoreComplexCalc extends ComplexCalc{public void calc() {value -=2;}public void calc(int multi){calc();super.calc();value *= multi;}public static void main(String[] args){MoreComplexCalc calc = new MoreComplexCalc();calc.calc(3);System.out.println("Oh it is: "+ calc.value);}}输出为：　Oh it is: 9这里的 clac.clac(3)，经历如下过程：(0-2+5)*3=9package Test_4;public class Test {private int a;public int b;protected int c;int d;public static void main(String[] args){Test test = new Test();int a = test.a++;int b = test.b--;int c = test.c++;int d = test.d--;System.out.println(a+"-"+b+"-"+c+"-"+d);}}输出为：０－０－０－０因为，改动的是test里的，对当前abcd没有改变package Test_5;import java.util.Collection;import java.util.HashSet;import java.util.LinkedList;import java.util.Set;public class TestSet {enum Num {ONE,THREE,TWO}public static void main(String[] args){Collection coll = new LinkedList();coll.add(Num.THREE);coll.add(Num.ONE);coll.add(Num.THREE);coll.add(Num.TWO);coll.add(Num.TWO);Set set = new HashSet(coll);System.out.println(set);System.out.println(coll);}}输出为：[TWO, THREE, ONE][THREE, ONE, THREE, TWO, TWO]package Test_6;public class Test {public static void main(String[] args){String[] elements = {"for","tea","too"};String first = (elements.length>0)?elements[0]:null;System.out.println(first);}}输出为：ｆｏｒpackage Test_8;public class JavaContest {public static void main(String[] args) throws Exception{Thread.sleep(3000);long n1=12_3_45___789;double n2=0b11001_001_0_0_11;float n3=0_1_2_3;System.out.println(n3);}}输出为：（等待１秒后）123457893219.083.0_作为连接用，不会对数字造成影响版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/44855399	今天在网上看到有人说LeetCode很适合刷题，于是我就随手点了一道题看看。Reverse Bits Total Accepted: 12829 Total Submissions: 47004My SubmissionsQuestion Solution Reverse bits of a given 32 bits unsigned integer.For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as00111001011110000010100101000000).Follow up:If this function is called many times, how would you optimize it?Related problem: Reverse Integer这是一道很普通的二进制求反序二进制的问题，脑中想到的自然还是和十进制一样取余放到新的数里去，然后乘以十循环到底。然后在Discuss看到一个3ms的算法，对哦~毕竟是二进制，那么因材制宜采用二进制的各种运算自然会快得多！二进制有哪些在底层来说是基础运算呢？ 逻辑运算，左右移。又因为uint32_t是一个32位的数，所以不管这数原先是多少都呆胶布~res=(res<<1)^(n&1)  容器左移一格然后把移出来的末位放上原数n的末尾n>>=1 然后原数的末尾就不需要咯，右移扔掉~Code：class Solution {public:    uint32_t reverseBits(uint32_t n) {        int i;        uint32_t res=0;        for(i=0;i<32;i++)        {            res=(res<<1)^(n&1);            n>>=1;        }        return res;    }};版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/44842909	今天阿里巴巴算法工程师实习生的笔试有这样一道题，问输出啥#include <iostream>using namespace std;int main(void){    const int a = 10;    int * p = (int *)(&a);    *p = 20;    cout<<"a = "<<a<<", *p = "<<*p<<endl;    return 0;}当时我凭感觉觉得——肯定是10，20吧考完之后尝试了一下编译运行果真如此，但是，很奇怪不是么，*p成20了我懂，但const的地址指向的地方都被改掉了呀，为啥a还是10呢？于是……到处找找看资料学习下const volatile int i = 10;  const int i = 10;  原来如此，这两个是不一样的，C++中有个东西叫做常量折叠，《定义》c++里的常量折叠（或者常量替换)是将const常量放在符号表中，而并不给其分配内存。编译器直接进行替换优化。嘛，简单的说，就是如果直接 const int i = 10; 和 #define i 10差不多（嘛，微妙的有点区别，不过10也看作是个整型大差不差了）实际上，在刚刚代码中*p=20的时候，确实const i所在地址的值被改成20了没错，但是会输出10，就是因为这个常量折叠的原因，当加上volatile（易变的）修饰符之后，系统就知道，嗯这个东西善变啊，输出的时候就不是从符号表中提取值而是乖乖从内存去读了，那样一来，就是20咯~~~P.S》 不是我黑VC++6.0哦……它可能确实……有点老了。在这方面我们凭事实说话……VS2010中，一切和上述说明一致，DevC++中，一切和上述说明一致，VC++6.0中，即便你加了volatile，也和没加一样输出10，20——虽然定义const变量的同时加上了volatile修饰符，但VC++ 6.0编译器还是进行了优化措施，输出 i 时 从编译器的符号表中取值，直接输出。const volatile int i = 10;  const int i = 10;  版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/44791591	腾讯笔试里有道题也是让人头晕的累的一塌糊涂，就是给了一群类，谁是谁的父类，子类，集成类，其中还有属性，还有析构什么什么的，问输出的是什么（其实是考察运行的顺序）那么，备忘记录下吧。c++ 类的继承与派生一、基本概念1、类的继承是新的类从已有类那里得到已有的特性。或从已有类产生新类的过程就是类的派生。原有的类称为基类或父类，产生的新类称为派生类或子类。2、派生类的声明class 派生类名：继承方式 基类名1， 继承方式 基类名2，...，继承方式 基类名n{    派生类成员声明；}; 3、一个派生类可以同时有多个基类这种情况称为多重继承，派生类只有一个基类，称为单继承。直接派生，间接派生。 4、继承方式规定了如何访问基类继承的成员。继承方式有public, private, protected。如果不显示给出继承方式，默认为private继承。继承方式指定了派生类成员以及类外对象对于从基类继承来的成员的访问权限。 5、派生类继承基类中除构造和析构函数以外的所有成员。 6、派生类生成：   吸收基类成员（除构造析构函数以外的所有成员）；   改造基类成员（根据继承方式调整基类成员的访问，函数在子类中的覆盖，以及虚函数在子类中的覆盖）；   添加新的成员； 7、公有继承当类的继承方式为公有继承时，基类的公有和保护成员的访问属性在派生类中不变，而基类的私有成员不可访问。即基类的公有成员和保护成员被继承到派生类中仍作为派生类的公有成员和保护成员。派生类的其他成员可以直接访问它们。无论派生类的成员还是派生类的对象都无法访问基类的私有成员。 8、私有继承当类的继承方式为私有继承时，基类中的公有成员和保护成员都以私有成员身份出现在派生类中，而基类的私有成员在派生类中不可访问。基类的公有成员和保护成员被继承后作为派生类的私有成员，派生类的其他成员可以直接访问它们，但是在类外部通过派生类的对象无法访问。无论是派生类的成员还是通过派生类的对象，都无法访问从基类继承的私有成员。通过多次私有继承后，对于基类的成员都会成为不可访问。因此私有继承比较少用。 9、保护继承保护继承中，基类的公有成员和私有成员都以保护成员的身份出现在派生类中，而基类的私有成员不可访问。派生类的其他成员可以直接访问从基类继承来的公有和保护成员，但是类外部通过派生类的对象无法访问它们，无论派生类的成员还是派生类的对象，都无法访问基类的私有成员。二、派生类的构造函数和析构函数1、派生类中由基类继承而来的成员的初始化工作还是由基类的构造函数完成，然后派生类中新增的成员在派生类的构造函数中初始化。 2、派生类构造函数的语法：派生类名::派生类名（参数总表）：基类名1（参数表1），基类名（参数名2）....基类名n（参数名n），内嵌子对象1（参数表1），内嵌子对象2（参数表2）....内嵌子对象n（参数表n）{    派生类新增成员的初始化语句；}注：构造函数的初始化顺序并不以上面的顺序进行，而是根据声明的顺序初始化。 3、如果基类中没有不带参数的构造函数，那么在派生类的构造函数中必须调用基类构造函数，以初始化基类成员。 4、派生类构造函数执行的次序：   调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左到右）；   调用内嵌成员对象的构造函数，调用顺序按照它们在类中声明的顺序；   派生类的构造函数体中的内容。例子：#include <iostream>#include <time.h>using namespace std;class B1{public:    B1(int i)    {        cout<<"constructing B1 "<<i<<endl;    }};class B2{public:    B2(int j)    {        cout<<"constructing B2 "<<j<<endl;    }};class B3{public:    B3()    {        cout<<"constructing B3"<<endl;    }};class C: public B2, public B1, public B3{public:    C(int a, int b, int c, int d):B1(a), memberB2(d), memberB1(c),B2(b)    {    }private:    B1 memberB1;    B2 memberB2;    B3 memberB3;};int main() {     C obj(1,2,3,4);    return 0; }C(a,b,c,d)赋值Then Class C: B2,B1,B3Then Private B1,B2,B3输出结果为：constructing B2 2constructing B1 1constructing B3constructing B1 3constructing B2 4constructing B3 5、析构函数派生类的析构函数的功能是在该对象消亡之前进行一些必要的清理工作，析构函数没有类型，也没有参数。析构函数的执行顺序与构造函数相反。例子：#include <iostream>#include <time.h>using namespace std;class B1{public:    B1(int i)    {        cout<<"constructing B1 "<<i<<endl;    }    ~B1()    {        cout<<"destructing B1"<<endl;    }};class B2{public:    B2(int j)    {        cout<<"constructing B2 "<<j<<endl;    }    ~B2()    {        cout<<"destructing B2"<<endl;    }};class B3{public:    B3()    {        cout<<"constructing B3"<<endl;    }    ~B3()    {        cout<<"destructing B3"<<endl;    }};class C: public B2, public B1, public B3{public:    C(int a, int b, int c, int d):B1(a), memberB2(d), memberB1(c),B2(b)    {    }private:    B1 memberB1;    B2 memberB2;    B3 memberB3;};int main() {     C obj(1,2,3,4);    return 0; }析构顺序为构造顺序反序输出结果为：constructing B2 2constructing B1 1constructing B3constructing B1 3constructing B2 4constructing B3destructing B3destructing B2destructing B1destructing B3destructing B1destructing B2 三、派生类成员的标识和访问1、派生类成员属性划分为四种：   不可访问的成员；私有成员；保护成员；公有成员； 2、作用域分辨形式为：基类名::成员名；基类名::成员名（参数表）；如果某派生类的多个基类拥有同名的成员，同时，派生类又新增这样的同名成员，在这种情况下，派生类成员将覆盖所有基类的同名成员。这就需要这样的调用方式才能调用基类的同名成员。例子：多继承同名 #include <iostream>#include <time.h>using namespace std;class B1{public:    int nV;    void fun()    {        cout<<"member of B1 "<<nV<<endl;    }};class B2{public:    int nV;    void fun()    {        cout<<"member of B2 "<<nV<<endl;    }};class D1: public B1, public B2{public:    int nV;    void fun()    {        cout<<"member of D1 "<<nV<<endl;    }};int main() {     D1 d1;    d1.nV = 1;    d1.fun();    d1.B1::nV = 2;    d1.B1::fun();    d1.B2::nV = 3;    d1.B2::fun();    return 0; }输出结果为：member of D1 1member of B1 2member of B2 3以上通过作用域分辨符，解决了访问基类中被屏蔽的同名成员。 3、如果某个派生类的部分或全部直接基类是从另一个共同的基类派生而来，在这些直接基类中，从上一级基类继承来的成员就拥有相同的名称，因此派生类中也就会产生同名现象，对这种类型的同名成员也要使用作用域分辨符来唯一标识，而且必须用直接基类进行限定。例子：#include <iostream>#include <time.h>using namespace std;class B0{public:    int nV;    void fun()    {        cout<<"member of B0 "<<nV<<endl;    }};class B1:public B0{public:    int nV1;};class B2:public B0{public:    int nV2;};class D1:public B1, public B2{public:    int nVd;    void fund()    {        cout<<"member of D1"<<endl;    }};int main() {     D1 d1;    d1.B1::nV = 2;    d1.B1::fun();    d1.B2::nV = 3;    d1.B2::fun();    return 0; }输出结果为：member of B0 2member of B0 3在这种情况下，派生类对象在内存中就同时拥有成员nV及fun的两份拷贝。但是很多情况下，我们只需要这样一个这样的数据拷贝，同一成员的多份拷贝增加了内存的开销。可以通过虚函数来解决这个问题。 4、虚基类为了解决前面提到的多重拷贝的问题，可以将共同基类设置为虚基类，这时从不同的路径继承过来的同名数据成员在内存中就只有一个拷贝，同一个函数也只有一个映射。虚基类的声明是在派生类的声明过程，其语法形式为：class 派生类名::virtual 继承方式 基类名；例子：#include <iostream>#include <time.h>using namespace std;class B0{public:    int nV;    void fun()    {        cout<<"member of B0 "<<nV<<endl;    }};class B1:virtual public B0{public:    int nV1;};class B2:virtual public B0{public:    int nV2;};class D1:public B1, public B2{public:    int nVd;    void fund()    {        cout<<"member of D1"<<endl;    }};int main() {     D1 d1;    d1.nV = 2;    d1.fun();    return 0; }输出结果为：member of B0 2 5、虚基类及其派生类的构造函数一般而言，派生类只对其直接基类的构造函数传递参数，但是在虚基类中，不管是直接或间接虚基类的所有派生类，都必须在构造函数的成员初始化列表中列出对虚基类的初始化。例子：#include <iostream>#include <time.h>using namespace std;class B0{public:    B0(int n)    {        nV = n;    }    int nV;    void fun()    {        cout<<"member of B0 "<<nV<<endl;    }};class B1:virtual public B0{public:    B1(int a):B0(a)       {    }    int nV1;};class B2:virtual public B0{public:    B2(int a):B0(a)    {    }    int nV2;};class D1:public B1, public B2{public:    D1(int a):B0(a), B1(a), B2(a)    {    }    int nVd;    void fund()    {        cout<<"member of D1"<<endl;    }};int main() {     D1 d1(1);    d1.nV = 2;    d1.fun();    return 0; }以上例子看上去B0的构造函数好像被调用了三次，但是实际上只有D1类中的D1(int a):B0(a), B1(a), B2(a)才是真正的调用了B0构造函数。 四、赋值兼容规则1、赋值兼容规则是指在需要基类对象的任何地方都可以使用公有派生类的对象来替代。2、赋值兼容规则中所指的替代包括：   派生类的对象可以赋值给基类对象；   派生类的对象可以初始化基类的引用；   派生类对象的地址可以赋给指向基类的指针。   在替代之后，派生类对象就可以作为基类的对象使用，但只能使用从基类继承的成员。例子：#include <iostream>#include <time.h>using namespace std;class B0{public:    void display()    {        cout<<"B0::display()"<<endl;    }};class B1:public B0{public:    void display()    {        cout<<"B1::display()"<<endl;    }};class B2:public B0{public:    void display()    {        cout<<"B2::display()"<<endl;    }};void fun(B0 *ptr){    ptr->display();}int main() {     B0 b0;    B1 b1;    B2 b2;    fun(&b0);    b0 = b1;    fun(&b0);    b0 = b2;    fun(&b0);    return 0; }输出结果为：B0::display()B0::display()B0::display()通过这种赋值兼容后，每次调用的同名函数都是基类的同名函数，如果想调用派生类的，则需要使用虚函数。JAVA类继承和初始化类初始化类的执行顺序：子类初始化-》-》子类构造方法-》父类-》构造方法-》属性-》构造方法中内容-》构造方法下面的内容-》子类属性-》子类构造方法中内容在Java编程语言中，对象的初始化是非常结构化的，这样做是为了保证安全。在前面的模块中，看到了当一个特定对象被创建时发生了什么。由于继承性，对象被完成，而且下述行为按顺序发生：（1）存储空间被分配并初始化到0值（2）进行显式初始化（3）调用构造方法（4）层次中的每个类都会发生最后两个步骤，是从最上层开始。Java技术安全模式要求在子类执行任何东西之前，描述父类的一个对象的各个方面都必须初始化。因此，Java编程语言总是在执行子构造方法前调用父类构造方法的版本。 有继承的类在运行的时候，一定要记得：初始化子类必先初始化父类，这是Java程序的一个基本运行过程。比如：public class Test extends Parent{private String name = "Java私塾";private int age = 2;public Test(){age = 1000;//期望能到1000年，呵呵}public static void main(String[] args) { Test t = new Test();System.out.println(t.name+"的年龄是"+t.age+"年");}}class Parent{private int num = 1;public Parent(){System.out.println("现在初始化父类");}public void test(){System.out.println("这是父类的test方法"); }}上述类的基本运行顺序是： （1）：先运行到第7行，这是程序的入口 （2）：然后运行到第8行，这里要new一个Test，就要调用Test的构造方法 （3）：就运行到第4行，注意：初始化子类必先初始化父类 （4）：要先初始化父类，所以运行到第14行 （5）：然后是第13行，初始化一个类，必须先初始化它的属性 （6）：然后是第15行 （7）：然后是第16行，表示父类初始化完成 （8）：然后是回到子类，开始初始化属性，因此运行到第2行，然后是第3行 （9）：子类属性初始化完过后，才回到子类的构造方法，执行里面的代码，也就是第5行 （10）：然后是第6行，表示new一个Test实例完成 （11）：然后回到main方法中执行第9行 （12）：然后是第10行 运行结果是： 现在初始化父类 Java私塾的年龄是1000年
http://blog.csdn.net/okcd00/article/details/44760113	StarsTime Limit: 1000MS Memory Limit: 65536KTotal Submissions: 35197 Accepted: 15277DescriptionAstronomers often examine star maps where stars are represented by points on a plane and each star has Cartesian coordinates. Let the level of a star be an amount of the stars that are not higher and not to the right of the given star. Astronomers want to know the distribution of the levels of the stars. For example, look at the map shown on the figure above. Level of the star number 5 is equal to 3 (it's formed by three stars with a numbers 1, 2 and 4). And the levels of the stars numbered by 2 and 4 are 1. At this map there are only one star of the level 0, two stars of the level 1, one star of the level 2, and one star of the level 3. You are to write a program that will count the amounts of the stars of each level on a given map.InputThe first line of the input file contains a number of stars N (1<=N<=15000). The following N lines describe coordinates of stars (two integers X and Y per line separated by a space, 0<=X,Y<=32000). There can be only one star at one point of the plane. Stars are listed in ascending order of Y coordinate. Stars with equal Y coordinates are listed in ascending order of X coordinate. OutputThe output should contain N lines, one number per line. The first line contains amount of stars of the level 0, the second does amount of stars of the level 1 and so on, the last line contains amount of stars of the level N-1.Sample Input51 15 17 13 35 5Sample Output12110HintThis problem has huge input data,use scanf() instead of cin to read data to avoid time limit exceed.SourceUral Collegiate Programming Contest 1999是时候捡起来线段树和树状数组了……题目大意：在坐标上有n个星星，如果某个星星坐标为(x, y), 它的左下位置为：(x0,y0)，x0<=x 且y0<=y。如果左下位置有a个星星，就表示这个星星属于level x按照y递增，如果y相同则x递增的顺序给出n个星星，求出所有level水平的数量。首先这道题看了网上的解题报告：线段树解法：#include<iostream>#include<cstdio>#include<cstring>#define mid ((left+right)>>1)#define lson rt<<1,left,mid#define rson rt<<1|1,mid+1,rightusing namespace std;const int MAXN = 32005;int sum[MAXN<<2],level[MAXN<<2];void update(int rt,int left,int right,int data){    ++sum[rt];    if(left==right) return;    if(data <= mid) update(lson,data);    else update(rson,data);}int query(int rt,int left,int right,int l,int r){    if(left==l && right==r) {        return sum[rt];    }    int m = mid;    if(r <= m) return query(lson,l,r);    else if(l > m) return query(rson,l,r);    else return query(lson,l,m)+query(rson,m+1,r);}int main(){    int n,x,y;    while(~scanf("%d",&n)){        memset(sum, 0, sizeof(sum));        memset(level, 0, sizeof(level));        for(int i=0; i<n; ++i){            scanf("%d%d",&x,&y);            ++x;            ++level[query(1,1,MAXN,1,x)];            update(1,1,MAXN,x);        }        for(int i=0; i<n; ++i)            printf("%d\n",level[i]);    }    return 0;}树状数组解法：#include<iostream>#include<cstdio>#include<cstring>using namespace std;const int MAXN = 32005;int c[MAXN],level[MAXN],n;int lowbit(int x){return x & (-x);}// 求前n项的和int sum(int n){    int sum = 0;    while(n > 0){        sum += c[n];        n -= lowbit(n);    }    return sum;}// 增加某个元素的大小void add(int x){    while(x <= MAXN){        ++c[x];        x += lowbit(x);    }}int main(){    int n,x,y;    while(~scanf("%d",&n)){        memset(level, 0, sizeof(level));        memset(c, 0, sizeof(c));        for(int i=0; i<n; ++i) {            scanf("%d%d",&x,&y);            ++x;            level[sum(x)]++;            add(x);        }        for(int i=0; i<n; ++i)            printf("%d\n",level[i]);    }    return 0;}相对的我还是比较喜欢树状数组的，今天看懂的一些小部分还是记录一下的好：首先，lowbit(x)是很常见的操作，作用为取当前数在二进制表示中最低位的1，比如10111000取lowbit就是1000，定义上则是 return x&(-x)C1 = A1C2 = A1 + A2C3 = A3C4 = A1 + A2 + A3 + A4C5 = A5C6 = A5 + A6C7 = A7C8 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8咱们来用这个来说明下意思：设节点编号为x，那么这个节点管辖的区间为2^k（其中k为x二进制末尾0的个数）个元素。因为这个区间最后一个元素必然为Ax，所以很明显：Cn = A(n – 2^k + 1) + ... + An使用lowbit的时候，一般有向上和向下（即加减）之分：求sum的时候，把区间一个接着一个的加起来，就是 i=x;i>0;i-=lowbit(i) n = n – lowbit(n)这一步实际上等价于将n的二进制的最后一个1减去，即一个接着一个的获取这个区间内的和，把这些和加起来就得到了所需要的和。当我们要把其中某个点加1的时候，是不是应该要把包含有它的所有区间记录也加一呢，那么问题来了，哪些有呢，那就是i=x;i<=maxn;i+=lowbit(i)知道了这些至少这道题就能解了，线段树神马的……咱以后再说好啦~ 赶紧去写作业哦~~~啊然后这是这道题我的Code：#include<cstdio>#include<iostream>#include<algorithm>using namespace std; #define maxn 32001int arr[maxn]={0};int lowbit(int i){return (i&-i);}void update(int x,int val){for(int i=x;i<=maxn;i+=lowbit(i))arr[i]+=val;}int getsum(int x){    int temp=0;    for(int i=x;i>0;i-=lowbit(i)) temp+=arr[i];    return temp;}int main(){int stars[maxn]={0};int n;scanf("%d",&n);for(int i=1;i<=n;i++){int x,y;scanf("%d%d",&x,&y);int l=getsum(x+1);stars[l]++;update(x+1,1);}for(int i=0;i<n;i++)printf("%d\n",stars[i]);return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/44727555	AVitaliy and Piestandard input/output2 s, 256 MB  x3268BPasha and Stringstandard input/output2 s, 256 MB  x2385CIlya and Sticksstandard input/output2 s, 256 MB  x1884DArthur and Wallsstandard input/output2 s, 512 MB  x320EAnya and Cubesstandard input/output2 s, 256 MB  x411在这么下去不行啊…… 数据结构依赖症需要改正了，明明数组简单粗暴而且不容易错，我非要用优先队列到底是为了什么……（C再次被Fst，哭）A. Vitaliy and Pietime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputAfter a hard day Vitaly got very hungry and he wants to eat his favorite potato pie. But it's not that simple. Vitaly is in the first room of the house with n room located in a line and numbered starting from one from left to right. You can go from the first room to the second room, from the second room to the third room and so on — you can go from the (n - 1)-th room to the n-th room. Thus, you can go to room x only from room x - 1.The potato pie is located in the n-th room and Vitaly needs to go there.Each pair of consecutive rooms has a door between them. In order to go to room x from room x - 1, you need to open the door between the rooms with the corresponding key.In total the house has several types of doors (represented by uppercase Latin letters) and several types of keys (represented by lowercase Latin letters). The key of type t can open the door of type T if and only if t and T are the same letter, written in different cases. For example, key f can open door F.Each of the first n - 1 rooms contains exactly one key of some type that Vitaly can use to get to next rooms. Once the door is open with some key, Vitaly won't get the key from the keyhole but he will immediately run into the next room. In other words, each key can open no more than one door.Vitaly realizes that he may end up in some room without the key that opens the door to the next room. Before the start his run for the potato pie Vitaly can buy any number of keys of any type that is guaranteed to get to room n.Given the plan of the house, Vitaly wants to know what is the minimum number of keys he needs to buy to surely get to the room n, which has a delicious potato pie. Write a program that will help Vitaly find out this number.InputThe first line of the input contains a positive integer n (2 ≤ n ≤ 105) — the number of rooms in the house.The second line of the input contains string s of length 2·n - 2. Let's number the elements of the string from left to right, starting from one.The odd positions in the given string s contain lowercase Latin letters — the types of the keys that lie in the corresponding rooms. Thus, each odd position i of the given string s contains a lowercase Latin letter — the type of the key that lies in room number (i + 1) / 2.The even positions in the given string contain uppercase Latin letters — the types of doors between the rooms. Thus, each even position i of the given string s contains an uppercase letter — the type of the door that leads from room i / 2 to room i / 2 + 1.OutputPrint the only integer — the minimum number of keys that Vitaly needs to buy to surely get from room one to room n.Sample test(s)input3aAbBoutput0input4aBaCaBoutput3input5xYyXzZaZoutput2有n个房间，每个房间放着一个钥匙，到下一个房间都会有一个门，每个门和钥匙的对应方式是同一个字母的大小写。问初始的时候需要多少钥匙才能到达终点。这个就想象成游戏的时候的钥匙寄存数组就好，发现钥匙则 record[钥匙]++,遇到门的时候如果有钥匙就record[钥匙]--，没有钥匙就说明初始的时候需要带着这个钥匙，则ans++，遍历完了之后输出ans即可。Code：#include <map>#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}map<char,int> mci;int main(){mci.clear();int n,ans=0; cin>>n;string s;cin>>s;for(int i=0;i<s.length();i++){if(islower(s[i])) mci[s[i]]++;if(isupper(s[i])) {if(mci[tolower(s[i])]==0) ans++;else mci[tolower(s[i])]--;}//cout<<i<<":"<<ans<<endl;}cout<<ans;return 0;}B. Pasha and Stringtime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputPasha got a very beautiful string s for his birthday, the string consists of lowercase Latin letters. The letters in the string are numbered from 1 to |s| from left to right, where |s| is the length of the given string.Pasha didn't like his present very much so he decided to change it. After his birthday Pasha spent m days performing the following transformations on his string — each day he chose integer ai and reversed a piece of string (a segment) from position ai to position |s| - ai + 1. It is guaranteed that 2·ai ≤ |s|.You face the following task: determine what Pasha's string will look like after m days.InputThe first line of the input contains Pasha's string s of length from 2 to 2·105 characters, consisting of lowercase Latin letters.The second line contains a single integer m (1 ≤ m ≤ 105) —  the number of days when Pasha changed his string.The third line contains m space-separated elements ai (1 ≤ ai; 2·ai ≤ |s|) — the position from which Pasha started transforming the string on the i-th day.OutputIn the first line of the output print what Pasha's string s will look like after m days.Sample test(s)inputabcdef12outputaedcbfinputvwxyz22 2outputvwxyzinputabcdef31 2 3outputfbdcea有一个字符串，在m天的时间内，这位同学每天都会选择一个位置a，然后把从左边数第a个和右边数第a个字符以及他们中间的字符组成的字符串反转顺序，问这m天过去之后字符串是什么样子的。我们要知道，每个字符只有2种可能，原字符，或者和他对称的右边那个字符，因为无论怎么颠倒，每个字符也不会在这两种位置以外的地方。那么我们用一个数组来标记这个字符是否在原位，那有人问了，难道用线段树维护，区间加一减一么？不好意思，本人的线段树也不熟呢，话说你会的话求教我一下呢哈哈哈~这里的话我们记忆的仅仅只是每个位置被a挑中的奇偶性，因为奇数次相当于颠倒1次，偶数次等于没做事嘛。For example，如果现在第i位的字符，被选中偶数次，那么对于它来说，他和他前面的那个字符是一样的情况，前面那个字符i-1位如果是交换状态，那么这个第i位也应该是处于要交换的状态，反之，我相当于颠倒了一次，那么是否交换应该和前一个的情况相反。这个想清楚了的话那就简单的多啦~Code:#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int main(){string s;int m=0,now=0,a[100086]={0},b[200086]={0};cin>>s>>m;int len=s.length();for(int i=0;i<m;i++){scanf("%d",&now);a[now-1]=1-a[now-1];}int rev=0;for(int i=0;i<len/2;i++){if(a[i]!=0) rev=1-rev;b[i]=b[len-i-1]=rev;}for(int i=0;i<len;i++){if(b[i]==1) printf("%c",s[len-i-1]);else printf("%c",s[i]);}return 0;}C. Ilya and Stickstime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputIn the evening, after the contest Ilya was bored, and he really felt like maximizing. He remembered that he had a set of n sticks and an instrument. Each stick is characterized by its length li.Ilya decided to make a rectangle from the sticks. And due to his whim, he decided to make rectangles in such a way that maximizes their total area. Each stick is used in making at most one rectangle, it is possible that some of sticks remain unused. Bending sticks is not allowed.Sticks with lengths a1, a2, a3 and a4 can make a rectangle if the following properties are observed:a1 ≤ a2 ≤ a3 ≤ a4a1 = a2a3 = a4A rectangle can be made of sticks with lengths of, for example, 3 3 3 3 or 2 2 4 4. A rectangle cannot be made of, for example, sticks 5 5 5 7.Ilya also has an instrument which can reduce the length of the sticks. The sticks are made of a special material, so the length of each stick can be reduced by at most one. For example, a stick with length 5 can either stay at this length or be transformed into a stick of length 4.You have to answer the question — what maximum total area of the rectangles can Ilya get with a file if makes rectangles from the available sticks?InputThe first line of the input contains a positive integer n (1 ≤ n ≤ 105) — the number of the available sticks.The second line of the input contains n positive integers li (2 ≤ li ≤ 106) — the lengths of the sticks.OutputThe first line of the output must contain a single non-negative integer — the maximum total area of the rectangles that Ilya can make from the available sticks.Sample test(s)input42 4 4 2output8input42 2 3 5output0input4100003 100004 100005 100006output10000800015有一堆棍子，对于每个棍子，我们有“使用原长度”和“使用原长度减一”两种选择，问组成的矩形总面积的最大值。我们从平方差公式知道，距离越小的长宽之积越大，一边长一定的时候，面积与另一边长成正比增加。那么就简单了，排序之后从大到小找可以做对边的两根棍子做长边，再找一对做短边，乘积加进ans里，然后再找长边……如此循环重复，O(n)结束战斗Code：#include <cmath> #include <queue>#include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))int n=0, ct=0, a[100086]={0}, b[100086]={0};int main() {    cin>>n;    for(int i=1;i<=n;++i) scanf("%d",&a[i]);    sort(a+1,a+n+1);    for(int i=n; i>=0; i-=2) {        if(a[i] == a[i-1]) b[ct++]=a[i];        else {            if(a[i]-a[i-1] == 1) b[ct++]=a[i-1];            else ++i;        }    }    ll ans=0;    for(int i=0;i<=ct-1;i+=2) ans+=(ll)b[i]*b[i+1];    cout<<ans;    return 0;}D. Arthur and Wallstime limit per test2 secondsmemory limit per test512 megabytesinputstandard inputoutputstandard outputFinally it is a day when Arthur has enough money for buying an apartment. He found a great option close to the center of the city with a nice price.Plan of the apartment found by Arthur looks like a rectangle n × m consisting of squares of size 1 × 1. Each of those squares contains either a wall (such square is denoted by a symbol "*" on the plan) or a free space (such square is denoted on the plan by a symbol ".").Room in an apartment is a maximal connected area consisting of free squares. Squares are considered adjacent if they share a common side.The old Arthur dream is to live in an apartment where all rooms are rectangles. He asks you to calculate minimum number of walls you need to remove in order to achieve this goal. After removing a wall from a square it becomes a free square. While removing the walls it is possible that some rooms unite into a single one.InputThe first line of the input contains two integers n, m (1 ≤ n, m ≤ 2000) denoting the size of the Arthur apartments.Following n lines each contain m symbols — the plan of the apartment.If the cell is denoted by a symbol "*" then it contains a wall.If the cell is denoted by a symbol "." then it this cell is free from walls and also this cell is contained in some of the rooms.OutputOutput n rows each consisting of m symbols that show how the Arthur apartment plan should look like after deleting the minimum number of walls in order to make each room (maximum connected area free from walls) be a rectangle.If there are several possible answers, output any of them.Sample test(s)input5 5.*.*.*****.*.*.*****.*.*.output.*.*.*****.*.*.*****.*.*.input6 7***.*.*..*.*.**.*.*.**.*.*.*..*...********output***...*..*...*..*...*..*...*..*...********input4 5............***..*..output....................有一张图，星号是墙，点号是空地，要求推倒最少数量的墙，令所有的房间都是矩形。简单的说，如果发现L形，那么那个阻碍成为矩形的墙就需要被消灭掉,然后接着看会造成的其他的影响一个个磨消掉，直到达成最终要求即可。Code：#include <bits/stdc++.h>//Code By cikofte@Codeforces#include <cmath> #include <queue>#include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;#definest first#definend second#definemp make_pair#definepb push_back#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))#definectrl( xx,yy )( xx>=1 and yy>=1 and xx<=m and yy<=n and s[xx][yy]=='.' )using namespace std;intm,n;chars[3000][3000];charh[3000][3000];intbozuk( int x,int y )//Bad mood .Turkey{if( s[x][y]!='*' )return0;if( ctrl( x-1,y ) and ctrl( x-1,y+1 ) and ctrl( x,y+1 ) )return1;if( ctrl( x,y+1 ) and ctrl( x+1,y+1 ) and ctrl( x+1,y ) )return1;if( ctrl( x+1,y ) and ctrl( x+1,y-1 ) and ctrl( x,y-1 ) )return1;if( ctrl( x,y-1 ) and ctrl( x-1,y-1 ) and ctrl( x-1,y ) )return1;return0;}int main(){cin>>m>>n;for(ll i=1;i<=m;i++)scanf("%s",s[i]+1);queue< pair<int,int> >Q;for(ll i=1;i<=m;i++)for(ll j=1;j<=n;j++)if( bozuk( i,j ) )Q.push( mp(i,j) ), h[i][j]=1;intx,y,xx,yy;while( Q.size() ){x = Q.front().st;y = Q.front().nd;Q.pop();s[x][y] = '.';h[x][y] = 0;for(ll i=-1;i<=1;i++)for(ll j=-1;j<=1;j++){if( !i and !j )continue;xx = x+i;yy = y+j;if( xx<1 or xx>m or yy<1 or yy>n or h[xx][yy] or !bozuk( xx,yy ) )continue;Q.push( mp(xx,yy) ), h[xx][yy] = 1;s[xx][yy] = '.';}}for(ll i=1;i<=m;i++) printf("%s\n",s[i]+1);return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/44725753	并不需要很多语言说明（其实是查了半天发现啊啦根本不需要说明找到就行），感觉放着两张图以后能找到在哪就行了两张图结束战斗，简单明了~~~File-Properties文件-属性Advanced-Encoding-utf8-CS-Enter编码从默认改成UTF8-简体中文版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/44650269	</pre><p></p><p></p><p>之前腾讯模拟笔试的时候，出了一道sizeof的题目，问没有规定大小的各种数据类型指针的size，于是这次还是写个文章测试顺便备忘一下。</p><p>测试代码：</p><p></p><pre code_snippet_id="628654" snippet_file_name="blog_20150326_2_2178915" name="code" class="cpp">#include <map>#include <cmath>#include <vector>#include <cstdio>#include <string>#include <cstring> #include <iostream>#include <algorithm>using namespace std;typedef long long ll;int main(){int *a,b;float *c,d;double *e,f;char *g,h;map<int,int> mii;map<double,double> mdd;map<char,char> mcc;map<string,int> msi;vector<int> vi;vector<double> vd;string *s,str;cout<<"int* \t"<<sizeof a<<endl;cout<<"int \t"<<sizeof b<<endl;cout<<"float* \t"<<sizeof c<<endl;cout<<"float \t"<<sizeof d<<endl;cout<<"double* "<<sizeof e<<endl;cout<<"double \t"<<sizeof f<<endl;cout<<"char* \t"<<sizeof g<<endl;cout<<"char \t"<<sizeof h<<endl;cout<<"mii \t"<<sizeof mii<<endl;cout<<"mdd \t"<<sizeof mdd<<endl;cout<<"mcc \t"<<sizeof mcc<<endl;cout<<"msi \t"<<sizeof msi<<endl;cout<<"veci \t"<<sizeof vi<<endl;cout<<"vecd \t"<<sizeof vd<<endl;cout<<"str* \t"<<sizeof s<<endl;cout<<"str \t"<<sizeof str<<endl;return 0; } 结果int*    8int     4float*  8float   4double* 8double  8char*   8char    1mii     48mdd     48mcc     48msi     48veci    24vecd    24str*    8str     8#include<iostream>class A{};class B{private:int a;};class B1{private:void fun(){}};class C{virtual void fun() = 0;};class D{virtual void fun(){std::cout << "this is a D1.";}};class D1{virtual void fun(){std::cout << "this is a D2.";}virtual void fun1(){std::cout << "this is a D2.";}};class D2:public D1,public D{virtual void fun(){std::cout << "this is a D3.";}virtual void fun1(){std::cout << "this is a D3.";}};class D3 :public D1, public D{virtual void fun3(){std::cout << "this is a D3.";}};class D4 :public D1, public B1{virtual void fun3(){std::cout << "this is a D3.";}};class E {void show(){std::cout << "THIS IS E";}};class F :public A{virtual void show(){std::cout << "THIS IS E";}};int main(){std::cout << "empty class's size is " << sizeof(A) << std::endl;std::cout << "only one int class's size is " << sizeof(B) << std::endl;std::cout << "only one funciton class's size is " << sizeof(B1) << std::endl;std::cout << "only one virtual pure funciton class's size is " << sizeof(C) << std::endl;std::cout << "only one virtual function class's size is " << sizeof(D) << std::endl;std::cout << "two virtual function class's size is " << sizeof(D1) << std::endl;std::cout << "three virtual function two jicheng(TWO VIRTUAL) class's size is " << sizeof(D2) << std::endl;std::cout << "three virtual function two jicheng(ONE VIRTUAL) class's size is " << sizeof(D4) << std::endl;std::cout << "four virtual function two jicheng class's size is " << sizeof(D3) << std::endl;std::cout << "only one  function class's size is " << sizeof(E) << std::endl;std::cout << "only one  virtual function class's size is " << sizeof(E) << std::endl;getchar();}反正写了也是写了，再看看类吧empty class's size is 1only one int class's size is 4only one funciton class's size is 1only one virtual pure funciton class's size is 8only one virtual function class's size is 8two virtual function class's size is 8three virtual function two jicheng(TWO VIRTUAL) class's size is 16three virtual function two jicheng(ONE VIRTUAL) class's size is 8four virtual function two jicheng class's size is 16only one  function class's size is 1only one  virtual function class's size is 1版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/44408489	Problems  #Name  APlaying with Paperstandard input/output2 s, 256 MB  x2429BError Correct Systemstandard input/output2 s, 256 MB  x953CGlass Carvingstandard input/output2 s, 256 MB  x584第三十次……好想到紫啊好想紫55555，两个1A，14min，然后我看Standing的时候你们造么！ 28名啊！！！然后被C骗住了，我以为是zkw线段树……居然是考察数据结构set的问题……然后……Failed System Test…… 原因？A. Playing with Papertime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputOne day Vasya was sitting on a not so interesting Maths lesson and making an origami from a rectangular a mm  ×  bmm sheet of paper (a > b). Usually the first step in making an origami is making a square piece of paper from the rectangular sheet by folding the sheet along the bisector of the right angle, and cutting the excess part.After making a paper ship from the square piece, Vasya looked on the remaining (a - b) mm  ×  b mm strip of paper. He got the idea to use this strip of paper in the same way to make an origami, and then use the remainder (if it exists) and so on. At the moment when he is left with a square piece of paper, he will make the last ship from it and stop.Can you determine how many ships Vasya will make during the lesson?InputThe first line of the input contains two integers a, b (1 ≤ b < a ≤ 1012) — the sizes of the original sheet of paper.OutputPrint a single integer — the number of ships that Vasya will make.Sample test(s)input2 1output2input10 7output6input1000000000000 1output1000000000000NotePictures to the first and second sample test.说一张长方形的纸~，每次都以较短边为边长裁一个正方形下来折个纸船，问长宽已知的长方形纸能折多少个纸船。我想说……做题的时候有这个图么！！！每次如果裁剪的效果没有达到a的剩余部分<b，那下次依然要剪b边长的正方形。其实看到这个图大家应该就立马懂了，每次不要一裁裁一个正方形，咱们要裁一串，就是 a/b 个。Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int main(){long long a=0,b=0,c=0,t=0;cin>>a>>b;while(a!=b){if(a%b){c+=(a/b);a=a%b;t=a;a=b;b=t;}else{c+=(a/b);a=b;}}cout<<c<<endl; return 0;}B. Error Correct Systemtime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputFord Prefect got a job as a web developer for a small company that makes towels. His current work task is to create a search engine for the website of the company. During the development process, he needs to write a subroutine for comparing strings S and T of equal length to be "similar". After a brief search on the Internet, he learned about theHamming distance between two strings S and T of the same length, which is defined as the number of positions in which S and T have different characters. For example, the Hamming distance between words "permanent" and "pergament" is two, as these words differ in the fourth and sixth letters.Moreover, as he was searching for information, he also noticed that modern search engines have powerful mechanisms to correct errors in the request to improve the quality of search. Ford doesn't know much about human beings, so he assumed that the most common mistake in a request is swapping two arbitrary letters of the string (not necessarily adjacent). Now he wants to write a function that determines which two letters should be swapped in stringS, so that the Hamming distance between a new string S and string T would be as small as possible, or otherwise, determine that such a replacement cannot reduce the distance between the strings.Help him do this!InputThe first line contains integer n (1 ≤ n ≤ 200 000) — the length of strings S and T.The second line contains string S.The third line contains string T.Each of the lines only contains lowercase Latin letters.OutputIn the first line, print number x — the minimum possible Hamming distance between strings S and T if you swap at most one pair of letters in S.In the second line, either print the indexes i and j (1 ≤ i, j ≤ n, i ≠ j), if reaching the minimum possible distance is possible by swapping letters on positions i and j, or print "-1 -1", if it is not necessary to swap characters.If there are multiple possible answers, print any of them.Sample test(s)input9pergamentpermanentoutput14 6input6wookiecookieoutput1-1 -1input4petregoroutput21 2input6doublebundleoutput24 1NoteIn the second test it is acceptable to print i = 2, j = 3.所谓海明距离，就是字符串s和字符串t字符不同的位置个数，比如acm和acg，有一个字符不同，所以是1.题目问，如果最多允许把s中的两个不同位置的字符调换位置，那么调换后（也可以不调换）海明距离最小是多少。假设原先海明距离是k，不调换肯定依然是k，调换的话如果要比k小只有2种情况：1）[s]A [t]B 和某处的[s]B [t]A 调换位置，那么有两个不同处被解决了，即海明距离小了2个，最小为k-2.2）[s]A [t]B 和某处的[s]B [t]C 调换位置，或[s]A [t]B 和某处的[s]C [t]A 调换位置， 那么有一个不同处被解决了，即海明距离小了2个，最小为k-1.那么，该怎么写呢?由于字符的不同处可多可少，感觉如果全都消耗时间空间比较浪费所以我使用的是map，有的就放进来，读的过程中还可以同时把海明距离数出来，这是O(n)。用map找由于其本质是红黑树，所以是在O(lgn)的时间内寻找到，综合来看最坏情况也是nlgn，可行。Code：#include <map>#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef pair<char,char> pcc;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}map <pcc,int> mpi;map <char,int> mci,mcii;int main(){int flag=0,x=-1,y=-1;int n=0,cnt=0;cin>>n;string s,t;cin>>s>>t;mpi.clear(); mci.clear(); mcii.clear();for(int i=0;i<n;i++){if(s[i]!=t[i]){cnt++;if(flag<2 && mpi[make_pair(t[i],s[i])]!=0) flag=2,x=mpi[make_pair(t[i],s[i])],y=i+1;mpi[make_pair(s[i],t[i])]=i+1;if(flag<1 && mci[s[i]]!=0) flag=1,x=mci[s[i]],y=i+1;mci[t[i]]=i+1;//why forget a half ,my god...if(flag<1 && mcii[t[i]]!=0) flag=1,x=mcii[t[i]],y=i+1;mcii[s[i]]=i+1;}}cout<<cnt-flag<<endl<<x<<' '<<y<<endl;return 0;}C. Glass Carvingtime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputLeonid wants to become a glass carver (the person who creates beautiful artworks by cutting the glass). He already has a rectangular w mm  ×  h mm sheet of glass, a diamond glass cutter and lots of enthusiasm. What he lacks is understanding of what to carve and how.In order not to waste time, he decided to practice the technique of carving. To do this, he makes vertical and horizontal cuts through the entire sheet. This process results in making smaller rectangular fragments of glass. Leonid does not move the newly made glass fragments. In particular, a cut divides each fragment of glass that it goes through into smaller fragments.After each cut Leonid tries to determine what area the largest of the currently available glass fragments has. Since there appear more and more fragments, this question takes him more and more time and distracts him from the fascinating process.Leonid offers to divide the labor — he will cut glass, and you will calculate the area of the maximum fragment after each cut. Do you agree?InputThe first line contains three integers w, h, n (2 ≤ w, h ≤ 200 000, 1 ≤ n ≤ 200 000).Next n lines contain the descriptions of the cuts. Each description has the form H y or V x. In the first case Leonid makes the horizontal cut at the distance y millimeters (1 ≤ y ≤ h - 1) from the lower edge of the original sheet of glass. In the second case Leonid makes a vertical cut at distance x (1 ≤ x ≤ w - 1) millimeters from the left edge of the original sheet of glass. It is guaranteed that Leonid won't make two identical cuts.OutputAfter each cut print on a single line the area of the maximum available glass fragment in mm2.Sample test(s)input4 3 4H 2V 2V 3V 1output8442input7 6 5H 4V 3V 5H 2V 1output28161264NotePicture for the first sample test:Picture for the second sample test: 有一块大大的玻璃~~~每次横着或者竖着砍一刀，砍完不要拿走，下一道也得砍到这条线所在的所有部件。每次砍完之后输出当前碎片中最大面积的部件的面积。首先要知道的是，千万别一个一个部件的比较面积大小哦，因为每刀都是垂直或者水平的，所以每部分的面积都等于所对应的长边线段和短边线段的积。即：我们要求的其实只是长边上的最长线段和短边上的最长线段，输出它们的积。这题的标签写的是《数据结构》，于是想到了set / multiset 的数据结构，感觉很适合这道题，因为其insert() , find()和erase()函数的存在，对这道题而言。嘛，也顺带用两个例程说明下这三个函数的使用方法吧~ 毕竟set感觉并不是那么太常见（灵活使用的大大们请无视这句^_^）// erasing from multiset#include <iostream>#include <set>int main (){  std::multiset<int> mymultiset;  std::multiset<int>::iterator it;  // insert some values:  mymultiset.insert (40);                            // 40  for (int i=1; i<7; i++) mymultiset.insert(i*10);   // 10 20 30 40 40 50 60  it=mymultiset.begin();  it++;                                              //    ^  mymultiset.erase (it);                             // 10 30 40 40 50 60  mymultiset.erase (40);                             // 10 30 50 60  it=mymultiset.find (50);  mymultiset.erase ( it, mymultiset.end() );         // 10 30  std::cout << "mymultiset contains:";  for (it=mymultiset.begin(); it!=mymultiset.end(); ++it)    std::cout << ' ' << *it;  std::cout << '\n';  return 0;}// set::find#include <iostream>#include <set>int main (){  std::set<int> myset;  std::set<int>::iterator it;  // set some initial values:  for (int i=1; i<=5; i++) myset.insert(i*10);    // set: 10 20 30 40 50  it=myset.find(20);  myset.erase (it);  myset.erase (myset.find(40));  std::cout << "myset contains:";  for (it=myset.begin(); it!=myset.end(); ++it)    std::cout << ' ' << *it;  std::cout << '\n';  return 0;}// set::insert (C++98)#include <iostream>#include <set>int main (){  std::set<int> myset;  std::set<int>::iterator it;  std::pair<std::set<int>::iterator,bool> ret;  // set some initial values:  for (int i=1; i<=5; ++i) myset.insert(i*10);    // set: 10 20 30 40 50  ret = myset.insert(20);               // no new element inserted  if (ret.second==false) it=ret.first;  // "it" now points to element 20  myset.insert (it,25);                 // max efficiency inserting  myset.insert (it,24);                 // max efficiency inserting  myset.insert (it,26);                 // no max efficiency inserting  int myints[]= {5,10,15};              // 10 already in set, not inserted  myset.insert (myints,myints+3);  std::cout << "myset contains:";  for (it=myset.begin(); it!=myset.end(); ++it)    std::cout << ' ' << *it;  std::cout << '\n';  return 0;}说完了函数的使用方法，嘛，就来看看这题的解题Code吧Code：#include <set>#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;#define i insertchar ch;int n,w,h,t;set<int> x,y,*s;set<int>::iterator l,r;multiset<int> lx,ly,*ls;int main(){cin>>w>>h>>n; x.i(0);x.i(w);y.i(0);y.i(h);lx.i(w);ly.i(h);    for (int j=1; j<=n; ++j){cin>>ch>>t;        if (ch=='H') {s=&y; ls=&ly;} else {s=&x; ls=&lx;}s->i(t); l=r=s->find(t); l--; r++; ls->erase(ls->find(*r-*l));ls->i(t-*l);ls->i(*r-t);cout<<(ll)*lx.rbegin() * (ll)*ly.rbegin()<<endl;}return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/44268847	//String 字符串的常见操作        public static void Fun1()        {            string MyStr = " Hello World! ";            //length长度属性            Console.WriteLine(MyStr.Length);            //Substring()截取            Console.WriteLine(MyStr.Substring(0, 5));            //ToCharArray()转换为字符数组            char[] charr = MyStr.ToCharArray();            //ToUpper()转换大写            string UpperStr = MyStr.ToUpper();            Console.WriteLine("转换为大写：" + UpperStr + "\n");            //ToLower()转换小写            Console.WriteLine("转换为小写：" + MyStr.ToLower());            //TrimStart() and TrimEnd() 去掉字符左右边的空格 TrimStart--去掉左边            string LefStr = MyStr.TrimStart();            string RigStr = MyStr.TrimEnd();            Console.WriteLine("左边 " + LefStr + "\n" + "右边 " + RigStr + "\n");            //Replace()替换字符            string ReplaceStr = MyStr.Replace('W', 'M');            Console.WriteLine("替换字符 " + ReplaceStr + "\n");            //Concat()连接字符            string concatStr = string.Concat(MyStr, "asas", "asasa");            Console.WriteLine("连接字符 " + concatStr + "\n");            //IsNullOrEmpty()判断空值            bool NullorEmpty = string.IsNullOrEmpty(MyStr);            Console.WriteLine("判断空值 " + NullorEmpty.ToString() + "\n");            //StartsWith()开头            Console.WriteLine(MyStr.StartsWith(" ") == true);            //EndsWith()结尾            bool endwith = MyStr.EndsWith(" ");            Console.WriteLine("结尾 " + endwith.ToString() + "\n");            //IndexOf() and LastIndexOf()字符串的位置            string strLocation = "123abc4c56efd";            Console.WriteLine("IndexOf:" + strLocation.IndexOf('1') + "\n");            Console.WriteLine("LastIndexOf:" + strLocation.LastIndexOf('c') + "\n");            //插入字符            Console.WriteLine(MyStr.Insert(2, "W"));            //MyStr.PadLeft();MyStr.PadRight()            //Remove()移除            Console.WriteLine("Remove:" + strLocation.Remove(0, 1) + "\n");            //Format()格式化            string str = string.Format("{0:X4}", 3);            Console.WriteLine(str);            //Compare()和CompareTo() 比较方法            string strA = "File.exe";            string strB = "0";            int numA = string.Compare(strA, strB);            Console.WriteLine("Compare: " + numA.ToString() + "\n");            int numB = strA.CompareTo(strB);            Console.WriteLine("CompareTo: " + numB.ToString());            //比较两个指定的 System.String 对象。            // 返回结果:            // 一个 32 位有符号整数，指示两个比较数之间的词法关系。            //值条件小于零 strA 小于 strB。 零strA 等于 strB。 大于零 strA大于 strB。         }
http://blog.csdn.net/okcd00/article/details/44183037	众所周知，我们常常需要知道所谓的INF值，那个2开头的一串数字代表int型的最大值，虽然很多人都记住了，也有很多人用3f3f3f3f这样的方法来表示，不过自然这种选择：limit.h里的INT_MIN & INT_MAX也常常被大家使用。有时候会看到有人直接int minValue=-INT_MAX这就需要吐槽了，为什么呢，在climit的定义里，它们是这样的#define INT_MAX 2147483647  #define INT_MIN (- INT_MAX - 1) 网上查来的资料是这么说——这里没有简单地将INT_MIN赋值成-2147483647，是因为-2147483648对于编译器而言是个表达式，而2147483648对于32-bit整数是无法表示的，所以经过这个表达式的结果是未定义的。在GCC上直接写-2147483648后，编译器给出了警告，说结果是unsigned。“An integer constant begins with a digit, but has no period or exponent part. It may have a prefix that specifies its base and a suffix that specifies its type.”The problem is that 2147483648 cannot be represented in a signed 32-bit integer, so it becomes either an unsigned long int or a long long int.So we have to resort to a little trickery, and compute -2147483648 as (-2147483647 – 1), which all fit nicely into 32-bit signed integers, and INT_MIN gets the right type and value.这里我解释一下：这样一个程序可能可以帮上忙#include <stdio.h>#include <limits.h>#include <float.h>int main(void){if (-2147483648 > 0)     printf("positive\n");if (-2147483647 - 1 < 0) printf("negative\n");if (INT_MIN == -INT_MIN) printf("equal\n");if (FLT_MIN > 0)         printf("floating\n");return 0;}所以，使用的话就加上头文件climit，然后轻松愉快地用INT_MAX和INT_MIN吧版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/44059081	Problems  #Name  AVitaly and Stringsstandard input/output1 s, 256 MB  x2731BTanya and Postcardstandard input/output2 s, 256 MB  x2749CAnya and Smartphonestandard input/output1 s, 256 MB  x2299DIlya and Escalatorstandard input/output2 s, 256 MB  x1453向来赛完不写解题报告就会时运Down，以后不敢了Q^Q这场比赛是相对较为简单，容易想到思路，适宜冲紫名的一场，但可惜Pretest数据可能弱了些让大家过的太爽了于是FST就多了起来反而掉分现象普及。那么，一个个来看看吧A. Vitaly and Stringstime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputVitaly is a diligent student who never missed a lesson in his five years of studying in the university. He always does his homework on time and passes his exams in time.During the last lesson the teacher has provided two strings s and t to Vitaly. The strings have the same length, they consist of lowercase English letters, string s is lexicographically smaller than string t. Vitaly wondered if there is such string that is lexicographically larger than string s and at the same is lexicographically smaller than string t. This string should also consist of lowercase English letters and have the length equal to the lengths of strings s and t.Let's help Vitaly solve this easy problem!InputThe first line contains string s (1 ≤ |s| ≤ 100), consisting of lowercase English letters. Here, |s| denotes the length of the string.The second line contains string t (|t| = |s|), consisting of lowercase English letters.It is guaranteed that the lengths of strings s and t are the same and string s is lexicographically less than string t.OutputIf the string that meets the given requirements doesn't exist, print a single string "No such string" (without the quotes).If such string exists, print it. If there are multiple valid strings, you may print any of them.Sample test(s)inputacoutputbinputaaazzzoutputkkkinputabcdefgabcdefhoutputNo such stringNoteString s = s1s2... sn is said to be lexicographically smaller than t = t1t2... tn, if there exists such i, that s1 = t1, s2 = t2, ... si - 1 = ti - 1, si < ti.简单来说，给了两个字符串，问他们之间存在字典序夹在二者之间的字符串嘛？有的话随便输出一个，没有的话输出“No such string”，题目中已经告知了s一定字典序小于t，那么s的最后一位加一看看是不是和t一样不就行了嘛？一样就是不存在，不一样就输出咯？嘿嘿，有坑哦~ 如果末位是z怎么办，如果末位是两个、三个……n个z怎么办呢？这不是数字可以9变成0然后进位哦~ 对了，我们自己用while写一个类似进位的操作不久好了嘛？Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int main(){string s,t; cin>>s>>t;int l=s.length()-1;while(s[l]=='z'){s[l]='a';l--;}s[l]=s[l]+1;if(s==t) cout<<"No such string";else cout<<s;return 0;}B. Tanya and Postcardtime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputLittle Tanya decided to present her dad a postcard on his Birthday. She has already created a message — string s of length n, consisting of uppercase and lowercase English letters. Tanya can't write yet, so she found a newspaper and decided to cut out the letters and glue them into the postcard to achieve string s. The newspaper contains string t, consisting of uppercase and lowercase English letters. We know that the length of string t greater or equal to the length of the string s.The newspaper may possibly have too few of some letters needed to make the text and too many of some other letters. That's why Tanya wants to cut some n letters out of the newspaper and make a message of length exactly n, so that it looked as much as possible like s. If the letter in some position has correct value and correct letter case (in the string s and in the string that Tanya will make), then she shouts joyfully "YAY!", and if the letter in the given position has only the correct value but it is in the wrong case, then the girl says "WHOOPS".Tanya wants to make such message that lets her shout "YAY!" as much as possible. If there are multiple ways to do this, then her second priority is to maximize the number of times she says "WHOOPS". Your task is to help Tanya make the message.InputThe first line contains line s (1 ≤ |s| ≤ 2·105), consisting of uppercase and lowercase English letters — the text of Tanya's message.The second line contains line t (|s| ≤ |t| ≤ 2·105), consisting of uppercase and lowercase English letters — the text written in the newspaper.Here |a| means the length of the string a.OutputPrint two integers separated by a space:the first number is the number of times Tanya shouts "YAY!" while making the message,the second number is the number of times Tanya says "WHOOPS" while making the message.Sample test(s)inputAbCDCbAoutput3 0inputABCabcoutput0 3inputabacabaAbaCaBAoutput3 4说有一个小盆友他在报纸上剪下字来拼一个明信片，如果和自己想的字符一样而且大小写也一样了她就说“YAY”，如果字符一样大小写不一样她就说“Whoops”要求YAY最多的情况中Whoops最多时的两者数量。简单的说，给定两个字符串，问在第二个字符串中有多少个a中的严格区分大小写字符，排除掉这些字符后不严格区分大小写的有多少个。因为字符串不长，可以暴力枚举。先读一遍s得知需要哪些东西（这里想想我当时为啥hash呢，map简直轻松愉快呀，读者可以试试使用map<char,int> mp，然后mp[a]++这样的操作，会比起数组hash来惬意的多），然后在t中找，严格区分大小写的数完记得减掉，然后再找一次不区分大小写的，输出两个数字即可。Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int cntl[26]={0},cntu[26]={0};//cntint nedl[26]={0},nedu[26]={0};//needint main(){int yay=0,whoops=0;string s,t; cin>>s>>t;for(int i=0;i<s.length();i++){if(isupper(s[i])) nedu[s[i]-'A']++;else nedl[s[i]-'a']++;}for(int i=0;i<t.length();i++){if(isupper(t[i])) cntu[t[i]-'A']++;else cntl[t[i]-'a']++;}for(int i=0;i<26;i++){if(nedl[i]!=0 && cntl[i]!=0){int p=min(nedl[i],cntl[i]);nedl[i]-=p,cntl[i]-=p,yay+=p;}if(nedu[i]!=0 && cntu[i]!=0){int p=min(nedu[i],cntu[i]);nedu[i]-=p,cntu[i]-=p,yay+=p;}}for(int i=0;i<26;i++){if(nedl[i]!=0 && cntu[i]!=0){int p=min(nedl[i],cntu[i]);nedl[i]-=p,cntu[i]-=p,whoops+=p;}if(nedu[i]!=0 && cntl[i]!=0){int p=min(nedu[i],cntl[i]);nedu[i]-=p,cntl[i]-=p,whoops+=p;}}cout<<yay<<' '<<whoops<<endl;return 0;}C. Anya and Smartphonetime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputAnya has bought a new smartphone that uses Berdroid operating system. The smartphone menu has exactly n applications, each application has its own icon. The icons are located on different screens, one screen contains k icons. The icons from the first to the k-th one are located on the first screen, from the (k + 1)-th to the 2k-th ones are on the second screen and so on (the last screen may be partially empty).Initially the smartphone menu is showing the screen number 1. To launch the application with the icon located on the screen t, Anya needs to make the following gestures: first she scrolls to the required screen number t, by making t - 1 gestures (if the icon is on the screen t), and then make another gesture — press the icon of the required application exactly once to launch it.After the application is launched, the menu returns to the first screen. That is, to launch the next application you need to scroll through the menu again starting from the screen number 1.All applications are numbered from 1 to n. We know a certain order in which the icons of the applications are located in the menu at the beginning, but it changes as long as you use the operating system. Berdroid is intelligent system, so it changes the order of the icons by moving the more frequently used icons to the beginning of the list. Formally, right after an application is launched, Berdroid swaps the application icon and the icon of a preceding application (that is, the icon of an application on the position that is smaller by one in the order of menu). The preceding icon may possibly be located on the adjacent screen. The only exception is when the icon of the launched application already occupies the first place, in this case the icon arrangement doesn't change.Anya has planned the order in which she will launch applications. How many gestures should Anya make to launch the applications in the planned order?Note that one application may be launched multiple times.InputThe first line of the input contains three numbers n, m, k (1 ≤ n, m, k ≤ 105) — the number of applications that Anya has on her smartphone, the number of applications that will be launched and the number of icons that are located on the same screen.The next line contains n integers, permutation a1, a2, ..., an — the initial order of icons from left to right in the menu (from the first to the last one), ai —  is the id of the application, whose icon goes i-th in the menu. Each integer from 1 to n occurs exactly once among ai.The third line contains m integers b1, b2, ..., bm(1 ≤ bi ≤ n) — the ids of the launched applications in the planned order. One application may be launched multiple times.OutputPrint a single number — the number of gestures that Anya needs to make to launch all the applications in the desired order.Sample test(s)input8 3 31 2 3 4 5 6 7 87 8 1output7input5 4 23 1 5 2 44 4 4 4output8NoteIn the first test the initial configuration looks like (123)(456)(78), that is, the first screen contains icons of applications 1, 2, 3, the second screen contains icons 4, 5, 6, the third screen contains icons 7, 8.After application 7 is launched, we get the new arrangement of the icons — (123)(457)(68). To launch it Anya makes 3gestures.After application 8 is launched, we get configuration (123)(457)(86). To launch it Anya makes 3 gestures.After application 1 is launched, the arrangement of icons in the menu doesn't change. To launch it Anya makes 1 gesture.In total, Anya makes 7 gestures.说有个智能手机，上面有n个APP，我要点其中的m个，每页最多可以放k个APP。当我每次点击一个APP的时候，如果这个APP不在第一位，那么他就和他前面的一个APP调换位置，问我们按照顺序点击那m个APP要做多少个手势（滑动到下一页要一个手势，点击是一个手势，每点击一个APP出来都回到第一页）点击某个APP需要的手势的个数其实就是(pos/k)+(pos%k==0?0:1)，即这个APP当前所在的位置除以每页最多放置的APP数，向上取整，因为我们需要滑动（当前所在页数-1）+点击1次=当前所在页数。然后就是每次点击要前移一位的实现了：if(pos>1){int t=fdnum[pos-1];fdnum[pos-1]=now;fdpos[now]=pos-1;fdnum[pos]=t;fdpos[t]=pos;}我用的方法是：数组1：每个位置对应当前位置的APP编号，数组2：每个APP编号当前所在的位置，然后借助临时变量t进行swap操作。当然别忘了他就在第一页的时候不用和前一个调换位置哦。然后，坑来了——孩子们永远是那句话……int不是好东西啊，LL大法好啊，动不动int就溢出了烦不烦呢！明明就前300可以紫名了你就是不开心溢出让我FST，叹气……Code：#include <map>#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}map<int,int> fdpos,fdnum; //num->pos & pos->numint main(){fdpos.clear();fdnum.clear();long long ans=0; // LL大法好……int n,m,k;cin>>n>>m>>k;for(int i=1;i<=n;i++){int now;scanf("%d",&now);fdpos[now]=i;fdnum[i]=now;}for(int i=1;i<=m;i++){int now;scanf("%d",&now);int pos=fdpos[now];ans+=(pos/k)+(pos%k==0?0:1);//swapif(pos>1){int t=fdnum[pos-1];fdnum[pos-1]=now;fdpos[now]=pos-1;fdnum[pos]=t;fdpos[t]=pos;}}cout<<ans;return 0;}D. Ilya and Escalatortime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputIlya got tired of sports programming, left university and got a job in the subway. He was given the task to determine the escalator load factor.Let's assume that n people stand in the queue for the escalator. At each second one of the two following possibilities takes place: either the first person in the queue enters the escalator with probability p, or the first person in the queue doesn't move with probability (1 - p), paralyzed by his fear of escalators and making the whole queue wait behind him.Formally speaking, the i-th person in the queue cannot enter the escalator until people with indices from 1 to i - 1 inclusive enter it. In one second only one person can enter the escalator. The escalator is infinite, so if a person enters it, he never leaves it, that is he will be standing on the escalator at any following second. Ilya needs to count the expected value of the number of people standing on the escalator after t seconds.Your task is to help him solve this complicated task.InputThe first line of the input contains three numbers n, p, t (1 ≤ n, t ≤ 2000, 0 ≤ p ≤ 1). Numbers n and t are integers, number pis real, given with exactly two digits after the decimal point.OutputPrint a single real number — the expected number of people who will be standing on the escalator after t seconds. The absolute or relative error mustn't exceed 10 - 6.Sample test(s)input1 0.50 1output0.5input1 0.50 4output0.9375input4 0.20 2output0.4没错这就是个DP……啊对了题意啊题意……有个无限长的电梯，有n个人一列纵队在排队上电梯，每个人只能在前头都没人了的时候才能上电梯，每秒钟，有p的概率排在第一的人上了电梯，问：t秒后，电梯上人数的数学期望……数学你好……概率学啦……用dp[i][j]来表示当i个人排队时在第t秒电梯上人数的数学期望。那么我们知道dp[i][j]应该等于当[（i-1个人，j-1秒）时的期望+1] * p （这个人上去了）加上 当[（i个人，j-1秒）时的期望 * (1-p) （这个人没上去）具体的看看代码吧Code：#include<bits/stdc++.h>double dp[2005][2005];int main(){int n,t,i;double p;scanf("%d%lf%d",&n,&p,&t);for(i=1;i<=n;i++){for(int j=1;j<=t;j++)dp[i][j]=(p*(1+dp[i-1][j-1])+(1-p)*(dp[i][j-1]));}printf("%.6lf",dp[n][t]);return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/43907889	  #Name  AChewbaсca and Numberstandard input/output1 s, 256 MB  x3704BHan Solo and Lazer Gunstandard input/output1 s, 256 MB  x2790CWatto and Mechanismstandard input/output3 s, 256 MB  x895DR2D2 and Droid Armystandard input/output2 s, 256 MB  x744这次在C题上纠结的有点多了浪费了不少时间……Codeforces Round #291 (Div. 2)A. Chewbaсca and Numbertime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputLuke Skywalker gave Chewbacca an integer number x. Chewbacca isn't good at numbers but he loves inverting digits in them. Inverting digit t means replacing it with digit 9 - t.Help Chewbacca to transform the initial number x to the minimum possible positive number by inverting some (possibly, zero) digits. The decimal representation of the final number shouldn't start with a zero.InputThe first line contains a single integer x (1 ≤ x ≤ 1018) — the number that Luke Skywalker gave to Chewbacca.OutputPrint the minimum possible positive number that Chewbacca can obtain after inverting some digits. The number shouldn't contain leading zeroes.Sample test(s)input27output22input4545output4444关于这道题我只想说“哈哈哈哈哈哈我居然WA了4次哈哈哈哈…… ”其实读题真的是很重要的事情，The number shouldn't contain leading zeroes 意思是，数字不含前导零…… 没看见……题意是说，给你一个数字，你可以将其中任意数位的数字变成（9-当前数字），需要获得一个最小的数（但是不含前导零！）。所以基本上就是一个把大于等于5的都变成9和当前数字的差，然后注意首位如果是0请改成9，即可…… 叹气，不审题害死人呐Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int main(){string s;cin>>s;for(int i=0;i<s.length();i++){int now=s[i]-'0';if(i==0 && (now==0 || now==9)) cout<<9;else cout<<Min(now,9-now);}return 0;}B. Han Solo and Lazer Guntime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputThere are n Imperial stormtroopers on the field. The battle field is a plane with Cartesian coordinate system. Each stormtrooper is associated with his coordinates (x, y) on this plane.Han Solo has the newest duplex lazer gun to fight these stormtroopers. It is situated at the point (x0, y0). In one shot it can can destroy all the stormtroopers, situated on some line that crosses point (x0, y0).Your task is to determine what minimum number of shots Han Solo needs to defeat all the stormtroopers.The gun is the newest invention, it shoots very quickly and even after a very large number of shots the stormtroopers don't have enough time to realize what's happening and change their location.InputThe first line contains three integers n, x0 и y0 (1 ≤ n ≤ 1000,  - 104 ≤ x0, y0 ≤ 104) — the number of stormtroopers on the battle field and the coordinates of your gun.Next n lines contain two integers each xi, yi ( - 104 ≤ xi, yi ≤ 104) — the coordinates of the stormtroopers on the battlefield. It is guaranteed that no stormtrooper stands at the same point with the gun. Multiple stormtroopers can stand at the same point.OutputPrint a single integer — the minimum number of shots Han Solo needs to destroy all the stormtroopers.Sample test(s)input4 0 01 12 22 0-1 -1output2input2 1 21 11 0output1NoteExplanation to the first and second samples from the statement, respectively:这道题比起A对于参赛者而言倒是最简单AC的一个，告诉你雷射炮的坐标和敌人的坐标，问你多少枪能把他们全干掉。题意解析的话大概是这么个情况，从炮台坐标开始画多少条直线能穿透所有已知点。再优化一下就相对坐标系一下，就是把炮台所在点视为原点，那么斜率相同的（没有斜率的也互相称作相同）即为在同一次攻击内被干掉。一旦有除法要考虑精度浮点数判断相等的时候就很头疼，于是我用了分数表示斜率的方法，用map存一个<int,int>来代表 n/m 这样一个分数的斜率，化为最简分数即可。我的这种方法需要考虑到的为以下问题：1、 其中有一个为0的时候，因为0和非0数组成的分数，要么就是无斜率的0分母斜率，要么就是求最大公约数没办法把各种分之0化为相同的。于是一旦遇到一个为0，另一个为非0，我们就把他变成 0/1 和 1/0 的形式存即可。2、 都为0的时候，您是不是怎么打都会死……3、 这里我用的是map，很棒的STL，如果有不懂的可以这么理解，map是一个数组，但是下标可以为任何的东西，此处我用的下表是点对，就是分数。m[make_pair(a,b)]就是下标为<a,b>的意思。Code：#include <map>#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int x[1001]={0};int y[1001]={0};map<pair<int,int>,int> m;int main(){int n;cin>>n;cin>>x[0]>>y[0];for(int ni=1;ni<=n;ni++) {scanf("%d%d",&x[ni],&y[ni]);x[ni]=x[ni]-x[0],y[ni]=y[ni]-y[0];int g=__gcd(x[ni],y[ni]);if(g==0) g=Max(x[ni],y[ni]);m[make_pair(x[ni]/g,y[ni]/g)]++;}cout<<m.size();return 0;}C. Watto and Mechanismtime limit per test3 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputWatto, the owner of a spare parts store, has recently got an order for the mechanism that can process strings in a certain way. Initially the memory of the mechanism is filled with n strings. Then the mechanism should be able to process queries of the following type: "Given string s, determine if the memory of the mechanism contains string t that consists of the same number of characters as s and differs from s in exactly one position".Watto has already compiled the mechanism, all that's left is to write a program for it and check it on the data consisting of n initial lines and m queries. He decided to entrust this job to you.InputThe first line contains two non-negative numbers n and m (0 ≤ n ≤ 3·105, 0 ≤ m ≤ 3·105) — the number of the initial strings and the number of queries, respectively.Next follow n non-empty strings that are uploaded to the memory of the mechanism.Next follow m non-empty strings that are the queries to the mechanism.The total length of lines in the input doesn't exceed 6·105. Each line consists only of letters 'a', 'b','c'.OutputFor each query print on a single line "YES" (without the quotes), if the memory of the mechanism contains the required string, otherwise print "NO" (without the quotes).Sample test(s)input2 3aaaaaacacacaaabaaccacacccaaacoutputYESNONO题意的话是在说，先给你n个字符串，然后进行m次询问，每次询问一个字符串，问之前给出的n个字符串内有没有字符串可以在刚好改动一个字母的情况下获得当前字符串。这道题，出题人给的解题方法是Hash，我个人原先的想法是字典树建一棵树，每次询问从root开始向下找目标节点，有一次非相同机会，如果找不到已有节点则使用，并在当前节点bfs，但这种方法有问题，比如在某节点其实应该认作不同，但字典树中刚好有另一个字符串的此位置有这个字母，就这辈子都找不到了……果然不能这样。那么Hash应该怎么做呢？解题报告是这么说的：While adding a string to the set, let's count its polynomial hash and add it to an array. Then let's sort this array. Now, to know the query answer, let's try to change every symbol in the string and check with binary search if its hash can be found in the array (recounting hashes with O(1) complexity). If the hash is found in the array, the answer is "YES", otherwise "NO".简单的说，hash，排序，询问的字符串每个字母都变，找hash是否存在。overCode：#include <bits/stdc++.h>typedef long long int lnt;typedef double dou;using namespace std;#define N 600514int nx[N*2][3],spt;int newnode(){for(int i=0;i<3;i++)nx[spt][i]=0;return spt++;}void add(char*s,int p,int*st,int&top){top=0;st[top++]=p;for(int i=0;s[i];i++){int a=s[i]-'a';if(nx[p][a]==0)nx[p][a]=newnode();p=nx[p][a];st[top++]=p;}}set<pair<int,int> >mp[3];int n,m;char s[N];int r1,r2;int st1[N],t1;int st2[N],t2;int solve(){if(scanf("%d %d",&n,&m)==EOF)return 0;spt=1;r1=newnode();r2=newnode();for(int i=0;i<n;i++){scanf("%s",s);add(s,r1,st1,t1);int l=0;for(;s[l];l++);for(int j=0;j+j<l;j++)swap(s[j],s[l-1-j]);add(s,r2,st2,t2);for(int j=0;j<t1-1;j++){//printf("%d %d %d\n",st1[j],st2[t1-2-j],s[j]-'a');mp[s[l-1-j]-'a'].insert(pair<int,int>(st1[j],st2[t1-2-j]));}}////////////////////for(int i=0;i<m;i++){scanf("%s",s);add(s,r1,st1,t1);int l=0;for(;s[l];l++);for(int j=0;j+j<l;j++)swap(s[j],s[l-1-j]);add(s,r2,st2,t2);int flag=0;for(int j=0;j<t1-1;j++){int a=s[l-1-j]-'a';//printf("(%d %d %d)\n",st1[j],st2[t1-2-j],a);if(a!=0&&mp[0].find(pair<int,int>(st1[j],st2[t1-2-j]))!=mp[0].end()){flag=1;break;}if(a!=1&&mp[1].find(pair<int,int>(st1[j],st2[t1-2-j]))!=mp[1].end()){flag=1;break;}if(a!=2&&mp[2].find(pair<int,int>(st1[j],st2[t1-2-j]))!=mp[2].end()){flag=1;break;}}puts(flag?"YES":"NO");}mp[0].clear();mp[1].clear();mp[2].clear();return 1;}int main(){while(solve());return 0;}字典树的话其实也是行得通的，建立字典树进行dfs即可（我比赛的时候为啥要用bfs……哭）Code：#include<bits/stdc++.h>const int maxnode=6e5+100;const int sigma_size=3;using namespace std;int n,m;int ch[maxnode][sigma_size],val[maxnode];int sz;void init(){    memset(ch,0,sizeof ch);    memset(val,0,sizeof(val));    sz=1;}void insert(char *s){    int u=0,l=strlen(s);    for(int i=0; i<l; ++i) {        int c=s[i]-'a';        if(!ch[u][c]) {            ch[u][c]=sz++;        }        u=ch[u][c];    }    val[u]=1;}char s[maxnode];bool dfs(char *s,int rt,int p,int d,int l){    if(d>1) return false;    if(p==l){        if(d==1&&val[rt]) return true;        return false;    }    for(int i=0;i<sigma_size;++i){        if(ch[rt][i]){            if(dfs(s,ch[rt][i],p+1,d+(i!=s[p]-'a'),l)) return true;        }    }    return false;}int main(){    init();    scanf("%d%d",&n,&m);    for(int i=0; i<n; ++i) {        scanf("%s",s);        insert(s);    }    for(int i=0; i<m; ++i) {        scanf("%s",s);        if(dfs(s,0,0,0,strlen(s))) printf("YES\n");        else printf("NO\n");    }    return 0;}D. R2D2 and Droid Armytime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputAn army of n droids is lined up in one row. Each droid is described by m integers a1, a2, ..., am, where aiis the number of details of the i-th type in this droid's mechanism. R2-D2 wants to destroy the sequence of consecutive droids of maximum length. He has m weapons, the i-th weapon can affect all the droids in the army by destroying one detail of the i-th type (if the droid doesn't have details of this type, nothing happens to it).A droid is considered to be destroyed when all of its details are destroyed. R2-D2 can make at most kshots. How many shots from the weapon of what type should R2-D2 make to destroy the sequence of consecutive droids of maximum length?InputThe first line contains three integers n, m, k (1 ≤ n ≤ 105, 1 ≤ m ≤ 5, 0 ≤ k ≤ 109) — the number of droids, the number of detail types and the number of available shots, respectively.Next n lines follow describing the droids. Each line contains m integers a1, a2, ..., am (0 ≤ ai ≤ 108), where ai is the number of details of the i-th type for the respective robot.OutputPrint m space-separated integers, where the i-th number is the number of shots from the weapon of the i-th type that the robot should make to destroy the subsequence of consecutive droids of the maximum length.If there are multiple optimal solutions, print any of them.It is not necessary to make exactly k shots, the number of shots can be less.Sample test(s)input5 2 44 01 22 10 21 3output2 2input3 2 41 21 32 2output1 3NoteIn the first test the second, third and fourth droids will be destroyed.In the second test the first and second droids will be destroyed.关于D……没来的及看，当时卡C太狠了，但是似乎是个队列的问题，先存个代码和解题报告备看To destroy all the droids on a segment of l to r, we need to make sum_m(Max_r cnt[i][j])  shots, where cnt[i][j] — number of j-type details in i-th droid. Let's support two pointers — on the beginning and on the end of the segment, which we want to destroy all the droids on. If we can destroy droids on current segment, let's increase right border of the segment, otherwise increase left border, updating the answer after every segment change. Let's use a queue in order to find the segment maximum effectively.Code：#include <cstring>#include <vector>#include <map>#include <set>#include <stack>#include <bitset>#include <algorithm>#include <iostream>#include <cstdio>#include <cmath>#include <cstdlib>#define ls rt << 1#define rs rt << 1 | 1#define lson ls, l, m#define rson rs, m + 1, r#define getm int m = (l + r) >> 1#define LL long long#define ULL unsigned long long#define pii pair <LL, LL>using namespace std;const int N = 100005, mod = 1e9 + 7, M = 100;int n, m, k;int q[N][6], a[N][6], r[6], f[6], e[6];inline void inq (int id, int x) {    while (f[id] <= e[id] && a[x][id] >= a[q[e[id]][id]][id]) e[id]--;    q[++e[id]][id] = x;}inline void outq (int id, int x) {    if (q[f[id]][id] <= x) f[id]++;}inline int jug () {    int sum = 0;    for (int i = 1; i <= m; i++) {        sum += a[q[f[i]][i]][i];    }    return sum > k;}inline int read() {    int x=0; char ch=getchar();    while(ch<'0'||ch>'9'){ch=getchar();}    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}    return x;}int main () {//    freopen ("in.txt", "r", stdin);    cin >> n >> m >> k;    for (int i = 1; i <= n; i++) {        for (int j = 1; j <= m; j++) {            a[i][j] = read ();        }    }    for (int i = 1; i <= m; i++) f[i] = 0, e[i] = -1;    int res = 0;    int pre = 1;    for (int i = 1; i <= n; i++) {        for (int j = 1; j <= m; j++) {            inq (j, i);        }        while (pre <= i && jug ()) {            for (int j = 1; j <= m; j++) outq(j, pre);            pre++;        }        if (res < i - pre + 1) {            res = i - pre + 1;            for (int j = 1; j <= m; j++) r[j] = a[q[f[j]][j]][j];        }    }    for (int i = 1; i <= m; i++) {        cout << r[i] << ' ';    }}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/43907861	A. String Tasktime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputPetya started to attend programming lessons. On the first lesson his task was to write a simple program. The program was supposed to do the following: in the given string, consisting if uppercase and lowercase Latin letters, it:deletes all the vowels,inserts a character "." before each consonant,replaces all uppercase consonants with corresponding lowercase ones.Vowels are letters "A", "O", "Y", "E", "U", "I", and the rest are consonants. The program's input is exactly one string, it should return the output as a single string, resulting after the program's processing the initial string.Help Petya cope with this easy task.InputThe first line represents input string of Petya's program. This string only consists of uppercase and lowercase Latin letters and its length is from 1 to 100, inclusive.OutputPrint the resulting string. It is guaranteed that this string is not empty.Sample test(s)inputtouroutput.t.rinputCodeforcesoutput.c.d.f.r.c.sinputaBAcAbaoutput.b.c.b题意是说给一个字符串，要求输出一个序列，只包含原字符串的非元音字母的小写形式，每个字母输出前要加一个点首先处理大小写，我们直接把源字符串变成全小写的就好，tolower(char a)函数返回的就是当前字母的小写形式，然后我们判断一下这个字母是否元音字母，不是的话我们就输出点和这个字母即可Code：#include <cstdio>#include <string>#include <cstring> #include <iostream>#include <algorithm>using namespace std;typedef long long ll;// http://codeforces.com/contest/118// String Taskbool judge(char c){if(c=='a'||c=='e'||c=='i'||c=='o'||c=='u'||c=='y')return false;return true;}int main(){string s;cin>>s;for(int i=0;i<s.length();i++){char now=tolower(s[i]);if(judge(now))cout<<'.'<<now;} return 0;} 版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/43737069	欢迎使用Markdown编辑器写博客[本文章用以测试新博客编辑器]本Markdown编辑器使用StackEdit修改而来，用它写博客，将会带来全新的体验哦：Markdown和扩展Markdown简洁的语法代码块高亮图片链接和图片上传LaTex数学公式UML序列图和流程图离线写博客导入导出Markdown文件丰富的快捷键快捷键加粗    Ctrl + B 斜体    Ctrl + I 引用    Ctrl + Q插入链接    Ctrl + L插入代码    Ctrl + K插入图片    Ctrl + G提升标题    Ctrl + H有序列表    Ctrl + O无序列表    Ctrl + U横线    Ctrl + R撤销    Ctrl + Z重做    Ctrl + YMarkdown及扩展Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    ——  [ 维基百科 ]使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接等，详细语法参考帮助？。本编辑器支持 Markdown Extra , 　扩展了很多好用的功能。具体请参考Github.  表格Markdown　Extra　表格语法：项目价格Computer$1600Phone$12Pipe$1可以使用冒号来定义对齐方式：项目价格数量Computer1600 元5Phone12 元12Pipe1 元234定义列表Markdown　Extra　定义列表语法：项目１项目２定义 A定义 B项目３定义 C定义 D定义D内容代码块代码块语法遵循标准markdown代码，例如：@requires_authorizationdef somefunc(param1='', param2=0):    '''A docstring'''    if param1 > param2: # interesting        print 'Greater'    return (param2 - param1 + 1) or Noneclass SomeClass:    pass>>> message = '''interpreter... prompt'''脚注生成一个脚注1.目录用 [TOC]来生成目录：欢迎使用Markdown编辑器写博客快捷键Markdown及扩展表格定义列表代码块脚注目录数学公式UML 图离线写博客浏览器兼容数学公式使用MathJax渲染LaTex 数学公式，详见math.stackexchange.com.行内公式，数学公式为：Γ(n)=(n−1)!∀n∈N\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N。块级公式：x=−b±b2−4ac−−−−−−−√2ax = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} 更多LaTex语法请参考 这儿.UML 图:可以渲染序列图：Created with Raphaël 2.1.2张三张三李四李四嘿，小四儿, 写博客了没?李四愣了一下，说：忙得吐血，哪有时间写。或者流程图：Created with Raphaël 2.1.2开始我的操作确认？结束yesno关于 序列图 语法，参考 这儿,关于 流程图 语法，参考 这儿.离线写博客即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入write.blog.csdn.net/mdeditor即可。Markdown编辑器使用浏览器离线存储将内容保存在本地。用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。博客发表后，本地缓存将被删除。　用户可以选择  把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。注意：虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，请务必及时发表或者保存到服务器草稿箱。浏览器兼容目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。IE９以下不支持IE９，１０，１１存在以下问题 不支持离线功能IE9不支持文件导入导出IE10不支持拖拽文件导入这里是 脚注 的 内容. ↩            $(function () {                $('pre.prettyprint code').each(function () {                    var lines = $(this).text().split('\n').length;                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();                    $(this).addClass('has-numbering').parent().append($numbering);                    for (i = 1; i <= lines; i++) {                        $numbering.append($('<li/>').text(i));                    };                    $numbering.fadeIn(1700);                });            });        
http://blog.csdn.net/okcd00/article/details/43234049	Problems  #Name  APasha and Pixelsstandard input/output2 s, 256 MB  x3234BAnton and currency you all knowstandard input/output0.5 s, 256 MB  x2848CAnya and Ghostsstandard input/output2 s, 256 MB  x1671这次出了前三题，原为第三位的Avator加了100来分变成第二了，这下终于三个ID都1650+了，可喜可贺，希望能多撑几天吧……A. Pasha and Pixelstime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputPasha loves his phone and also putting his hair up... But the hair is now irrelevant.Pasha has installed a new game to his phone. The goal of the game is following. There is a rectangular field consisting of n row with mpixels in each row. Initially, all the pixels are colored white. In one move, Pasha can choose any pixel and color it black. In particular, he can choose the pixel that is already black, then after the boy's move the pixel does not change, that is, it remains black. Pasha loses the game when a 2 × 2 square consisting of black pixels is formed.Pasha has made a plan of k moves, according to which he will paint pixels. Each turn in his plan is represented as a pair of numbers iand j, denoting respectively the row and the column of the pixel to be colored on the current move.Determine whether Pasha loses if he acts in accordance with his plan, and if he does, on what move the 2 × 2 square consisting of black pixels is formed.InputThe first line of the input contains three integers n, m, k (1 ≤ n, m ≤ 1000, 1 ≤ k ≤ 105) — the number of rows, the number of columns and the number of moves that Pasha is going to perform.The next k lines contain Pasha's moves in the order he makes them. Each line contains two integers i and j (1 ≤ i ≤ n, 1 ≤ j ≤ m), representing the row number and column number of the pixel that was painted during a move.OutputIf Pasha loses, print the number of the move when the 2 × 2 square consisting of black pixels is formed.If Pasha doesn't lose, that is, no 2 × 2 square consisting of black pixels is formed during the given k moves, print 0.Sample test(s)input2 2 41 11 22 12 2output4input2 3 62 32 21 32 21 21 1output5input5 3 72 31 21 14 13 15 33 2output0给你一个n*m的棋盘，每次你走到的格子都会被涂黑，接下来有k步，每一步都告诉你我这步走的是哪一个格子（Row/Col坐标），要求输出在第几步时第一次出现了2X2的黑色正方形，如果走完了都没出现，则输出0。看了看数据范围，似乎……模拟完全无压呢我们就真的给一个棋盘，每走一步我们就把这个格子 mp[a][b]=1 标记一下，然后找左上右上左下右下，这四个2X2的正方形是不是全黑，是的话输出然后return，不是的话就继续咯~Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int mp[1002][1002]={0};bool judge(int r,int c){if(mp[r-1][c]==1){if(mp[r][c-1]==1){if(mp[r-1][c-1]==1)return true;}if(mp[r][c+1]==1){if(mp[r-1][c+1]==1)return true;}}if(mp[r+1][c]==1){if(mp[r][c-1]==1){if(mp[r+1][c-1]==1)return true;}if(mp[r][c+1]==1){if(mp[r+1][c+1]==1)return true;}}return false;}int main(){int n,m,k;cin>>n>>m>>k;for(int i=1;i<=k;i++){int r,c;scanf("%d%d",&r,&c);mp[r][c]=1;if(judge(r,c)){cout<<i;return 0;} }cout<<0;return 0;}B. Anton and currency you all knowtime limit per test0.5 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputBerland, 2016. The exchange rate of currency you all know against the burle has increased so much that to simplify the calculations, its fractional part was neglected and the exchange rate is now assumed to be an integer.Reliable sources have informed the financier Anton of some information about the exchange rate of currency you all know against the burle for tomorrow. Now Anton knows that tomorrow the exchange rate will be an even number, which can be obtained from the present rate by swapping exactly two distinct digits in it. Of all the possible values that meet these conditions, the exchange rate for tomorrow will be the maximum possible. It is guaranteed that today the exchange rate is an odd positive integer n. Help Anton to determine the exchange rate of currency you all know for tomorrow!InputThe first line contains an odd positive integer n — the exchange rate of currency you all know for today. The length of number n's representation is within range from 2 to 105, inclusive. The representation of n doesn't contain any leading zeroes.OutputIf the information about tomorrow's exchange rate is inconsistent, that is, there is no integer that meets the condition, print  - 1.Otherwise, print the exchange rate of currency you all know against the burle for tomorrow. This should be the maximum possible number of those that are even and that are obtained from today's exchange rate by swapping exactly two digits. Exchange rate representation should not contain leading zeroes.Sample test(s)input527output572input4573output3574input1357997531output-1给一个很长的数字，至少两位数，最多10的五次方位的一个奇数，让你调换其中两个数位，将其变为可变的各种选择中最大的偶数并输出，如果做不到则输出-1。很显然，最后一位决定了奇偶，所以调换的两位中确定了一位是末位，然后，做不到的意思就是数字中没有偶数数字，特例排除后我们来考虑如何最大。因为数字太大，所以我们不能直接加减甚至无法记录最大值，但是我们在纸上写一写就能发现，很明显调换后与调换前的差一定是一个 A99999...999B 的数，而AB作为一个两位数来看就是两个调换位调换前后的两位数的差，即 10*B+A-10*A-B=9*(B-A) ，连9我们都不必要了…… 我们就简单的通过正负（zf）、9的个数（digit）和差值（sub）来记录就可以啦~ 话说我为啥要把正负提出来！！！ 直接正负和差值用一个int不就可以了么！我真傻……真的……Code：#include <map>#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}string s;string ans;int zf,digit,sub;int tzf,td,ts,len; //temp zf,dig,submap<int,int> m;void update(int pos){zf=tzf;digit=td;sub=ts;ans=s;char temp=ans[pos];ans[pos]=ans[len-1];ans[len-1]=temp;}int main(){m.clear();cin>>s;len=s.length();int tail=s[len-1]-'0';for(int i=0;i<len;i++){int num=s[i]-'0';if(num%2==0) m[i]=num;}if(m.empty()){cout<<-1;return 0;}zf=-1,digit=100001,sub=99;tzf=0,td=0,ts=0; //temp zf,dig,subfor (map<int,int>::iterator it=m.begin(); it!=m.end(); ++it){//cout << it->first << " => " << it->second << '\n';int pos=it->first;int now=s[pos]-'0';tzf=1;ts=tail-now; //*9 略去 td=s.length()-pos;if(ts<0){tzf=-1;ts=-ts;}if(tzf>zf) update(pos);else if(tzf==1 && zf==1){if(td>digit) update(pos);else if(td==digit){if(ts>sub) update(pos);}}else if(tzf==-1 && zf==-1){if(td<digit) update(pos);else if(td==digit){if(ts<sub) update(pos);}}}cout<<ans;return 0;}Another Code:#include<stdio.h>#include<string.h>int n,i,x,minpos=-1;char a[100010],t;int main(){    scanf("%s",a);    n=strlen(a);    for(i=0;i<n-1;i++){        if((a[i]-'0')%2==0){            if(a[n-1]>a[i]){                t = a[n-1] , a[n-1] = a[i] , a[i] = t;                printf("%s\n",a);                return 0;            }            else{                minpos = i;            }        }    }    if(minpos==-1){        printf("-1\n");    }    else{        t = a[n-1] , a[n-1] = a[minpos] , a[minpos] = t;        printf("%s\n",a);        return 0;    }}C. Anya and Ghoststime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputAnya loves to watch horror movies. In the best traditions of horror, she will be visited by m ghosts tonight. Anya has lots of candles prepared for the visits, each candle can produce light for exactly t seconds. It takes the girl one second to light one candle. More formally, Anya can spend one second to light one candle, then this candle burns for exactly t seconds and then goes out and can no longer be used.For each of the m ghosts Anya knows the time at which it comes: the i-th visit will happen wi seconds after midnight, all wi's are distinct. Each visit lasts exactly one second.What is the minimum number of candles Anya should use so that during each visit, at least r candles are burning? Anya can start to light a candle at any time that is integer number of seconds from midnight, possibly, at the time before midnight. That means, she can start to light a candle integer number of seconds before midnight or integer number of seconds after a midnight, or in other words in any integer moment of time.InputThe first line contains three integers m, t, r (1 ≤ m, t, r ≤ 300), representing the number of ghosts to visit Anya, the duration of a candle's burning and the minimum number of candles that should burn during each visit.The next line contains m space-separated numbers wi (1 ≤ i ≤ m, 1 ≤ wi ≤ 300), the i-th of them repesents at what second after the midnight the i-th ghost will come. All wi's are distinct, they follow in the strictly increasing order.OutputIf it is possible to make at least r candles burn during each visit, then print the minimum number of candles that Anya needs to light for that.If that is impossible, print  - 1.Sample test(s)input1 8 310output3input2 10 15 8output1input1 1 310output-1NoteAnya can start lighting a candle in the same second with ghost visit. But this candle isn't counted as burning at this visit.It takes exactly one second to light up a candle and only after that second this candle is considered burning; it means that if Anya starts lighting candle at moment x, candle is buring from second x + 1 to second x + t inclusively.In the first sample test three candles are enough. For example, Anya can start lighting them at the 3-rd, 5-th and 7-th seconds after the midnight.In the second sample test one candle is enough. For example, Anya can start lighting it one second before the midnight.In the third sample test the answer is  - 1, since during each second at most one candle can burn but Anya needs three candles to light up the room at the moment when the ghost comes.安娜是个小姑娘，有m只鬼晚上要来安娜家（鬼登门拜访的时间以升序给出），小姑娘每秒钟可以点燃1根蜡烛，蜡烛可以燃烧t秒，每只鬼到她家的时候她家需要有至少r根蜡烛在燃烧，问最少用多少根蜡烛可以渡过难关。首先我们需要考虑“-1”即做不到，是什么情况，每秒都在点蜡烛但是在任何一秒都无法实现同时有r根蜡烛在亮着，那么，m<r时就放弃吧，输出-1。当m>=r时，我们在任一根蜡烛燃烧的最后一秒时点燃一根蜡烛，蜡烛熄灭的同时新蜡烛燃烧第一秒，就可以达成延续r根蜡烛的状态。首先，第一只鬼来的时候很明显为了不浪费蜡烛的持续时间，我们从鬼来的前一秒点燃开始向前推，前1秒到前r秒都在点蜡烛，这时在第一个鬼来的时候刚好r根蜡烛而且他们总剩余燃烧时间最大，什么你问我如果鬼第一秒就来了怎么点？仔细看题：That means, she can start to light a candle integer number of seconds before midnight or integer number of seconds after a midnight, or in other words in any integer moment of time.然后我们用lgt（light）数组来记录每一秒的当前亮度是多少，为了得知某根蜡烛啥时候灭，我们在点燃的时候就在lgt[当前秒数+t]处赋值-1，这样dp推到那里的时候就会自动减一达到减少的效果了，我们从第一秒开始推，当遇到鬼了我们要看现在光够不够，不够的话从前一秒开始向前补蜡烛，然后一路向后，最终蜡烛数必然是最小，也算是一个贪心dp的感觉吧Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int vit[666]={0};int lgt[666]={0};//degree of lightint main(){int c=0;int m,t,r;cin>>m>>t>>r;if(t<r) {cout<<-1;return 0;}for(int i=1;i<=m;i++)scanf("%d",&vit[i]);int now=1;for(int i=1;i<=300;i++){lgt[i]+=lgt[i-1];if(i==vit[now]){if(lgt[i]!=r){int dec=r-lgt[i];c+=dec;for(int vt=i+t;i+t-vt<dec;vt--){//cout<<"decing..."<<endl;lgt[vt]--;}lgt[i]=r;}now++;}//cout<<"lgt["<<i<<"]:"<<lgt[i]<<endl;} cout<<c;return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/43292133	A. Elevatortime limit per test3 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputAnd now the numerous qualifying tournaments for one of the most prestigious Russian contests Russian Codec Cup are over. All nparticipants who have made it to the finals found themselves in a huge m-floored 108-star hotel. Of course the first thought to come in a place like this is "How about checking out the elevator?".The hotel's elevator moves between floors according to one never changing scheme. Initially (at the moment of time 0) the elevator is located on the 1-st floor, then it moves to the 2-nd floor, then — to the 3-rd floor and so on until it reaches the m-th floor. After that the elevator moves to floor m - 1, then to floor m - 2, and so on until it reaches the first floor. This process is repeated infinitely. We know that the elevator has infinite capacity; we also know that on every floor people get on the elevator immediately. Moving between the floors takes a unit of time.For each of the n participant you are given si, which represents the floor where the i-th participant starts, fi, which represents the floor the i-th participant wants to reach, and ti, which represents the time when the i-th participant starts on the floor si.For each participant print the minimum time of his/her arrival to the floor fi.If the elevator stops on the floor si at the time ti, then the i-th participant can enter the elevator immediately. If the participant starts on the floor si and that's the floor he wanted to reach initially (si = fi), then the time of arrival to the floor fi for this participant is considered equal to ti.InputThe first line contains two space-separated integers n and m (1 ≤ n ≤ 105, 2 ≤ m ≤ 108).Next n lines contain information about the participants in the form of three space-separated integers si fi ti (1 ≤ si, fi ≤ m, 0 ≤ ti ≤ 108), described in the problem statement.OutputPrint n lines each containing one integer — the time of the arrival for each participant to the required floor.Sample test(s)input7 42 4 31 2 02 2 01 2 14 3 51 2 24 2 0output91071075input5 51 5 41 3 11 3 43 1 54 2 5output12101087NoteLet's consider the first sample. The first participant starts at floor s = 2 by the time equal to t = 3. To get to the floor f = 4, he has to wait until the time equals 7, that's the time when the elevator will go upwards for the second time. Then the first participant should get on the elevator and go two floors up. In this case the first participant gets to the floor f at time equal to 9. The second participant starts at the time t = 0 on the floor s = 1, enters the elevator immediately, and arrives to the floor f = 2. The third participant doesn't wait for the elevator, because he needs to arrive to the same floor where he starts.一句话：哇塞题目好长！话说我这个专题可以作为……A题缩句者~有一栋m层高的大楼，有一个电梯是从一楼开始，一层一层向上，到顶之后一层一层下降，这样循环往复的过程。有n个人他们要搭电梯，每个人有3个参数： s是这个人的出发层，f是这个人的目标层，t是指这个人从t时刻开始在电梯口等待，问：输出每一个人到达目的地时的到达时间。需要注意的是，电梯从底到顶是m-1次移动，所以一个往复是2*m-2，当一个人错过了当前这轮电梯的时候他将只有等待下一班的到来，结合生活实际就会容易理解一些。闲着没事干代码也缩了个句……Code：#include <iostream>#include <algorithm>using namespace std;typedef long long ll;// http://codeforces.com/contest/117// Elevatorint main(){    int n,m,s,f,t;    scanf("%d%d",&n,&m);    for(m=m*2-2; n--; printf("%d\n",s^f?(t+m-(s>f?m+2-s:s))/m*m+(s>f?m+2-f:f)-1:t))    scanf("%d%d%d",&s,&f,&t);    return 0;}那个for是不是过分了点…… 异或的意思就是不等啦，据说计算起来比较快……帮大家扩个句哦：while(n--){if(s!=f){if(s>f)cout<<(t+m-(m+2-s))/m*m + (m+2-f) -1 <<endl;else cout<<(t+m-s)/m*m +f-1<<endl;}else cout<<t<<endl;}当然替换前需要把m=m*2-2写在前头哦。为了便于理解，再放一个别人的写的比较分开的代码，可能会更加清晰明朗一些吧：Code By MK3@Codeforces#include <iostream>using namespace std;int main(){   int n,m;  int p,s,f,t,x;   cin >> n >> m; p=(m-1)*2;   while(n--)  {    cin >> s >> f >> t;     if(s==f) cout << t << endl;     else    {      x = t / p*p + (s<f ? s-1 : 2*m-1-s);       cout << (x<t ? x+p : x) + (f>s ? f-s : s-f) << endl;     }  }  return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/43291849	A. Tramtime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputLinear Kingdom has exactly one tram line. It has n stops, numbered from 1 to n in the order of tram's movement. At the i-th stop aipassengers exit the tram, while bi passengers enter it. The tram is empty before it arrives at the first stop. Also, when the tram arrives at the last stop, all passengers exit so that it becomes empty.Your task is to calculate the tram's minimum capacity such that the number of people inside the tram at any time never exceeds this capacity. Note that at each stop all exiting passengers exit before any entering passenger enters the tram.InputThe first line contains a single number n (2 ≤ n ≤ 1000) — the number of the tram's stops.Then n lines follow, each contains two integers ai and bi (0 ≤ ai, bi ≤ 1000) — the number of passengers that exits the tram at the i-th stop, and the number of passengers that enter the tram at the i-th stop. The stops are given from the first to the last stop in the order of tram's movement.The number of people who exit at a given stop does not exceed the total number of people in the tram immediately before it arrives at the stop. More formally, . This particularly means that a1 = 0.At the last stop, all the passengers exit the tram and it becomes empty. More formally, .No passenger will enter the train at the last stop. That is, bn = 0.OutputPrint a single integer denoting the minimum possible capacity of the tram (0 is allowed).Sample test(s)input40 32 54 24 0output6NoteFor the first example, a capacity of 6 is sufficient:At the first stop, the number of passengers inside the tram before arriving is 0. Then, 3 passengers enter the tram, and the number of passengers inside the tram becomes 3.At the second stop, 2 passengers exit the tram (1 passenger remains inside). Then, 5 passengers enter the tram. There are 6 passengers inside the tram now.At the third stop, 4 passengers exit the tram (2 passengers remain inside). Then, 2 passengers enter the tram. There are 4 passengers inside the tram now.Finally, all the remaining passengers inside the tram exit the tram at the last stop. There are no passenger inside the tram now, which is in line with the constraints.Since the number of passengers inside the tram never exceeds 6, a capacity of 6 is sufficient. Furthermore it is not possible for the tram to have a capacity less than 6. Hence, 6 is the correct answer.最近这些题目啊真是读起来神烦神烦的，那么长的题目可讨厌了，等一读完每次的感想都是——这么点事情你用这么多字闹哪样啊啊啊！Tram就是有轨电车，可以理解为新干线，题目的意思就是告诉你有n个站，每个站上车几个人下车几个人（注意是先下后上），问：车上最多的时候有几个人…… 用maxValue简称maxv(麦克斯韦23333)来记忆一下最高值即可Code：#include <cstdio>#include <string>#include <cstring> #include <iostream>#include <algorithm>using namespace std;typedef long long ll;// http://codeforces.com/contest/116// Tramint main(){int maxv=0,a=0,b=0,now=0,n=0;cin>>n;for(int i=0;i<n;i++){cin>>a>>b;now=now-a+b;maxv=max(maxv,now);}cout<<maxv;return 0;} 版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/43233603	AMr. Kitayuta's Giftstandard input/output1 s, 256 MB  x2396BMr. Kitayuta's Colorful Graphstandard input/output1 s, 256 MB  x1618CMr. Kitayuta, the Treasure Hunterstandard input/output1 s, 256 MB  x456A. Mr. Kitayuta's Gifttime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputMr. Kitayuta has kindly given you a string s consisting of lowercase English letters. You are asked to insert exactly one lowercase English letter into s to make it a palindrome. A palindrome is a string that reads the same forward and backward. For example, "noon", "testset" and "a" are all palindromes, while "test" and "kitayuta" are not.You can choose any lowercase English letter, and insert it to any position of s, possibly to the beginning or the end of s. You have to insert a letter even if the given string is already a palindrome.If it is possible to insert one lowercase English letter into s so that the resulting string will be a palindrome, print the string after the insertion. Otherwise, print "NA" (without quotes, case-sensitive). In case there is more than one palindrome that can be obtained, you are allowed to print any of them.InputThe only line of the input contains a string s (1 ≤ |s| ≤ 10). Each character in s is a lowercase English letter.OutputIf it is possible to turn s into a palindrome by inserting one lowercase English letter, print the resulting string in a single line. Otherwise, print "NA" (without quotes, case-sensitive). In case there is more than one solution, any of them will be accepted.Sample test(s)inputreviveoutputreviverinputeeoutputeyeinputkitayutaoutputNANoteFor the first sample, insert 'r' to the end of "revive" to obtain a palindrome "reviver".For the second sample, there is more than one solution. For example, "eve" will also be accepted.For the third sample, it is not possible to turn "kitayuta" into a palindrome by just inserting one letter.给一个字符串，必须向里头添加一个字符，问能不能构成一个回文串，能的话输出回文串，不能的话输出NA。我们定义*号为通配符，尝试在0到s.length()的每一个地方放置，每次放置后判断当前字符串是不是回文串（我们定义*号和任何一个字母都称作“相同”），如果当前字符串为回文串，我们把*号变为它对应的那个字母，然后输出当前字符串即可。Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int main(){string s,ans,st="*";cin>>s;int len=s.length();for(int i=0;i<=len;i++){bool f=true;ans=s.substr(0,i)+st+s.substr(i,len-i);for(int j=0;j<=ans.length()/2;j++){if(ans[j]==ans[ans.length()-1-j]) continue;else if(ans[j]=='*') {ans[j]=ans[ans.length()-1-j];continue;}else if(ans[ans.length()-1-j]=='*') {ans[ans.length()-1-j]=ans[j];continue;}else{f=false;break;}} if(f) {cout<<ans;return 0;} } cout<< "NA";return 0;}B. Mr. Kitayuta's Colorful Graphtime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputMr. Kitayuta has just bought an undirected graph consisting of n vertices and m edges. The vertices of the graph are numbered from 1 to n. Each edge, namely edge i, has a color ci, connecting vertex ai and bi.Mr. Kitayuta wants you to process the following q queries.In the i-th query, he gives you two integers — ui and vi.Find the number of the colors that satisfy the following condition: the edges of that color connect vertex ui and vertex vi directly or indirectly.InputThe first line of the input contains space-separated two integers — n and m (2 ≤ n ≤ 100, 1 ≤ m ≤ 100), denoting the number of the vertices and the number of the edges, respectively.The next m lines contain space-separated three integers — ai, bi (1 ≤ ai < bi ≤ n) and ci (1 ≤ ci ≤ m). Note that there can be multiple edges between two vertices. However, there are no multiple edges of the same color between two vertices, that is, if i ≠ j, (ai, bi, ci) ≠ (aj, bj, cj).The next line contains a integer — q (1 ≤ q ≤ 100), denoting the number of the queries.Then follows q lines, containing space-separated two integers — ui and vi (1 ≤ ui, vi ≤ n). It is guaranteed that ui ≠ vi.OutputFor each query, print the answer in a separate line.Sample test(s)input4 51 2 11 2 22 3 12 3 32 4 331 23 41 4output210input5 71 5 12 5 13 5 14 5 11 2 22 3 23 4 251 55 12 51 51 4output11112NoteLet's consider the first sample.The figure above shows the first sample.Vertex 1 and vertex 2 are connected by color 1 and 2.Vertex 3 and vertex 4 are connected by color 3.Vertex 1 and vertex 4 are not connected by any single color.依然是在点之间连好多线问能不能从S到T的问题，只是这道题它的连线有好多种颜色（最多100种），问的是有多少种颜色可以从S到T（指的是如果用1的颜色必须一直用1的颜色的路径）。这道题反正颜色不多，开101个图不就行了嘛~我们定义 map[i][j][k] 为第i种颜色的图中，从j节点到k节点有没有路可以过去。然后……简单的bfs咯~Code：#include <cmath> #include <queue>#include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int n,m,q;int ans[101]={0};int map[101][101][101]={0};int bfs(int j,int u,int v){int vis[101]={0};queue<int> q;while(!q.empty())q.pop();q.push(u);while(!q.empty()){int now=q.front();q.pop();if(now==v) return 1;vis[now]=1;for(int i=0;i<=n;i++){if(map[j][now][i]==1 && vis[i]==0){vis[i]==1;q.push(i);}}}return 0;} int main(){cin>>n>>m;for(int i=0;i<m;i++){int a,b,c;scanf("%d%d%d",&a,&b,&c);map[c][a][b]=1;map[c][b][a]=1;}cin>>q;for(int i=0;i<q;i++){int tu,tv;scanf("%d%d",&tu,&tv);int u=min(tu,tv),v=max(tu,tv);for(int j=1;j<=m;j++){ans[i]+=bfs(j,u,v);}cout<<ans[i]<<endl;} return 0;}C. Mr. Kitayuta, the Treasure Huntertime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputThe Shuseki Islands are an archipelago of 30001 small islands in the Yutampo Sea. The islands are evenly spaced along a line, numbered from 0 to 30000 from the west to the east. These islands are known to contain many treasures. There are n gems in the Shuseki Islands in total, and the i-th gem is located on island pi.Mr. Kitayuta has just arrived at island 0. With his great jumping ability, he will repeatedly perform jumps between islands to the east according to the following process:First, he will jump from island 0 to island d.After that, he will continue jumping according to the following rule. Let l be the length of the previous jump, that is, if his previous jump was from island prev to island cur, let l = cur - prev. He will perform a jump of length l - 1, l or l + 1 to the east. That is, he will jump to island (cur + l - 1), (cur + l) or (cur + l + 1) (if they exist). The length of a jump must be positive, that is, he cannot perform a jump of length 0 when l = 1. If there is no valid destination, he will stop jumping.Mr. Kitayuta will collect the gems on the islands visited during the process. Find the maximum number of gems that he can collect.InputThe first line of the input contains two space-separated integers n and d (1 ≤ n, d ≤ 30000), denoting the number of the gems in the Shuseki Islands and the length of the Mr. Kitayuta's first jump, respectively.The next n lines describe the location of the gems. The i-th of them (1 ≤ i ≤ n) contains a integer pi (d ≤ p1 ≤ p2 ≤ ... ≤ pn ≤ 30000), denoting the number of the island that contains the i-th gem.OutputPrint the maximum number of gems that Mr. Kitayuta can collect.Sample test(s)input4 1010212727output3input8 8919283645556678output6input13 788916171718212324242630output4NoteIn the first sample, the optimal route is 0  →  10 (+1 gem)  →  19  →  27 (+2 gems)  → ...In the second sample, the optimal route is 0  →  8  →  15  →  21 →  28 (+1 gem)  →  36 (+1 gem)  →  45 (+1 gem)  →  55 (+1 gem)  →  66 (+1 gem)  →  78 (+1 gem)  → ...In the third sample, the optimal route is 0  →  7  →  13  →  18 (+1 gem)  →  24 (+2 gems)  →  30 (+1 gem)  → ...有一个数轴，从0到30000，这上面分布着n个宝石（位置在下方数据中表示，分别处于某个给出的点），你的第一步必须走p个单位长度，此后每一步可以选择走p+1或者p或者p-1个单位长度（但是至少为1），问最多可以获得多少个宝石。这道题本来想，阿拉不就是简单的dfs么，然后看到了30000，以及每一步有3种分支……简直是当场吓哭的节奏……就去默默的推dp直至结束。结束之后看别人的AC代码……一口老血喷出来……DFS居然不会TLE么？！！！！ 好吧我胆子太小了……Code：#include <bits/stdc++.h>using namespace std;int gem[99999] = {}, dp[35000][500], d, x;int dfs(int a, int b) {if(dp[a][b] + 1) return dp[a][b];int res = 0, i, v;for(i = -1; i < 2; i++) {v = a + d + b + i;if(v > 30001 | v <= a) continue;res = max(res, dfs(v, b + i));}return dp[a][b] = res + gem[a];}int main() {cin >> x >> d;while(cin >> x)gem[x]++;memset(dp, -1, sizeof dp);cout << dfs(d, 0);return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/43233289	Problems  #Name  AConteststandard input/output1 s, 256 MB  x3271BMisha and Changing Handlesstandard input/output1 s, 256 MB  x2473这一场比赛是在算法考试前日晚上做的，做了一小时然后去吃饭了，姑且只有AB两题……A. Contesttime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputMisha and Vasya participated in a Codeforces contest. Unfortunately, each of them solved only one problem, though successfully submitted it at the first attempt. Misha solved the problem that costs a points and Vasya solved the problem that costs b points. Besides, Misha submitted the problem c minutes after the contest started and Vasya submitted the problem d minutes after the contest started. As you know, on Codeforces the cost of a problem reduces as a round continues. That is, if you submit a problem that costs p points tminutes after the contest started, you get  points.Misha and Vasya are having an argument trying to find out who got more points. Help them to find out the truth.InputThe first line contains four integers a, b, c, d (250 ≤ a, b ≤ 3500, 0 ≤ c, d ≤ 180).It is guaranteed that numbers a and b are divisible by 250 (just like on any real Codeforces round).OutputOutput on a single line:"Misha" (without the quotes), if Misha got more points than Vasya."Vasya" (without the quotes), if Vasya got more points than Misha."Tie" (without the quotes), if both of them got the same number of points.Sample test(s)input500 1000 20 30outputVasyainput1000 1000 1 1outputTieinput1500 1000 176 177outputMisha这题使用了Codeforces上的算分机智，就是某题的得分  ，然后有四个数字，分别是Misha做的题目总分，Vasya做的题目总分，Misha出题时间，Vasya出题时间。 问谁得分高（平局的时候输出Tie）题意理解了之后这就是一个简单的代入计算问题啦~double mp=max(3*a/10 , a-(a/250*c) );double vp=max(3*b/10 , b-(b/250*d) );Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int main(){int a=0,b=0,c=0,d=0;cin>>a>>b>>c>>d;double mp=max(3*a/10 , a-(a/250*c) );double vp=max(3*b/10 , b-(b/250*d) );if(mp>vp) cout<<"Misha";else if(mp<vp) cout<<"Vasya";else cout<<"Tie";return 0;}B. Misha and Changing Handlestime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputMisha hacked the Codeforces site. Then he decided to let all the users change their handles. A user can now change his handle any number of times. But each new handle must not be equal to any handle that is already used or that was used at some point.Misha has a list of handle change requests. After completing the requests he wants to understand the relation between the original and the new handles of the users. Help him to do that.InputThe first line contains integer q (1 ≤ q ≤ 1000), the number of handle change requests.Next q lines contain the descriptions of the requests, one per line.Each query consists of two non-empty strings old and new, separated by a space. The strings consist of lowercase and uppercase Latin letters and digits. Strings old and new are distinct. The lengths of the strings do not exceed 20.The requests are given chronologically. In other words, by the moment of a query there is a single person with handle old, and handlenew is not used and has not been used by anyone.OutputIn the first line output the integer n — the number of users that changed their handles at least once.In the next n lines print the mapping between the old and the new handles of the users. Each of them must contain two strings, old andnew, separated by a space, meaning that before the user had handle old, and after all the requests are completed, his handle is new. You may output lines in any order.Each user who changes the handle must occur exactly once in this description.Sample test(s)input5Misha ILoveCodeforcesVasya PetrovPetrov VasyaPetrov123ILoveCodeforces MikeMirzayanovPetya Ivanovoutput3Petya IvanovMisha MikeMirzayanovVasya VasyaPetrov123这道题说的是Codeforces的更名服务，每个人都可以改名字，经过一系列的改名之后，问最后列出所有人的原始名和最终名的对应关系。我们可以意识到，中间的名字根本没有意义，当A变成B，B变成C的时候等价于A变成C，那么我们就直接记录当前的“原始-现名”关系即可，这里我使用了map，map<string,string>就可以实现 m[A]=B,然后当新的B变成C时更改为m[A]=C即可，这需要对STL中map的理解，当然用struct node也是可以的，题目中放宽要求可以in any order应该就是这个考虑吧，map可以自动把对应关系按照原始名的字典序排序，也是相当便利的事情。Code：#include <map>#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef map<string, string> mss;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int main(){int n=0;cin>>n;mss mp;while(!mp.empty()) mp.clear();for(int i=0;i<n;i++){int flag=1;string a,b;cin>>a>>b;for (map<string,string>::iterator it=mp.begin(); it!=mp.end(); ++it){if(it->second==a){mp[it->first]=b;flag=0;break;}}if(flag) mp[a]=b;}cout<<mp.size()<<endl;for (map<string,string>::iterator it=mp.begin(); it!=mp.end(); ++it){cout << it->first << " " << it->second << endl;}return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/42458325	Linux下一般来说提到界面编程JAVA自然是EclipseC++就大概是Qt了吧那么C呢？ 于是我去学了学UnixC和GTK，先放个可用代码放着吧~啊对了，配环境，没错配环境    sudo apt-get install vim #使用vim来编写代码，当然您可以使用任何自己喜欢的编辑器。 　　sudo apt-get install build-essential #这将安装gcc/g++/gdb/make 等基本编程工具。 　　sudo apt-get install gnome-core-devel #这将安装 libgtk2.0-dev libglib2.0-dev 等开发相关的库文件。 　　sudo apt-get install pkg-config #用于在编译GTK程序时自动找出头文件及库文件位置。 　　sudo apt-get install devhelp #这将安装 devhelp GTK文档查看程序。 　　sudo apt-get install libglib2.0-doc libgtk2.0-doc #这将安装 gtk/glib 的API参考手册及其它帮助文档。 　　sudo apt-get install glade libglade2-dev #这将安装基于GTK的界面构造程序。有的获取不到要去官网下载下来tar.gz自己解压缩安装哦~解压小贴士：tar –xvf file.tar //解压 tar包tar -xzvf file.tar.gz //解压tar.gztar -xjvf file.tar.bz2   //解压 tar.bz2tar –xZvf file.tar.Z   //解压tar.Zunrar e file.rar //解压rarunzip file.zip //解压zip东西都有了之后呢~看看效果？效果看完了咱——就来看看代码研读研读吧~//   UnixC Based on GTK //   Compile Method: #gcc cdr –o cdos.c `pkg-config --cflags --libs gtk+-2.0//   Exec Method: ./cdr// Author :okcd00 @ CSDN_2014#include "cdhd.h" #include <fcntl.h>#include <stdio.h>#include <stdlib.h>#include <signal.h>#include <unistd.h>#include <string.h>#include <dirent.h>#include <gtk/gtk.h>#include <gdk/gdk.h>#include <sys/stat.h>#include <gdk/gdkkeysyms.h>#define DENSITY 100  //No. Density of Graph#define PMAX    100   //No. maxNum of Processenum{NAME_COLUMN,PID_COLUMN,STATUS_COLUMN,CPU_COLUMN,MEMORY_COLUMN,NP_COLUMNS};enum{MOD_COLUMN,DEPEND_COLUMN,NM_COLUMNS};//Declare of GtkWidgetGtkWidget *vbox;GtkWidget *hbox;GtkWidget *label;GtkWidget *frame;GtkWidget *window;GtkWidget *menubar;GtkWidget *notebook;GtkWidget *main_vbox;GtkWidget *mem_label;GtkWidget *swap_label;GtkWidget *info_label;GtkWidget *status_bar;GtkWidget *ptree_view;GtkWidget *mtree_view;GtkWidget *cpu_draw_area;GtkWidget *mem_draw_area;GtkWidget *scrolled_window;GtkWidget *prefresh_button , *pdelete_button; //Refresh & Kill Button// Global Varitiesgint cpu_graph[DENSITY];//CPU Graphic Densitygint mem_graph[DENSITY];//RAM Graphic Densitygdouble rate = 0;//cpu Use_Rategdouble total = 0;        //Curr. No.Processgdouble fuser = 0;//Curr. CPUinfogdouble ftotal = 0;//Curr. CPUtotalgdouble pfuser[PMAX];   //No. MaxProcessGString   *info;GdkPixmap *cgraph = NULL;//pixmap_Pointer_CPUGdkPixmap *mgraph = NULL;//pixmap_Pointer_RAM//OthersGtkAccelGroup *accel_group;GtkListStore *process_store;GtkItemFactory *item_factory;GtkCellRenderer *renderer;//Show each colTitleGtkTreeViewColumn *column;//tree view's No.Column//函数声明void about (GtkWidget *, gpointer);void destroy_window (GtkWidget *, gpointer);void sys_shutdown(GtkWidget *, gpointer);void sys_reboot (GtkWidget *, gpointer);void sys_halt (GtkWidget *, gpointer);void about_author (GtkWidget *, gpointer);gboolean handle_timeout (gpointer data);gboolean load_graph_refresh (GtkWidget *widget);gboolean get_cpu_rate (gpointer data);void create_sys_status_page (void);void create_process_page (void);void create_sys_info_page (void);void get_status_info (void);void get_process_info (GtkListStore *);void get_cpu_info (GString *);void get_os_info (GString *);void draw_cpu_load_graph (void);void draw_mem_load_graph (void);void prefresh_button_clicked (gpointer data);void pdelete_button_clicked (gpointer data);void mrefresh_button_clicked (gpointer data);void mdelete_button_clicked (gpointer data);gboolean cpu_configure_event (GtkWidget *, GdkEventConfigure *, gpointer);gboolean cpu_expose_event (GtkWidget *, GdkEventExpose *, gpointer);gboolean mem_configure_event (GtkWidget *, GdkEventConfigure *, gpointer);gboolean mem_expose_event (GtkWidget *, GdkEventExpose *, gpointer);gchar ABt[]="About us";gchar ABc[]="     __<20125209>Chendian_&_<20125216>Xutianyuan_&_<20125212>Yangyeyu__     ";void show_dialog (gchar *, gchar *);static GtkItemFactoryEntry menu_items[] = {{"/_File", NULL, NULL, 0, "<Branch>"},{"/File/Quit", "<CTRL>Q", destroy_window, 0, "<Item>"},{"/_Option", NULL, NULL, 0, "<Branch>"},{"/Option/Shutdown", "<CTRL>U", sys_shutdown, 0 ,"<Item>"},{"/Option/Reboot", "<CTRL>R", sys_reboot, 0 ,"<Item>"},{"/Option/Halt", "<CTRL>H",  sys_halt, 0 ,"<Item>"},{"/_About",NULL,NULL,0,"<Branch>"},{"/About/AboutUs","<CTRL>B", about, 0, "<Item>"},};static gint nmenu_items = sizeof (menu_items) / sizeof (menu_items[0]);//No.Menuint main (int argc, char **argv){  gtk_set_locale ();//Set LocalEnvir Vars  gtk_init (&argc, &argv);  memset (cpu_graph, 50, sizeof (cpu_graph));//Alloc 50size  memset (mem_graph, 50, sizeof (mem_graph));//Alloc 50size  memset (pfuser, 0 ,sizeof (pfuser));  window = gtk_window_new (GTK_WINDOW_TOPLEVEL);  gtk_window_set_title (GTK_WINDOW (window), "okcd00's Linux System Moniter");//Title  gtk_window_set_default_size (GTK_WINDOW (window), 400, 300);//Default Window_Size  gtk_window_set_resizable (GTK_WINDOW (window), FALSE);//Lock the Window_Size  g_signal_connect(G_OBJECT(window), "destroy",  G_CALLBACK(destroy_window), NULL);  main_vbox =gtk_vbox_new (FALSE, 0);  gtk_widget_show (main_vbox);  gtk_container_add (GTK_CONTAINER (window), main_vbox);  accel_group = gtk_accel_group_new ();  item_factory = gtk_item_factory_new (GTK_TYPE_MENU_BAR,"<main>", accel_group);//Create Menu  gtk_item_factory_create_items (item_factory, nmenu_items,menu_items, NULL);  gtk_window_add_accel_group (GTK_WINDOW (window), accel_group);  menubar = gtk_item_factory_get_widget (item_factory, "<main>");  gtk_widget_show (menubar);  gtk_box_pack_start (GTK_BOX (main_vbox), menubar, FALSE, FALSE, 0);  notebook = gtk_notebook_new ();//New a notebook  gtk_widget_show (notebook);  gtk_box_pack_start (GTK_BOX (main_vbox), notebook, FALSE, FALSE, 0);  status_bar = gtk_statusbar_new ();//New a status_bar  gtk_widget_show (status_bar);  gtk_statusbar_set_has_resize_grip (GTK_STATUSBAR (status_bar),TRUE); //Can be Resized  gtk_box_pack_start (GTK_BOX (main_vbox), status_bar, TRUE, FALSE, 0);  gtk_timeout_add (2000, (GtkFunction)handle_timeout, NULL);  gtk_timeout_add (1000, (GtkFunction)load_graph_refresh, NULL); //graph refresh per second  gtk_timeout_add (1000, (GtkFunction)get_cpu_rate, NULL); //CPUrate refresh per second  create_process_page ();  create_sys_status_page ();  create_sys_info_page ();  gtk_widget_show_all (window);  gtk_main ();  return 0;}void about(GtkWidget *widget, gpointer data){show_dialog(ABt,ABc);}void destroy_window (GtkWidget *widget, gpointer data)//QUIT {gtk_main_quit ();}void sys_shutdown (GtkWidget *widget, gpointer data)//Shotdown{system ("shutdown -r now");}void sys_reboot (GtkWidget *widget, gpointer data)//Restart the PC {system ("reboot");}void sys_halt (GtkWidget *widget, gpointer data)//Halt{system ("halt");}gboolean handle_timeout (gpointer data)//a series of operations by time{  gint page_num;  page_num = gtk_notebook_get_current_page (GTK_NOTEBOOK (notebook));//Get Curr Page  switch (page_num) {case 0:gtk_list_store_clear (process_store);//Clear treeviewget_process_info (process_store);//Re-read Process_infobreak;default:break;}return TRUE;}gboolean load_graph_refresh (GtkWidget *widget){  draw_cpu_load_graph ();  draw_mem_load_graph ();  return TRUE;}gboolean get_cpu_rate ( gpointer data)//Get CPU UseRate {  int fd,i;  gchar buffer[256];  gchar *cpu_time[9];  gchar *tmp;  gchar *delim =  " ";  gdouble cuser;  gdouble ctotal;  fd = open ("/proc/stat", O_RDONLY);//ReadFile  read (fd, buffer, sizeof (buffer));  close (fd);  tmp = strstr (buffer, "cpu0");//Buffer ended with "cpu0"  tmp--;  *tmp = '\0';  cpu_time[0] = strtok (buffer, delim);//split  for (i = 1; i < 9 ; i++)  cpu_time[i] = strtok (NULL, delim);  cuser = atoi (cpu_time[1]);//Change str to long  ctotal = (cuser + atoi (cpu_time[2]) + atoi (cpu_time[3]) + atoi (cpu_time[4]));  total = ctotal - ftotal;  rate = (cuser - fuser) / total;  fuser = cuser;  ftotal = ctotal;  return TRUE;}void create_sys_status_page ()//create_sys_status_page{  vbox = gtk_vbox_new (FALSE, 0);//Create colBox  gtk_widget_show (vbox);  gtk_container_add (GTK_CONTAINER (notebook), vbox);//Add it!  frame = gtk_frame_new ("CPU");//CreateFrame  gtk_widget_show (frame);  gtk_box_pack_start (GTK_BOX (vbox), frame, FALSE, FALSE, 0);//Add it!  cpu_draw_area = gtk_drawing_area_new ();//Add DrawPad  gtk_widget_show (cpu_draw_area);  gtk_drawing_area_size (GTK_DRAWING_AREA (cpu_draw_area), 400, 100);//Set DrawArea  gtk_container_add (GTK_CONTAINER (frame), cpu_draw_area);  g_signal_connect (cpu_draw_area, "expose_event",  G_CALLBACK (cpu_expose_event), NULL);  g_signal_connect (cpu_draw_area, "configure_event",  G_CALLBACK (cpu_configure_event), NULL);  frame = gtk_frame_new ("Memory");//CreateFrame  gtk_widget_show (frame);  gtk_box_pack_start (GTK_BOX (vbox), frame, FALSE, FALSE, 10);    mem_draw_area = gtk_drawing_area_new ();  gtk_widget_show (mem_draw_area);  gtk_drawing_area_size (GTK_DRAWING_AREA (mem_draw_area), 400, 100);//Set DrawArea  gtk_container_add (GTK_CONTAINER (frame), mem_draw_area);  g_signal_connect (mem_draw_area, "expose_event",  G_CALLBACK (mem_expose_event), NULL);  g_signal_connect (mem_draw_area, "configure_event",  G_CALLBACK (mem_configure_event), NULL);  mem_label = gtk_label_new ("");//RAM Label  gtk_widget_show (mem_label);  gtk_box_pack_start (GTK_BOX (vbox), mem_label, FALSE, FALSE, 0);  swap_label = gtk_label_new ("");//Exchange Label  gtk_widget_show (swap_label);  gtk_box_pack_start (GTK_BOX (vbox), swap_label, FALSE, FALSE, 10);  label = gtk_label_new ("Status");//Add Title   gtk_widget_show (label);  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook),  gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook), 1), label);}void create_process_page (){  int i;  gchar *col_name[5] = { "NAME", "PID" , "STATUS", "CPU" , "MEMORY"};  vbox = gtk_vbox_new (FALSE, 0);  gtk_widget_show (vbox);  gtk_container_add (GTK_CONTAINER (notebook), vbox);  scrolled_window = gtk_scrolled_window_new (NULL, NULL);  gtk_widget_set_size_request (scrolled_window, 300, 300);  gtk_widget_show (scrolled_window);  gtk_box_pack_start (GTK_BOX (vbox), scrolled_window, TRUE, TRUE, 0);//Process info   process_store = gtk_list_store_new (NP_COLUMNS,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_STRING);  ptree_view = gtk_tree_view_new_with_model (GTK_TREE_MODEL (process_store));  //Add tree_view Show ProcessTree  g_object_unref (G_OBJECT (process_store));  gtk_widget_show (ptree_view);  gtk_container_add (GTK_CONTAINER (scrolled_window), ptree_view);//Tree in scrolled_window  for (i = 0; i < 5; i++) {  renderer = gtk_cell_renderer_text_new ();//Add cell_renderer_text to Show Text  column = gtk_tree_view_column_new_with_attributes (col_name[i],renderer,"text",i,NULL);    gtk_tree_view_append_column (GTK_TREE_VIEW (ptree_view), column);  }  get_process_info (process_store); //Getinfo and show  hbox = gtk_hbox_new (FALSE, 0);//add parreling box  gtk_widget_show (hbox);  gtk_box_pack_start (GTK_BOX (vbox), hbox, TRUE, FALSE, 0);//Add to colBox  prefresh_button = gtk_button_new ();//Create Refresh Button   gtk_widget_show (prefresh_button);  gtk_widget_set_size_request (prefresh_button, 70, 30);//Set Button Size  gtk_button_set_label (GTK_BUTTON (prefresh_button), "refresh");//SetText  g_signal_connect (G_OBJECT (prefresh_button),"clicked",  G_CALLBACK(prefresh_button_clicked),NULL);//Function  gtk_box_pack_start (GTK_BOX (hbox), prefresh_button, TRUE, FALSE, 0);//Add to hBox  pdelete_button = gtk_button_new ();//Create Kill Button  gtk_widget_show (pdelete_button);  gtk_widget_set_size_request (pdelete_button, 70, 30);  gtk_button_set_label (GTK_BUTTON (pdelete_button), "kill");  g_signal_connect (G_OBJECT (pdelete_button),"clicked",  G_CALLBACK(pdelete_button_clicked),NULL);//Func:pdelete_button_clicked  gtk_box_pack_start (GTK_BOX (hbox), pdelete_button, TRUE, FALSE, 0);//Add to hBox  label = gtk_label_new ("Processes");  gtk_widget_show (label);  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook),  gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook), 0), label);}void create_sys_info_page (void)//Add Page{  vbox = gtk_vbox_new (FALSE, 0);  gtk_widget_show (vbox);  gtk_container_add (GTK_CONTAINER(notebook), vbox);  frame = gtk_frame_new ("CPU Information:");  gtk_widget_show (frame);  gtk_box_pack_start (GTK_BOX (vbox), frame, TRUE, TRUE, 10);  info = g_string_new ("");  get_cpu_info (info);//info: Save CPUinfo  info_label = gtk_label_new (info->str);//info_label Show infoString  gtk_widget_show (info_label);  gtk_container_add (GTK_CONTAINER(frame), info_label);  frame = gtk_frame_new ("OS Information:");  gtk_widget_show (frame);  gtk_box_pack_start (GTK_BOX (vbox), frame, TRUE, TRUE, 30);  info = g_string_new ("");  get_os_info (info);//info: Save CPUinfo  info_label = gtk_label_new (info->str);//info_label Show infoString  gtk_widget_show (info_label);  gtk_container_add (GTK_CONTAINER(frame), info_label);  label = gtk_label_new ("SysInfo");  gtk_widget_show (label);  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook),  gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook),2), label);}//IMPORTANT <MOST> 2014.12.28 void get_process_info (GtkListStore *store){  DIR *dir;  int fd, i,num = 0;   GtkTreeIter iter;  struct dirent *entry;  gdouble mem;  gdouble srate;  gdouble pcuser[PMAX];  gchar *info[26];  gchar buffer[128];  gchar dir_buf[256];  gchar *delim = " ";  gchar mem_buffer[16];  gchar rate_buffer[16];  gchar state[2][10]={"running", "sleeping"};  dir = opendir ("/proc");// Open/proc, dir: pointer to Return  while ((entry = readdir (dir)) != NULL ) {if ((entry->d_name[0] >= '0') && (entry->d_name[0] <= '9')) {sprintf (dir_buf, "/proc/%s/stat", entry->d_name);//ReadFilefd = open (dir_buf, O_RDONLY);read (fd, buffer, sizeof (buffer));close (fd);info[0] =  strtok (buffer, delim);//Delim splitfor (i = 1; i < 26 ; i++) info[i] = strtok (NULL, delim);info[1]++;info[1] = strtok(info[1], ")");switch(info[2][0]){    case 'R': info[2] = state[0];break;    case 'S': info[2] = state[1];break;}pcuser[num] = atoi (info[13]);srate = (pcuser[num]-pfuser[num]) / (2 * total);//Percent Calc                if(srate<0||srate>1){srate=0;}sprintf (rate_buffer, "%.2f%%",100 * srate);mem = atoi (info[22]);//Process' Using Percentmem = mem / (1024 * 1024);sprintf (mem_buffer, "%-.2f MB",mem);gtk_list_store_append (store, &iter);gtk_list_store_set (store, &iter,NAME_COLUMN,info[1],PID_COLUMN,info[0],STATUS_COLUMN,info[2],CPU_COLUMN,rate_buffer,MEMORY_COLUMN,mem_buffer,-1);pfuser[num] = pcuser[num];  num = (num + 1 ) % PMAX;}}  closedir (dir);}void get_cpu_info(GString *string){  int i=0,j=0;  FILE *file=NULL;  gchar buffer[120];  gchar cpu_info[3][88];  gchar *tmp = NULL;    file = fopen("/proc/cpuinfo", "r");    while(!feof(file))    {        fgets(buffer, 120, file);        if(tmp = strstr(buffer, "model name"))        {            tmp+=13;            sprintf(cpu_info[i], "CPU %d:\t%s", i++, tmp);        }    }    fclose(file);    while(j<i) g_string_append (string, cpu_info[j++]);    return;}void get_os_info (GString *string)//Get OSinfo{int fd,i;      gchar buffer[128];      gchar *tmp,*start,*stop;gchar *os_info[8];gchar *delim = " ";fd = open ("/proc/version", O_RDONLY);//Read OS infoFileread(fd, buffer, sizeof (buffer));start = buffer;stop = strstr (buffer, "#");stop--;stop--;os_info[0] = strtok (buffer, delim);for (i = 1; i < 8; i++) {os_info[i] = strtok (NULL, delim);}g_string_append (string, "Os\t\t\t\t:");g_string_append (string, os_info[0]);g_string_append_c (string, '\n');g_string_append (string, "Release\t\t:");    g_string_append (string, os_info[2]);    g_string_append_c (string, '\n');    g_string_append (string, "Domain\t\t:");    g_string_append (string, os_info[3]);  g_string_append_c (string, '\n');    g_string_append (string, "Gcc version\t:");  g_string_append (string, os_info[6]);g_string_append_c (string, ' ');    g_string_append (string, os_info[7]);    g_string_append_c (string, '\n');}void draw_cpu_load_graph (){    if (cgraph == NULL)        return;   int i;   gchar buffer[64];   gint width,height,current,step;   guint context_id;   sprintf (buffer, "CPU using rate:%.2f%%",100 * rate);   context_id = gtk_statusbar_get_context_id (GTK_STATUSBAR (status_bar),"cpu");   gtk_statusbar_push (GTK_STATUSBAR (status_bar), context_id, buffer);   //Clear PastGraph   gdk_draw_rectangle (GDK_DRAWABLE (cgraph), window->style->white_gc, TRUE, 0, 0,  cpu_draw_area->allocation.width,  cpu_draw_area->allocation.height);   width = cpu_draw_area->allocation.width;//Get Size   height = cpu_draw_area->allocation.height;   current = (int)(rate*(double)height);//Adjust Height   cpu_graph[DENSITY-1] = height - current;  //Move Direction   for ( i = 0 ; i < DENSITY - 1 ; i ++) {  cpu_graph[i] = cpu_graph[i+1];   }   step = width/DENSITY;//stepsets    GdkGC *gc = gdk_gc_new(GDK_DRAWABLE(cgraph));    GdkColor color;    gdk_color_parse("#FFFF00", &color);    gdk_gc_set_foreground(gc, &color);   for (i = DENSITY - 1; i >= 1 ; i -- ) { gdk_draw_line (cgraph, gc, i * step, cpu_graph[i], (i - 1) * step, cpu_graph[i-1]  );   }   gtk_widget_queue_draw (cpu_draw_area);//ReDraw}void draw_mem_load_graph (){  if (mgraph == NULL) return;  int fd,i;  gint width,height,current,step;  gint mem_total,mem_free;  gchar buffer[540];  gchar mem_tmp[19][20];  gchar *start,*stop,*tmp;  GString *string;  fd = open ("/proc/meminfo", O_RDONLY);  read (fd, buffer, sizeof (buffer));  stop = buffer;  close(fd);  for (i = 0; i < 19; i++)   {  start = strstr (stop, ":");  start++;  stop = strstr (start, "kB");  stop--;  tmp = mem_tmp[i];  while (start != stop) *tmp++ = *start++;  *tmp = '\0';  }  mem_total = atoi (mem_tmp[0]);  mem_free = atoi (mem_tmp[1]);  string = g_string_new ("");//Refresh info_Num  g_string_append (string, "Total Memory :");  g_string_append (string, mem_tmp[0]);  g_string_append (string, " kB");  g_string_append (string, "   ");  g_string_append (string, "Free Memory  :");  g_string_append (string, mem_tmp[1]);  g_string_append (string, " kB");  g_string_append_c (string, '\n');  gtk_label_set_text (GTK_LABEL (mem_label), string->str);  g_string_free (string, TRUE);  string = g_string_new ("");  g_string_append (string, "Total Swap   :");  g_string_append (string, mem_tmp[11]);  g_string_append (string, " kB");  g_string_append (string, "   ");  g_string_append (string, "Free Swap    :");  g_string_append (string, mem_tmp[12]);  g_string_append (string, " kB");  g_string_append_c (string, '\n');  gtk_label_set_text (GTK_LABEL (swap_label), string->str);  g_string_free (string, TRUE);   //ClearGraph  gdk_draw_rectangle (mgraph, window->style->white_gc, TRUE, 0, 0,  mem_draw_area->allocation.width,  mem_draw_area->allocation.height);  width = mem_draw_area->allocation.width;//GetSize  height = mem_draw_area->allocation.height;  current = ((float)(mem_total-mem_free)/(float)mem_total) * height;//Adjust Size  mem_graph[DENSITY-1] = height - current; //Move Dir   for ( i = 0 ; i < DENSITY - 1 ; i ++) {  mem_graph[i] = mem_graph[i+1];  }  step = width / DENSITY;    GdkGC *gc = gdk_gc_new(GDK_DRAWABLE(mgraph));    GdkColor color;    gdk_color_parse("#0000EE", &color);    gdk_gc_set_foreground(gc, &color);  for (i = DENSITY - 1; i >= 1 ; i -- ) {  gdk_draw_line (mgraph, gc, i * step,    mem_graph[i], (i - 1) * step, mem_graph[i-1]);  }  gtk_widget_queue_draw ( mem_draw_area);}void prefresh_button_clicked (gpointer data){  gtk_list_store_clear (process_store);  get_process_info (process_store);}void pdelete_button_clicked (gpointer data){  GtkTreeSelection *selection;  GtkTreeModel *model;  GtkTreeIter iter;  gchar *pid;  pid_t pid_num;  selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(ptree_view));//Get Selection  if (gtk_tree_selection_get_selected(selection, &model, &iter)) {gtk_tree_model_get (model, &iter, PID_COLUMN, &pid, -1);//Get PID  pid_num = atoi (pid);    if(kill (pid_num, SIGTERM) == -1 ) {gchar *title = "ERROR";gchar *content = "Termination Failed,Check UID";show_dialog (title, content);}    gtk_list_store_clear (process_store);    get_process_info (process_store);  }}gboolean cpu_configure_event (GtkWidget *widget, GdkEventConfigure *event, gpointer data){  if (cgraph) {  g_object_unref (cgraph);  }   //Pixmap Create  cgraph = gdk_pixmap_new (widget->window,  widget->allocation.width, widget->allocation.height,-1);  //RePaint in Pixmap  gdk_draw_rectangle (cgraph, widget->style->white_gc, TRUE, 0, 0,widget->allocation.width, widget->allocation.height);  return TRUE;}gboolean cpu_expose_event (GtkWidget *widget, GdkEventExpose *event, gpointer data){  gdk_draw_drawable (widget->window,widget->style->fg_gc[GTK_WIDGET_STATE (widget)],     cgraph,     event->area.x, event->area.y,     event->area.x, event->area.y,      event->area.width, event->area.height);  return TRUE;}//Graph Refreshinggboolean mem_configure_event (GtkWidget *widget, GdkEventConfigure *event, gpointer data){  if (mgraph) {  g_object_unref (mgraph);  }  mgraph = gdk_pixmap_new (widget->window,  widget->allocation.width, widget->allocation.height,-1);  gdk_draw_rectangle (mgraph, widget->style->white_gc, TRUE, 0, 0,widget->allocation.width, widget->allocation.height);  return TRUE;}gboolean mem_expose_event (GtkWidget *widget, GdkEventExpose *event, gpointer data){  gdk_draw_drawable (widget->window,widget->style->fg_gc[GTK_WIDGET_STATE (widget)],     mgraph,     event->area.x, event->area.y,     event->area.x, event->area.y,      event->area.width, event->area.height);  return TRUE;}void show_dialog (gchar *title, gchar *content){GtkWidget *dialog;GtkWidget *label;    dialog = gtk_dialog_new_with_buttons (title,                                         GTK_WINDOW (window),                                         GTK_DIALOG_DESTROY_WITH_PARENT,                                         GTK_STOCK_CLOSE,                                         GTK_RESPONSE_NONE,                                         NULL);gtk_window_set_resizable (GTK_WINDOW (dialog), FALSE);g_signal_connect_swapped (dialog,                             "response",                             G_CALLBACK (gtk_widget_destroy),                             dialog);label = gtk_label_new (content);gtk_widget_show (label);gtk_container_add (GTK_CONTAINER (GTK_DIALOG(dialog)->vbox),                      label);gtk_widget_show (dialog);}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/42090851	学了TCP协议，尝试着做了一个单文件的协议信息传输模拟，物理层传输使用的是共享文件传输。代码如下：#include <cmath> #include <dos.h>#include <time.h> #include <cctype>#include <cstdio>#include <string>#include <fstream>#include <cstdlib>#include <cstring>#include <iostream>#include <windows.h>#include <algorithm>using namespace std;//物理层0/1 //数据链路层译帧//网络层路由信息（MAC&Protocol） //传输层IP报头 （IP.addr） //应用层 ICMP信息（Division） //自然语言Original Message #define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))//Globalconst string ipfrom="192.168.191.001";const string ipto="192.168.191.002";const string protocal="tcp";const string macfrom="00-50-56-C0-00-01";const string macto="07-25-25-C0-D0-00";int buffer[7]={0};bool cmp(const int a, const int b){return a > b;}char getasc(char cc[7]){int c[7]={0};for(int i=0;i<7;i++){c[i]=cc[i]-'0';cout<<"C"<<i<<"="<<c[i]<<endl;}char temp='A'-65+c[6]+2*c[5]+4*c[4]+8*c[3]          +16*c[2]+32*c[1]+64*c[0];return temp;}void print01(int an){int t=an;int cmpt=64;while(cmpt){if(t>=cmpt){printf("1");t-=cmpt;}else printf("0"); cmpt/=2;}}void sen(){string mes;cout<<"Please Input Your Message(No blanks):";cin>>mes;cout<<"==Message Submitted!=="<<endl;string icmp="mail";string l1="icmp_head="+icmp+"$"+mes;cout<<"【应用层】:"<<endl;for(int i=0;i<l1.length();i++)cout<<l1[i];cout<<endl; string l2="trans_head="+ipfrom+"<:>"+ipto+"$"+l1;cout<<"【传输层】:"<<endl;for(int i=0;i<l2.length();i++)cout<<l2[i];cout<<endl; string l3="netw_head="+macfrom+"<"+protocal+">"+macto+"$"+l2;cout<<"【网络层】:"<<endl;for(int i=0;i<l3.length();i++)cout<<l3[i];cout<<endl; //数据链路层东西有点太多了，稍微偷个懒就只加一个ArrivalTime好了……time_t timer;struct tm* tblock;timer=time(NULL);tblock=localtime(&timer);string asct=asctime(tblock);//Mon Dec 22 22:52:30 2014string l4="static_head="+asct+"$"+l3;cout<<"【数据链路层】:"<<endl;for(int i=0;i<l4.length();i++)cout<<l4[i];cout<<endl; cout<<"【物理层开始0/1处理】"<<endl;freopen("Trans.txt","w",stdout);for(int i=0;i<l4.length();i++){int ascnum=l4[i]-'A'+65;print01(ascnum);}fclose(stdout);cout<<"【物理层0/1处理完成】"<<endl;}void rec(){int pos=0;char get[7]={'0'};char tl4[1024];freopen("Trans.txt","r",stdin);while(scanf("%c%c%c%c%c%c%c",&get[0],&get[1],&get[2],       &get[3],&get[4],&get[5],&get[6])!=EOF){system("cls");cout<<"Reading... "<< pos <<"letters."<<endl; char now=getasc(get);tl4[pos++]=now;}tl4[pos]='\0';cout<<"==Reading Operation Over=="<<endl;fclose(stdin);string l4=tl4;cout<<"【数据链路层】:"<<endl;for(int i=0;i<l4.length();i++)cout<<l4[i];cout<<endl;string l3=l4.substr(38,l4.length()-38);cout<<"【网络层】:"<<endl;for(int i=0;i<l3.length();i++)cout<<l3[i];cout<<endl;string l2=l3.substr(50,l3.length()-50);cout<<"【传输层】:"<<endl;for(int i=0;i<l2.length();i++)cout<<l2[i];cout<<endl;string l1=l2.substr(45,l2.length()-45);cout<<"【应用层】:"<<endl;for(int i=0;i<l1.length();i++)cout<<l1[i];cout<<endl;string l0=l1.substr(15,l1.length()-15);cout<<"【信息】:"<<endl;for(int i=0;i<l0.length();i++)cout<<l0[i];cout<<endl;}int main(){cout<<"-------------------------------------"<<endl<<"|  [NetWork_Project1] 五层协议模拟  |"<<endl<<"|  ---Author_Chendian IOT 20125209  |"<<endl<<"-------------------------------------"<<endl;system("pause");system("CLS");cout<<"@ S> Sender"<<endl<<"@ R> Receiver"<<endl;while(1){cout<<"请输入您的角色:"; string choice;cin>>choice;if(tolower(choice[0])=='s'){sen();break;}else if(tolower(choice[0])=='r'){rec();break;}else cout<<"Invalid Input , Please Try again"<<endl;}cout<<("Thanks for using. _Author okcd00");system("pause"); return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/42063531	内存中的进程•内存一部分供操作系统使用（驻留监控程序、内核），一部分供当前活跃的进程使用，用于存放进程需要的数据和程序等。•内存管理最基本的操作是由处理器把程序装入内存中执行。•进程对应的内存空间包含5种不同的数据区：代码段（Text）：代码段是用来存放可执行文件的操作指令，也就是说是它是可执行程序在内存中的镜像。数据段（Data）：数据段存放可执行文件中已初始化全局变量，包括程序静态(static)分配变量和全局变量(global)。BSS段：BSS段包含了程序中未初始化的全局变量和静态变量，在内存中 bss段全部置零。堆（Heap）：堆是用于存放进程运行中被动态分配(malloc)的内存段。    栈（Stack）：栈是用户存放程序临时创建的局部变量。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。在linux环境下编写程序，模拟一个作业的执行过程。•用户输入系统分配给该作业的物理块N，和该作业要访问的逻辑页号序列长度L。•该作业要访问的逻辑页号序列可以用户输入，也可以采用某种策略生成，如随机。•采用下面不同的页面置换算法，并给出不同算法下的页面置换情况及其对应的缺页率。•FIFO--先进先出，置换驻留在内存中时间最长的页。•LRU--最近最少使用，置换内存中上次使用据当前最远的页。•OPT--最佳置换，未来访问据当前时间最长的页。•CLOCK--时钟算法，页框关联使用位。为了好看（我为啥每次都在这种意义不明的事情上那么麻烦……）做了类命令行的操作界面，明明就是个控制台至于么……每个函数和用户友好表达都封装成函数，自认为写起来还是比较清晰明朗的（都划分这么细了了好不好）纯原创，请勿随意转载使用，如需使用请告知或署名okcd00，谢谢。Code:#include <cmath> #include <time.h>#include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <windows.h>#include <iostream>#include <algorithm>using namespace std;int b[16];//blockint mem[256];//memorystring choice;//choice#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))int n,l;bool cmp(const int a, const int b){return a > b;}void sta()//start{cout<<"<Project4> = 20125209 IOT01 Chendian_陈点"<<endl; cout<<"Please input the number of Physic Blocks (Less than 15):";cin>>n;cout<<"Please input the Length of Sequence Length (Less than 255):";cin>>l;}void cus()//custom{cout<<"==Custom Setting=="<<endl;cout<<"Please Input "<<l<<" digits :(split with blank)"<<endl;for(int i=0;i<l;i++){cin>>mem[i];}cout<<"\n Custom_Set Finished"<<endl;}void ran()//random{srand(time(NULL));cout<<"==Random Setting=="<<endl;cout<<"Now Calculating";cout<<endl;for(int i=0;i<l;i++){mem[i]=rand()%8+1;cout<<".";}cout<<"\n Random_Set Finished"<<endl;}void inp()//input{cout<<"Do you want CUSTOM or RANDOM?(c/r):"<<endl;memset(mem,0,sizeof mem);while(1){cin>>choice;if(tolower(choice[0])=='c') {cus();break;}if(tolower(choice[0])=='r') {ran();break;}//7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1cout<<"Invalid Input , Please Try again:";} }void dis()//display{cout<<endl<<"@ FIFO -- 先进先出，置换驻留在内存中时间最长的页"<<endl<<"@ LRU  -- 最近最少使用，置换内存中上次使用据当前最远的页"<<endl<<"@ OPT  -- 最佳置换，未来访问据当前时间最长的页"<<endl<<"@ CLOCK-- 时钟算法，页框关联使用位"<<endl<<"@ Exit -- 退出"<<endl<<"@ Another Sequence -- 更换序列"<<endl<<"Please Select Replacing Algorithm(输入首字母即可):"<<endl;} void fif()//fifo{int pos=0;int cnt=0;memset(b,-1,sizeof b);for(int i=0;i<l;i++){int now=mem[i],f=0;for(int j=0;j<n;j++) if(b[j]==now) { f=1;break;}if(f){for(int j=0;j<n;j++) if(b[j]==-1)printf("# ");else printf("%d ",b[j]);printf("[命中]\t New is %d\n",now);}else{b[pos++]=now;pos=pos%n;cnt++;for(int j=0;j<n;j++) if(b[j]==-1)printf("# ");else printf("%d ",b[j]);printf("[缺页]\t New is %d\n",now);} }cout<<"缺页数:"<<cnt<<endl;cout<<"缺页率:"<<(double)cnt/(double)l *100.0 <<"%"<<endl;}void lru()//lru{int maxdis=-1;int chg=0,cnt=0;int rec[10]={0};//recordint dis[10]={0};//distancememset(b,-1,sizeof b);for(int i=0;i<l;i++){maxdis=-1;int now=mem[i],f=0;for(int j=0;j<n;j++){if(b[j]==now) {f=1;break;}if(b[j]==-1) {chg=j;break;}dis[b[j]]=i-rec[b[j]];//cout<<"dis["<<j<<"]:"<<dis[b[j]]<<endl;if(dis[b[j]]>maxdis)  maxdis=dis[b[j]],chg=j;}if(f){rec[now]=i;for(int j=0;j<n;j++) if(b[j]==-1)printf("# ");else printf("%d ",b[j]);printf("[命中]\t New is %d\n",now);}else{b[chg]=now,cnt++;rec[now]=i;for(int j=0;j<n;j++) if(b[j]==-1)printf("# ");else printf("%d ",b[j]);printf("[缺页]\t New is %d\n",now);} }cout<<"缺页数:"<<cnt<<endl;cout<<"缺页率:"<<(double)cnt/(double)l *100.0 <<"%"<<endl;}void opt()//opt{int maxdis=-1;int cnt=0;int dis[10]={0};//distancememset(b,-1,sizeof b);for(int i=0;i<l;i++){int pos=0;int chg=0;maxdis=-1;int now=mem[i],f=0;for(int j=0;j<n;j++){if(b[j]==now) {f=1;break;}if(b[j]==-1) {chg=j;break;}dis[b[j]]=0;for(int k=i+1;k<l;k++){if(mem[k]==b[j]){dis[b[j]]=k-i;break;}}//cout<<"dis["<<j<<"]:"<<dis[b[j]]<<endl;if(dis[b[j]]>maxdis)  maxdis=dis[b[j]],chg=j;}if(f){for(int j=0;j<n;j++) if(b[j]==-1)printf("# ");else printf("%d ",b[j]);printf("[命中]\t New is %d\n",now);}else{b[chg]=now,cnt++;for(int j=0;j<n;j++) if(b[j]==-1)printf("# ");else printf("%d ",b[j]);printf("[缺页]\t New is %d\n",now);} }cout<<"缺页数:"<<cnt<<endl;cout<<"缺页率:"<<(double)cnt/(double)l *100.0 <<"%"<<endl;}void clo()//clock{int cnt=0;int pos=0;int clk[10]={0};//clockint dis[10]={0};//distancememset(b,-1,sizeof b);for(int i=0;i<l;i++){int chg=0;int now=mem[i],f=0;while(1){if(b[pos]==now){f=1;clk[pos]=1;break;}if(b[pos]==-1 || clk[pos]==0){f=0;chg=pos;clk[pos]=1;break;}clk[pos]=0;pos++;pos=pos%n;}if(f==1){for(int j=0;j<n;j++) if(b[j]==-1)printf("# ");else printf("%d ",b[j]);printf("[命中]\t New is %d\n",now);}else if(f==0){b[chg]=now,cnt++;for(int j=0;j<n;j++) if(b[j]==-1)printf("# ");else printf("%d ",b[j]);printf("[缺页]\t New is %d\n",now);} }cout<<"缺页数:"<<cnt<<endl;cout<<"缺页率:"<<(double)cnt/(double)l *100.0 <<"%"<<endl;}int main(){sta();inp();cout<<"==Sequence Setting Finished=="<<endl; cout<<"Your Sequence is:"<<endl;for(int i=0;i<l;i++) cout<<mem[i]<<"\t";while(1){dis();cin>>choice;memset(b,0,sizeof b);if(tolower(choice[0])=='f') fif();else if(tolower(choice[0])=='l') lru();else if(tolower(choice[0])=='o') opt();else if(tolower(choice[0])=='c') clo();else if(tolower(choice[0])=='a') inp(); else if(tolower(choice[0])=='e') break;else cout<<"Invalid Input , Please Try again:";} cout<<"Thanks for Using"<<endl<<"\t__Author IOT Chendian 20125209"<<endl;return 0;}实际运行代码测试粗略的评析结果FIFO算法较易实现，对具有线性顺序特征的程序比较适用，而对具有其他特征的程序则效率不高，此算法还可能出现抖动现象，当序列为周期为N的重复子序列时效率最低。LRU算法基于程序的局部性原理，所以应该适用大多数程序，此算法实现需要维护淘汰队列。OPT算法虽然产生的缺页数最少，然而，却需要预测程序的页面引用串，大多数情况下这是无法预知的，不可能对程序的运行过程做出精确的断言，不过此理论算法可用作衡量各种具体算法的标准。时钟算法的话，有点像是改进了的FIFO算法，版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/41950107	A. Ciferatime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputWhen Petya went to school, he got interested in large numbers and what they were called in ancient times. For instance, he learned that the Russian word "tma" (which now means "too much to be counted") used to stand for a thousand and "tma tmyschaya" (which literally means "the tma of tmas") used to stand for a million.Petya wanted to modernize the words we use for numbers and invented a word petricium that represents number k. Moreover,petricium la petricium stands for number k2, petricium la petricium la petricium stands for k3 and so on. All numbers of this form are called petriciumus cifera, and the number's importance is the number of articles la in its title.Petya's invention brought on a challenge that needed to be solved quickly: does some number l belong to the set petriciumus cifera? As Petya is a very busy schoolboy he needs to automate the process, he asked you to solve it.InputThe first input line contains integer number k, the second line contains integer number l (2 ≤ k, l ≤ 231 - 1).OutputYou should print in the first line of the output "YES", if the number belongs to the set petriciumus cifera and otherwise print "NO". If the number belongs to the set, then print on the seconds line the only number — the importance of number l.Sample test(s)input525outputYES1input38outputNO说是在某种语言里，一个数的平方叫做 xxx la xxx，立方是 xxx la xxx la xxx，也就是n次方就是n-1个la，给两个数，问第二个数是第一个数的某个次幂吗?是的话，表示出来有几个la呢？那我们就 while(tmp<l) { tmp*=k; cnt++; } 这样一下~ 然后cnt就能说明一切啦~ 啊需要注意的是，超过范围但是发现不是某次幂要记得判断哦~#include <cstdio>#include <string>#include <cstring> #include <iostream>#include <algorithm>using namespace std;typedef long long ll;// http://codeforces.com/contest/114// Ciferaint main(){int cnt=0;ll k,tmp,l;cin>>k>>l; tmp=k;while(tmp<l){tmp*=k;cnt++;} if(tmp==l)cout<<"YES"<<endl<<cnt;else cout<<"NO";return 0;} 版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/41714585	Codeforces Round #281 (Div. 2) EditorialBy albertg, 93 minutes ago, translation, , 493A - Vasya and FootballWe need 2 arrays — for the first and second team, in which we must save "status" of the player — is he "clear", yellow carded or sent off. Then while inputing we must output the players name if he wasn't sent off, and after the event he must be sent off.493B - Vasya and WrestlingWe need to vectors in which we will save points of first and second wrestlers, and two int-s, where we will save who made the last technique and what is the sum of all the numbers in the input. If the sum is not zero, we know the answer. Else we pass by the vectors, checking are there respective elements which are not equal. If yes — then we know the answer, else everything depends on who made the last technique.493C - Vasya and BasketballWe need an array of pairs — in each pair we save the distance and the number of team. Then we sort the array. Then we assume that all the throws bring 3 points. Then we pass by the array and one of our numbers we decrease on 1 (which one — it depends on the second element of array). Then we compare it with our answer. In the end — we print our answer.493D - Vasya and ChessIf n is odd, then black can win white doing all the moves symetric by the central line. Else white can win putting his queen on (1,2) (which is the lexicographicly smallest place) and play symetricly — never using the first row.493E - Vasya and PolynomialLet's discuss 2 case. 1) t!=1 и 2) t=1.1) If our function is not constant (n>=1) than a is greater all the coefficients, so the only polynom can be the number b — in the a-ary counting system. We must only check that one and constant function.2)if t=1 must be careful: in case 1 1 1: the answer is inf, in case 1 1 n: the answer is 0 in case 1 а а^x(x-integer, x>0): the answer is 1 in the other cases P(1) is greater than other coefficients. Tutorial of Codeforces Round #282 (Div. 2)A. Vasya and Footballtime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputVasya has started watching football games. He has learned that for some fouls the players receive yellow cards, and for some fouls they receive red cards. A player who receives the second yellow card automatically receives a red card.Vasya is watching a recorded football match now and makes notes of all the fouls that he would give a card for. Help Vasya determine all the moments in time when players would be given red cards if Vasya were the judge. For each player, Vasya wants to know only the first moment of time when he would receive a red card from Vasya.InputThe first line contains the name of the team playing at home. The second line contains the name of the team playing away. Both lines are not empty. The lengths of both lines do not exceed 20. Each line contains only of large English letters. The names of the teams are distinct.Next follows number n (1 ≤ n ≤ 90) — the number of fouls.Each of the following n lines contains information about a foul in the following form:first goes number t (1 ≤ t ≤ 90) — the minute when the foul occurs;then goes letter "h" or letter "a" — if the letter is "h", then the card was given to a home team player, otherwise the card was given to an away team player;then goes the player's number m (1 ≤ m ≤ 99);then goes letter "y" or letter "r" — if the letter is "y", that means that the yellow card was given, otherwise the red card was given.The players from different teams can have the same number. The players within one team have distinct numbers. The fouls go chronologically, no two fouls happened at the same minute.OutputFor each event when a player received his first red card in a chronological order print a string containing the following information:The name of the team to which the player belongs;the player's number in his team;the minute when he received the card.If no player received a card, then you do not need to print anything.It is possible case that the program will not print anything to the output (if there were no red cards).Sample test(s)inputMCCSKA928 a 3 y62 h 25 y66 h 42 y70 h 25 y77 a 4 y79 a 25 y82 h 42 r89 h 16 y90 a 13 routputMC 25 70MC 42 82CSKA 13 90else if(c=="y" && hc[no]!=-1) 这里的-1手残写成了0……这题是足球犯规给牌的记录题目，如果有红牌了之后这个人你就不用管它了（用-1标记就好，以及一个人不能拿两次红牌哦，输出第一次即可），如果给了一张黄牌，记录一下拿过牌了，下一次拿黄牌的时候记得标记改成-1然后输出~Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;int hc[100]={0};int ac[100]={0};#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int main(){string h,a;cin>>h>>a;int n;cin>>n;for(int i=0;i<n;i++){int time,no;string w,c;cin>>time>>w>>no>>c;if(w=="a"){if(c=="r" && ac[no]!=-1){ac[no]=-1;cout<<a<<" "<<no<<" "<<time<<endl;}else if(c=="y" && ac[no]==0){ac[no]=time;}else if(c=="y" && ac[no]!=-1){ac[no]=-1;cout<<a<<" "<<no<<" "<<time<<endl;}}else{if(c=="r" && hc[no]!=-1){hc[no]=-1;cout<<h<<" "<<no<<" "<<time<<endl;}else if(c=="y" && hc[no]==0){hc[no]=time;}else if(c=="y" && hc[no]!=-1){hc[no]=-1;cout<<h<<" "<<no<<" "<<time<<endl;}}}return 0;}B. Vasya and Wrestlingtime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputVasya has become interested in wrestling. In wrestling wrestlers use techniques for which they are awarded points by judges. The wrestler who gets the most points wins.When the numbers of points of both wrestlers are equal, the wrestler whose sequence of points is lexicographically greater, wins.If the sequences of the awarded points coincide, the wrestler who performed the last technique wins. Your task is to determine which wrestler won.InputThe first line contains number n — the number of techniques that the wrestlers have used (1 ≤ n ≤ 2·105).The following n lines contain integer numbers ai (|ai| ≤ 109, ai ≠ 0). If ai is positive, that means that the first wrestler performed the technique that was awarded with ai points. And if ai is negative, that means that the second wrestler performed the technique that was awarded with ( - ai) points.The techniques are given in chronological order.OutputIf the first wrestler wins, print string "first", otherwise print "second"Sample test(s)input512-3-43outputsecondinput3-1-23outputfirstinput24-4outputsecondNoteSequence x  =  x1x2... x|x| is lexicographically larger than sequence y  =  y1y2... y|y|, if either |x|  >  |y| and x1  =  y1,  x2  =  y2, ... ,  x|y|  =  y|y|, or there is such number r (r  <  |x|, r  <  |y|), that x1  =  y1,  x2  =  y2,  ... ,  xr  =  yr and xr  +  1  >  yr  +  1.We use notation |a| to denote length of sequence a.25Time: 15 ms, memory: 1556 KBVerdict: WRONG_ANSWERInput6-1-2-3123OutputsecondAnswerfirstChecker commentwrong answer 1st words differ - expected: 'first', found: 'second'WA 在了上述这个数据上…… 为啥为啥为啥为啥……然后我在解题报告中看到了这句——then we know the answer, else everything depends on who made the last technique.好吧……我错了，错在这种地方好不甘心呀……Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int main(){int n=0;cin>>n;ll sum1=0,sum2=0;int num1[200048]={0},v1=0;int num2[200048]={0},v2=0;int last=0;for(int i=0;i<n;i++){int tmp;scanf("%d",&tmp);if(tmp>0) sum1+=tmp,num1[v1++]=tmp;else sum2+=-tmp,num2[v2++]=-tmp;if(i==n-1)last=tmp;}if(sum1>sum2)cout<<"first";else if(sum2>sum1)cout<<"second";else {if(v1>v2){for(int i=0;i<v2;i++){if(num1[i]==num2[i])continue;else if(num1[i]>num2[i]){cout<<"first"; return 0;}else{cout<<"second"; return 0;}}cout<<"first";return 0;}else{for(int i=0;i<v1;i++){if(num1[i]==num2[i])continue;else if(num1[i]>num2[i]){cout<<"first"; return 0;}else{cout<<"second"; return 0;}}if(v1==v2 && last<0)cout<<"second";else if(v1==v2) cout<<"first";else cout<<"second";return 0;}}return 0;}C. Vasya and Basketballtime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputVasya follows a basketball game and marks the distances from which each team makes a throw. He knows that each successful throw has value of either 2 or 3 points. A throw is worth 2 points if the distance it was made from doesn't exceed some value ofd meters, and a throw is worth 3 points if the distance is larger than d meters, where d is some non-negative integer.Vasya would like the advantage of the points scored by the first team (the points of the first team minus the points of the second team) to be maximum. For that he can mentally choose the value of d. Help him to do that.InputThe first line contains integer n (1 ≤ n ≤ 2·105) — the number of throws of the first team. Then follow n integer numbers — the distances of throws ai (1 ≤ ai ≤ 2·109).Then follows number m (1 ≤ m ≤ 2·105) — the number of the throws of the second team. Then follow m integer numbers — the distances of throws of bi (1 ≤ bi ≤ 2·109).OutputPrint two numbers in the format a:b — the score that is possible considering the problem conditions where the result of subtraction a - b is maximum. If there are several such scores, find the one in which number a is maximum.Sample test(s)input31 2 325 6output9:6input56 7 8 9 1051 2 3 4 5output15:10这道题是说有两个队伍各在距离篮筐这么多米的距离投进了球，让你来制定三分线在哪里，以至于一队比二队的净胜分最大。需要注意的地方挺多的，错了的孩子可以好好琢磨一下这组数据：Test: #10, time: 46 ms., memory: 3132 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWERInput42 5 3 241 5 6 2Output12:12Answer12:11Checker Logwrong answer 1st words differ - expected: '12:11', found: '12:12'这是一个十分需要细心的题目……主要是当判断到两队相同米数时很容易出错，需要知道的是，当三分线向外移动时，两个队伍分数是【同时】降低的。Code：#include<bits/stdc++.h>using namespace std;#define ll long longconst int maxn=200010;int a[maxn],b[maxn],n,m;ll x,y,A,B;int main(){    cin>>n;    for(int i=0;i<n;i++) cin>>a[i];    cin>>m;    for(int i=0;i<m;i++) cin>>b[i];    sort(a,a+n);   sort(b,b+m);    int j=m-1;    A=n;    B=m;    for(int i=n-1;i>=0;i--)    {        while(j>=0 && a[i]<=b[j]) j--,y++;        x++;        if(x-y>=A-B) A=x,B=y;    }    if(A<B) A=B=0;    cout<<(ll)n*2+A<<":"<<(ll)m*2+B<<endl;    return 0;}D. Vasya and Chesstime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputVasya decided to learn to play chess. Classic chess doesn't seem interesting to him, so he plays his own sort of chess.The queen is the piece that captures all squares on its vertical, horizontal and diagonal lines. If the cell is located on the same vertical, horizontal or diagonal line with queen, and the cell contains a piece of the enemy color, the queen is able to move to this square. After that the enemy's piece is removed from the board. The queen cannot move to a cell containing an enemy piece if there is some other piece between it and the queen.There is an n × n chessboard. We'll denote a cell on the intersection of the r-th row and c-th column as (r, c). The square (1, 1) contains the white queen and the square (1, n) contains the black queen. All other squares contain green pawns that don't belong to anyone.The players move in turns. The player that moves first plays for the white queen, his opponent plays for the black queen.On each move the player has to capture some piece with his queen (that is, move to a square that contains either a green pawn or the enemy queen). The player loses if either he cannot capture any piece during his move or the opponent took his queen during the previous move.Help Vasya determine who wins if both players play with an optimal strategy on the board n × n.InputThe input contains a single number n (2 ≤ n ≤ 109) — the size of the board.OutputOn the first line print the answer to problem — string "white" or string "black", depending on who wins if the both players play optimally.If the answer is "white", then you should also print two integers r and c representing the cell (r, c), where the first player should make his first move to win. If there are multiple such cells, print the one with the minimum r. If there are still multiple squares, print the one with the minimum c.Sample test(s)input2outputwhite1 2input3outputblackNoteIn the first sample test the white queen can capture the black queen at the first move, so the white player wins.In the second test from the statement if the white queen captures the green pawn located on the central vertical line, then it will be captured by the black queen during the next move. So the only move for the white player is to capture the green pawn located at (2, 1).Similarly, the black queen doesn't have any other options but to capture the green pawn located at (2, 3), otherwise if it goes to the middle vertical line, it will be captured by the white queen.During the next move the same thing happens — neither the white, nor the black queen has other options rather than to capture green pawns situated above them. Thus, the white queen ends up on square (3, 1), and the black queen ends up on square(3, 3).In this situation the white queen has to capture any of the green pawns located on the middle vertical line, after that it will be captured by the black queen. Thus, the player who plays for the black queen wins.这道题1A的时候我只想说……你是在逗我嘛……博弈，nxn的棋盘，白皇后在(1,1),黑皇后在(1,n)，皇后每次只能走相邻的八方向格子（如果相邻的格子被Remove了可以走到这个方向的第一个还健在的格子里），如果走到对方皇后所在格子内或者让对方皇后没路可走则获胜。 很轻易的可以知道，2white，3black，4只要向右一格就变成了3的黑白互换，5同理向右一格变成4所以不这么走即可black胜，依此类推看奇偶性即可。Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int main(){int n;cin>>n;if(n%2)cout<<"black"<<endl;else cout<<"white"<<endl<<"1 2"<<endl;return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/41714395	C题fst了…… 感觉状态不是很好…… 最近得好好复习考试了…… 可能得等寒假再捡回来编程了……A. Team Olympiadtime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputThe School №0 of the capital of Berland has n children studying in it. All the children in this school are gifted: some of them are good at programming, some are good at maths, others are good at PE (Physical Education). Hence, for each child we know value ti:ti = 1, if the i-th child is good at programming,ti = 2, if the i-th child is good at maths,ti = 3, if the i-th child is good at PEEach child happens to be good at exactly one of these three subjects.The Team Scientific Decathlon Olympias requires teams of three students. The school teachers decided that the teams will be composed of three children that are good at different subjects. That is, each team must have one mathematician, one programmer and one sportsman. Of course, each child can be a member of no more than one team.What is the maximum number of teams that the school will be able to present at the Olympiad? How should the teams be formed for that?InputThe first line contains integer n (1 ≤ n ≤ 5000) — the number of children in the school. The second line contains n integerst1, t2, ..., tn (1 ≤ ti ≤ 3), where ti describes the skill of the i-th child.OutputIn the first line output integer w — the largest possible number of teams.Then print w lines, containing three numbers in each line. Each triple represents the indexes of the children forming the team. You can print both the teams, and the numbers in the triplets in any order. The children are numbered from 1 to n in the order of their appearance in the input. Each child must participate in no more than one team. If there are several solutions, print any of them.If no teams can be compiled, print the only line with value w equal to 0.Sample test(s)input71 3 1 3 2 1 2output23 5 26 7 4input42 1 1 2output0题意是有n个人，他们分别精通1、2、3这三种技能，凑齐1、2、3可以组一个队伍，问这些人最多能组几个队伍并输出。直接用3个数组存相应技能有哪些人会，然后从下标0开始凑队即可Code：#include <cmath> #include <cctype>#include <vector>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;int t[10086]={0};int a[5]={0};vector<int> q[5];#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int main(){int n=0;cin>>n;for(int i=0;i<5;i++)q[i].clear();for(int i=0;i<n;i++){scanf("%d",&t[i]);a[t[i]]++;q[t[i]].push_back(i+1);}int minv=min(a[1],min(a[2],a[3]));printf("%d\n",minv);for(int i=0;i<minv;i++){printf("%d %d %d\n",q[1][i],q[2][i],q[3][i]);}return 0;}B. Queuetime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputDuring the lunch break all n Berland State University students lined up in the food court. However, it turned out that the food court, too, has a lunch break and it temporarily stopped working.Standing in a queue that isn't being served is so boring! So, each of the students wrote down the number of the student ID of the student that stands in line directly in front of him, and the student that stands in line directly behind him. If no one stands before or after a student (that is, he is the first one or the last one), then he writes down number 0 instead (in Berland State University student IDs are numerated from 1).After that, all the students went about their business. When they returned, they found out that restoring the queue is not such an easy task.Help the students to restore the state of the queue by the numbers of the student ID's of their neighbors in the queue.InputThe first line contains integer n (2 ≤ n ≤ 2·105) — the number of students in the queue.Then n lines follow, i-th line contains the pair of integers ai, bi (0 ≤ ai, bi ≤ 106), where ai is the ID number of a person in front of a student and bi is the ID number of a person behind a student. The lines are given in the arbitrary order. Value 0 is given instead of a neighbor's ID number if the neighbor doesn't exist.The ID numbers of all students are distinct. It is guaranteed that the records correspond too the queue where all the students stand in some order.OutputPrint a sequence of n integers x1, x2, ..., xn — the sequence of ID numbers of all the students in the order they go in the queue from the first student to the last one.Sample test(s)input492 310 731 07 141output92 7 31 141 NoteThe picture illustrates the queue for the first sample.有一堆学生排队，他们每个人都有一个大于1的学号，然后队伍散了，每个人都来说自己前头和自己后头的人的学号，让你把队伍恢复出来。我们不难发现，这些首尾相接的东西最终会串成两条链，分别为队伍中为奇数和队伍中为偶数的人们，然后把这个链组合起来即可（0，a）说明a是第二个人，（b，0）说明b是倒数第二个人。这个题目的要点在于队伍长度奇数和偶数时不同，需要判断。Code：#include <cmath> #include <queue>#include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;int a[2000086]={0};int b[2000086]={0};int frt[2000086]={0};int bnd[2000086]={0};int ans[2000086]={0};#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int main(){int n=0;cin>>n;int head,tail;for(int i=0;i<n;i++){cin>>a[i]>>b[i];frt[b[i]]=a[i];bnd[a[i]]=b[i];if(a[i]==0) head=b[i];if(b[i]==0) tail=a[i];}int now=head,pos=1,tmp=0;while(now){ans[pos]=now;now=bnd[now];if(now) frt[now]=0;pos+=2; }if(n%2==0) {now=tail,pos=n-2;while(now){ans[pos]=now;now=frt[now];pos-=2;}}else {int pi;for(int i=0;i<n;i++){if(frt[b[i]] && b[i]!=0){pi=b[i];while(frt[pi]){pi=frt[pi];}break;}}int now=pi,pos=0,tmp=0;while(now){ans[pos]=now;now=bnd[now];if(now) frt[now]=0;pos+=2; }}for(int i=0;i<n;i++){printf("%d",ans[i]);if(i<n-1)printf(" ");}return 0;}C. Hacking Cyphertime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputPolycarpus participates in a competition for hacking into a new secure messenger. He's almost won.Having carefully studied the interaction protocol, Polycarpus came to the conclusion that the secret key can be obtained if he properly cuts the public key of the application into two parts. The public key is a long integer which may consist of even a million digits!Polycarpus needs to find such a way to cut the public key into two nonempty parts, that the first (left) part is divisible by a as a separate number, and the second (right) part is divisible by b as a separate number. Both parts should be positive integers that have no leading zeros. Polycarpus knows values a and b.Help Polycarpus and find any suitable method to cut the public key.InputThe first line of the input contains the public key of the messenger — an integer without leading zeroes, its length is in range from 1 to 106 digits. The second line contains a pair of space-separated positive integers a, b (1 ≤ a, b ≤ 108).OutputIn the first line print "YES" (without the quotes), if the method satisfying conditions above exists. In this case, next print two lines — the left and right parts after the cut. These two parts, being concatenated, must be exactly identical to the public key. The left part must be divisible by a, and the right part must be divisible by b. The two parts must be positive integers having no leading zeros. If there are several answers, print any of them.If there is no answer, print in a single line "NO" (without the quotes).Sample test(s)input11640102497 1024outputYES116401024input2842545891539281719112818110001009 1000outputYES284254589153928171911281811000input12012 1outputNO吾辈的C题Fst了…… TLE@Test42安心的读字符串处理就好了呀Q^Q 我为啥要string和longlong联用呢……Q^Q关于当前字符串是否可以被某个数整除，我们每次都留下余数然后向后增加位数继续留下直至余数，即可~Code：#include <cstdio>#include <cstring>char in[1048576], vis[1048576];int main() {    int a, b, n, t(0), base(1), i; scanf("%s%d%d", in, &a, &b);    n = strlen(in);    for (i = 1; i < n; ++i) {        t = (t * 10 + in[i - 1] - '0') % a;        vis[i] = !t;    }    t = 0;    for (i = n - 1; i > 0; --i) {        (t += base * (in[i] - '0')) %= b;        if ((in[i] - '0') && !t && vis[i]) break;        (base *= 10) %= b;    }    if (!i) puts("NO");    else {        puts("YES");        for (int j = 0; j < i; ++j) putchar(in[j]);        putchar('\n'); puts(in + i);    }}#import<bits/stdc++.h>int a, b, c, n, p=1, i, d[1<<20];char m[1<<20];main() {gets(m);n = strlen(m);scanf("%d%d", &a, &b);for (i=n-1; i>=0; i--) {d[i] = ((m[i] - '0') * p + d[i + 1]) % b;p = p * 10 % b;}for (i=1; i<n; i++) {c = (c * 10 + m[i - 1] - '0') % a;if (!c && !d[i] && m[i] != '0') {puts("YES");printf("%.*s\n%s", i, m, m + i);return 0;}}puts("NO");}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/41601677	A. Petya and Stringstime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputLittle Petya loves presents. His mum bought him two strings of the same size for his birthday. The strings consist of uppercase and lowercase Latin letters. Now Petya wants to compare those two strings lexicographically. The letters' case does not matter, that is an uppercase letter is considered equivalent to the corresponding lowercase letter. Help Petya perform the comparison.InputEach of the first two lines contains a bought string. The strings' lengths range from 1 to 100 inclusive. It is guaranteed that the strings are of the same length and also consist of uppercase and lowercase Latin letters.OutputIf the first string is less than the second one, print "-1". If the second string is less than the first one, print "1". If the strings are equal, print "0". Note that the letters' case is not taken into consideration when the strings are compared.Sample test(s)inputaaaaaaaAoutput0inputabsAbzoutput-1inputabcdefgAbCdEfFoutput1NoteIf you want more formal information about the lexicographical order (also known as the "dictionary order" or "alphabetical order"), you can visit the following site:http://en.wikipedia.org/wiki/Lexicographical_order这题是说，无视大小写的情况下比较两个字符串字典序的大小大于输出1，小于是-1，相等是0.刚好C++的STL里有string的逻辑运算符重载，直接==、>、<就可以比较了 （注意，string的比较似乎是和大小写相关的所以我们要把它变成全大写或者全小写）Code：#include <cstdio>#include <string>#include <cstring> #include <iostream>#include <algorithm>using namespace std;typedef long long ll;// http://codeforces.com/contest/112// Petya and Stringsint main(){string a,b;cin>>a>>b;for(int i=0;i<a.length();i++){a[i]=tolower(a[i]);b[i]=tolower(b[i]);}if(a==b)cout<<0;else if(a>b)cout<<1;elsecout<<-1;return 0;} 版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/41600861	A. Nearly Lucky Numbertime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputPetya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Unfortunately, not all numbers are lucky. Petya calls a number nearly lucky if the number of lucky digits in it is a lucky number. He wonders whether number n is a nearly lucky number.InputThe only line contains an integer n (1 ≤ n ≤ 1018).Please do not use the %lld specificator to read or write 64-bit numbers in С++. It is preferred to use the cin, cout streams or the %I64d specificator.OutputPrint on the single line "YES" if n is a nearly lucky number. Otherwise, print "NO" (without the quotes).Sample test(s)input40047outputNOinput7747774outputYESinput1000000000000000000outputNONoteIn the first sample there are 3 lucky digits (first one and last two), so the answer is "NO".In the second sample there are 7 lucky digits, 7 is lucky number, so the answer is "YES".In the third sample there are no lucky digits, so the answer is "NO".字符串的妙用~虽说题目给了1e18的范围摆明了想让我们用longlong，但是这样的一次一次 /=10 还是很烦躁呀，直接用string，每一位不就是当前位数数值了嘛（其实也要减去'0'）题目意思是说，一个所有数位都是4或者7的数字称为幸运数，一个数“包含4或7的个数”为幸运数的称为接近幸运数，问给出的数是不是“接近幸运数”模拟咯~数出4、7的个数，因为就18位，所以只能是4个或者7个，都不用再判断一遍的。Code：#include <cstdio>#include <string>#include <cstring> #include <iostream>#include <algorithm>using namespace std;typedef long long ll;// http://codeforces.com/contest/110// Nearly Lucky Numberint main(){int cnt=0;string s;cin>>s; for(int i=0;i<s.length();i++)if(s[i]=='4'||s[i]=='7')cnt++;if(cnt==4 || cnt==7)cout<<"YES";else cout<<"NO";return 0;} 版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/41600451	A. Palindromic Timestime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputTattah is asleep if and only if Tattah is attending a lecture. This is a well-known formula among Tattah's colleagues.On a Wednesday afternoon, Tattah was attending Professor HH's lecture. At 12:21, right before falling asleep, he was staring at the digital watch around Saher's wrist. He noticed that the digits on the clock were the same when read from both directions i.e. a palindrome.In his sleep, he started dreaming about such rare moments of the day when the time displayed on a digital clock is a palindrome. As soon as he woke up, he felt destined to write a program that finds the next such moment.However, he still hasn't mastered the skill of programming while sleeping, so your task is to help him.InputThe first and only line of the input starts with a string with the format "HH:MM" where "HH" is from "00" to "23" and "MM" is from "00" to "59". Both "HH" and "MM" have exactly two digits.OutputPrint the palindromic time of day that comes soonest after the time given in the input. If the input time is palindromic, output the soonest palindromic time after the input time.Sample test(s)input12:21output13:31input23:59output00:00题意是说，电子钟的小时和分钟有时会形成回文序列，比如1221，0550之类的，给定一个现在的时间，问下一个回文时间是什么时候。反正没多少，直接枚举出来呗~ （需要注意的是，23：32之后的时间会推到下一天的00：00去）Code:#include <cstdio>#include <string>#include <cstring> #include <iostream>#include <algorithm>using namespace std;typedef long long ll;// http://codeforces.com/contest/108// Palindromic Timesint hor[]={0, 1, 2, 3, 4, 5,10,11,12,13,14,15,20,21,22,23};int mie[]={0,10,20,30,40,50,1 ,11,21,31,41,51, 2,12,22,32};int main(){char maohao;int h,m;cin>>h>>maohao>>m;for(int i=0;i<16;i++){if((hor[i]==h && mie[i]>m) || hor[i]>h){if(hor[i]<10)cout<<"0";cout<<hor[i]<<":";if(mie[i]<10)cout<<"0";cout<<mie[i]<<endl;return 0;}}cout<<"00:00"<<endl;return 0;} 版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/41599305	A. Card Gametime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputThere is a card game called "Durak", which means "Fool" in Russian. The game is quite popular in the countries that used to form USSR. The problem does not state all the game's rules explicitly — you can find them later yourselves if you want.To play durak you need a pack of 36 cards. Each card has a suit ("S", "H", "D" and "C") and a rank (in the increasing order "6", "7", "8", "9", "T", "J", "Q", "K" and "A"). At the beginning of the game one suit is arbitrarily chosen as trump.The players move like that: one player puts one or several of his cards on the table and the other one should beat each of them with his cards.A card beats another one if both cards have similar suits and the first card has a higher rank then the second one. Besides, a trump card can beat any non-trump card whatever the cards’ ranks are. In all other cases you can not beat the second card with the first one.You are given the trump suit and two different cards. Determine whether the first one beats the second one or not.InputThe first line contains the tramp suit. It is "S", "H", "D" or "C".The second line contains the description of the two different cards. Each card is described by one word consisting of two symbols. The first symbol stands for the rank ("6", "7", "8", "9", "T", "J", "Q", "K" and "A"), and the second one stands for the suit ("S", "H", "D" and "C").OutputPrint "YES" (without the quotes) if the first cards beats the second one. Otherwise, print "NO" (also without the quotes).Sample test(s)inputHQH 9SoutputYESinputS8D 6DoutputYESinputC7H ASoutputNO两张牌比大小的游戏。第一个字母是牌面点数，第二个是花色（Spade黑桃、Heart红桃、Diamond方片、Clover梅花（其实是四叶草啦））先给出的那个字母是王牌花色，如果两张牌一个是王牌另一个不是，那么王牌花色获胜，如果都是或者都不是比点数大小。这里我用了find函数 find(begin,end,key)可以返回找到的值在数组内的指针，指针之间可以相减获得距离。#include <cstdio>#include <string>#include <vector>#include <cstring> #include <iostream>#include <algorithm>using namespace std;typedef long long ll;// http://codeforces.com/contest/106// Card Gamechar tramp[9]={'6','7','8','9','T','J','Q','K','A'};int main(){string trp;cin>>trp;string a,b;cin>>a>>b;if(a[1]==trp[0] && b[1]!=trp[0]) cout<<"YES";else if(a[1]!=trp[0] && b[1]==trp[0]) cout<<"NO";else {int dist=find(tramp,tramp+9,a[0])-find(tramp,tramp+9,b[0]);if(dist>0) cout<<"YES";else cout<<"NO";}return 0;} 版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/41598271	A. Transmigrationtime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputIn Disgaea as in most role-playing games, characters have skills that determine the character's ability to use certain weapons or spells. If the character does not have the necessary skill, he cannot use it. The skill level is represented as an integer that increases when you use this skill. Different character classes are characterized by different skills.Unfortunately, the skills that are uncommon for the given character's class are quite difficult to obtain. To avoid this limitation, there is the so-called transmigration.Transmigration is reincarnation of the character in a new creature. His soul shifts to a new body and retains part of his experience from the previous life.As a result of transmigration the new character gets all the skills of the old character and the skill levels are reduced according to the k coefficient (if the skill level was equal to x, then after transmigration it becomes equal to [kx], where[y] is the integral part of y). If some skill's levels are strictly less than 100, these skills are forgotten (the character does not have them any more). After that the new character also gains the skills that are specific for his class, but are new to him. The levels of those additional skills are set to 0.Thus, one can create a character with skills specific for completely different character classes via transmigrations. For example, creating a mage archer or a thief warrior is possible.You are suggested to solve the following problem: what skills will the character have after transmigration and what will the levels of those skills be?InputThe first line contains three numbers n, m and k — the number of skills the current character has, the number of skills specific for the class into which the character is going to transmigrate and the reducing coefficient respectively; n and mare integers, and k is a real number with exactly two digits after decimal point (1 ≤ n, m ≤ 20, 0.01 ≤ k ≤ 0.99).Then follow n lines, each of which describes a character's skill in the form "name exp" — the skill's name and the character's skill level: name is a string and exp is an integer in range from 0 to 9999, inclusive.Then follow m lines each of which contains names of skills specific for the class, into which the character transmigrates.All names consist of lowercase Latin letters and their lengths can range from 1 to 20 characters, inclusive. All character's skills have distinct names. Besides the skills specific for the class into which the player transmigrates also have distinct names.OutputPrint on the first line number z — the number of skills the character will have after the transmigration. Then print z lines, on each of which print a skill's name and level, separated by a single space. The skills should be given in the lexicographical order.Sample test(s)input5 4 0.75axe 350impaler 300ionize 80megafire 120magicboost 220healmegafireshieldmagicboostoutput6axe 262heal 0impaler 225magicboost 165megafire 0shield 0这是一个游戏党出的题，原先你有这么多技能，右边是熟练度或者记忆度之类的东西，然后你学习了一些技能的同时以一个比率对已有技能的记忆能力降低成这个比率的数值（遗忘），以前没学过的技能就是0熟练度，学过的技能如果低于100就被忘掉了，问这次学习之后还剩多少技能以及他们的熟练度。这里我用了map的数据结构，将string和int绑在一起用map是很棒的哦~先make_pair(str,int*rate) 然后把整数部分不小于100的pair给push进map中，判断新学技能有没有原先不会的，有的话push进去（int部分是0哦）。最后把map里的东西都打印出来即可。Code#include <map>#include <cstdio>#include <string>#include <cstring> #include <iostream>#include <algorithm>using namespace std;typedef long long ll;// http://codeforces.com/contest/105// Transmigrationmap<string,int> mp;int main(){int n,m;double rate;cin>>n>>m>>rate;int rat=(int)(rate*100);for(int i=0;i<n;i++){string name;double p;cin>>name>>p;int pp=p*rat/100;if(pp>=100)mp.insert(make_pair(name,pp));}for(int i=0;i<m;i++){string name;cin>>name;if(mp[name]==0)mp.insert(make_pair(name,0));}cout<<mp.size()<<endl;for(map<string,int>::iterator it=mp.begin();it!=mp.end();it++){cout<<it->first<<" "<<it->second<<endl;}return 0;} 版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/41598115	A. Blackjacktime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputOne rainy gloomy evening when all modules hid in the nearby cafes to drink hot energetic cocktails, the Hexadecimal virus decided to fly over the Mainframe to look for a Great Idea. And she has found one!Why not make her own Codeforces, with blackjack and other really cool stuff? Many people will surely be willing to visit this splendid shrine of high culture.In Mainframe a standard pack of 52 cards is used to play blackjack. The pack contains cards of 13 values: 2, 3, 4, 5, 6,7, 8, 9, 10, jacks, queens, kings and aces. Each value also exists in one of four suits: hearts, diamonds, clubs and spades. Also, each card earns some value in points assigned to it: cards with value from two to ten earn from 2 to 10points, correspondingly. An ace can either earn 1 or 11, whatever the player wishes. The picture cards (king, queen and jack) earn 10 points. The number of points a card earns does not depend on the suit. The rules of the game are very simple. The player gets two cards, if the sum of points of those cards equals n, then the player wins, otherwise the player loses.The player has already got the first card, it's the queen of spades. To evaluate chances for victory, you should determine how many ways there are to get the second card so that the sum of points exactly equals n.InputThe only line contains n (1 ≤ n ≤ 25) — the required sum of points.OutputPrint the numbers of ways to get the second card in the required way if the first card is the queen of spades.Sample test(s)input12output4input20output15input10output0NoteIn the first sample only four two's of different suits can earn the required sum of points.In the second sample we can use all tens, jacks, queens and kings; overall it's 15 cards, as the queen of spades (as any other card) is only present once in the pack of cards and it's already in use.In the third sample there is no card, that would add a zero to the current ten points.读懂题意即可的一道题。有52张牌，分为四种花色，JQK和10一样都算10分，A可以当1分可以当11分，现在已经有一张黑桃Q了（10分），给出一个数字n，问再抽一张牌，他们的和为n的抽法有多少中种。那么我们来等价一下题意：从A到K四种花色各一张，黑桃Q除外，A可以当1或者11，JQK为10，问值为 n-10 的牌有多少张。牌的点数都大于等于1，所以如果n-10<=0，答案为0反之，看有多少种了呗~记住黑桃Q用掉了所以如果需要10的话记得减一~Code：#include <cstdio>#include <string>#include <cstring> #include <iostream>#include <algorithm>using namespace std;typedef long long ll;// http://codeforces.com/contest/104// Black Jackint ans[26]={0};int main(){int n;cin>>n;for(int i=11;i<20;i++)ans[i]=4;ans[20]=15;ans[21]=4;cout<<ans[n];return 0;} 版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/41577785	A. Clothestime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputA little boy Gerald entered a clothes shop and found out something very unpleasant: not all clothes turns out to match. For example, Gerald noticed that he looks rather ridiculous in a smoking suit and a baseball cap.Overall the shop sells n clothing items, and exactly m pairs of clothing items match. Each item has its price, represented by an integer number of rubles. Gerald wants to buy three clothing items so that they matched each other. Besides, he wants to spend as little money as possible. Find the least possible sum he can spend.InputThe first input file line contains integers n and m — the total number of clothing items in the shop and the total number of matching pairs of clothing items ().Next line contains n integers ai (1 ≤ ai ≤ 106) — the prices of the clothing items in rubles.Next m lines each contain a pair of space-separated integers ui and vi (1 ≤ ui, vi ≤ n, ui ≠ vi). Each such pair of numbers means that the ui-th and the vi-th clothing items match each other. It is guaranteed that in each pair ui and vi are distinct and all the unordered pairs (ui, vi) are different.OutputPrint the only number — the least possible sum in rubles that Gerald will have to pay in the shop. If the shop has no three clothing items that would match each other, print "-1" (without the quotes).Sample test(s)input3 31 2 31 22 33 1output6input3 22 3 42 32 1output-1input4 41 1 1 11 22 33 44 1output-1NoteIn the first test there only are three pieces of clothing and they all match each other. Thus, there is only one way — to buy the 3 pieces of clothing; in this case he spends 6 roubles.The second test only has three pieces of clothing as well, yet Gerald can't buy them because the first piece of clothing does not match the third one. Thus, there are no three matching pieces of clothing. The answer is -1.In the third example there are 4 pieces of clothing, but Gerald can't buy any 3 of them simultaneously. The answer is -1.有各种各样的服饰，会给出他们的价格，以及每行两个整型，代表着下标为a和b的两个服饰相匹配，问是否存在三件两两相配的服饰，存在的话请找出总价最低的配套。这如果在图论上考虑的话是寻找三元环中顶点权值和最小的环，对于一个A题这有点过了，咱们用vector来存每一个节点相配的服饰编号。如果与a相配的衣服b，满足与b相配的衣服c中有与c相配的衣服为a的（好绕我的天），那就更新钱数，即三个服饰的价钱总和，与当前ans值取较小的。Code：#include <cstdio>#include <string>#include <vector>#include <cstring> #include <iostream>#include <algorithm>using namespace std;typedef long long ll;const int maxv=1000086;// http://codeforces.com/contest/102// Clothesvector<int> mat[127];int prc[127]={0};int minp[127]={0};int main(){memset(minp,-1,sizeof minp);int n,m,ans=3*maxv;cin>>n>>m;for(int i=0;i<n;i++){scanf("%d",&prc[i+1]);mat[i].clear();minp[i]=-1;}for(int i=0;i<m;i++){//cout<<ans<<endl;int a,b;scanf("%d%d",&a,&b);for(int i=0;i<mat[b].size();i++){int k=mat[b][i];for(int j=0;j<mat[k].size();j++){if(mat[k][j]==a) ans=min(prc[a]+prc[b]+prc[k],ans);}}mat[a].push_back(b);mat[b].push_back(a);}//minp[a]=(minp[a]+1)?min(minp[a],prc[b]):prc[b];//minp[b]=(minp[b]+1)?min(minp[b],prc[a]):prc[a];if(ans==3*maxv) cout<<"-1";else cout<<ans;return 0;} 版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/41577695	A. Help Far Away Kingdomtime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputIn a far away kingdom lived the King, the Prince, the Shoemaker, the Dressmaker and many other citizens. They lived happily until great trouble came into the Kingdom. The ACMers settled there.Most damage those strange creatures inflicted upon the kingdom was that they loved high precision numbers. As a result, the Kingdom healers had already had three appointments with the merchants who were asked to sell, say, exactly 0.273549107 beer barrels. To deal with the problem somehow, the King issued an order obliging rounding up all numbers to the closest integer to simplify calculations. Specifically, the order went like this:If a number's integer part does not end with digit 9 and its fractional part is strictly less than 0.5, then the rounded up number coincides with the number’s integer part.If a number's integer part does not end with digit 9 and its fractional part is not less than 0.5, the rounded up number is obtained if we add 1 to the last digit of the number’s integer part.If the number’s integer part ends with digit 9, to round up the numbers one should go to Vasilisa the Wise. In the whole Kingdom she is the only one who can perform the tricky operation of carrying into the next position.Merchants found the algorithm very sophisticated and they asked you (the ACMers) to help them. Can you write a program that would perform the rounding according to the King’s order?InputThe first line contains a single number to round up — the integer part (a non-empty set of decimal digits that do not start with 0 — with the exception of a case when the set consists of a single digit — in this case 0 can go first), then follows character «.» (a dot), and then follows the fractional part (any non-empty set of decimal digits). The number's length does not exceed 1000 characters, including the dot. There are no other characters in the input data.OutputIf the last number of the integer part is not equal to 9, print the rounded-up number without leading zeroes. Otherwise, print the message "GOTO Vasilisa." (without the quotes).Sample test(s)input0.0output0input1.49output1input1.50output2input2.71828182845904523536output3input3.14159265358979323846output3input12345678901234567890.1output12345678901234567890input123456789123456789.999outputGOTO Vasilisa.这是一个把浮点数四舍五入成整数的程序，但是如果需要进位的同时整数部分的末位是0，则输出 GOTO Vasilisa。所以相当于一个翻译题，翻译题意即可……使用string来存储可以省下不少麻烦。解题：找到点在哪里，然后点的后一位和前一位决定了全局，后一位决定进不进，进位的话前一位决定输出还是GOTOCode：#include <cstdio>#include <string>#include <cstring> #include <iostream>#include <algorithm>using namespace std;typedef long long ll;// http://codeforces.com/contest/99// Help Far Away Kingdomint main(){string s;cin>>s;string ans="";int flag=0;for(int i=0;i<s.length();i++){if(s[i]!='.' && !flag) ans+=s[i];else if(s[i]=='.' && !flag) flag=1;else {int lst=ans[i-2]-'0';int num=s[i]-'0';if(num<5) break;else if(lst!=9) ans[i-2]=ans[i-2]+1;else {cout<<"GOTO Vasilisa.";return 0;}break;}}cout<<ans;return 0;} 版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/41376589	这次的题目略可怕，只出了2道题就成了46名，直接加了161分进入了紫名……Codeforces Hot News!Wow! Coder CST14-okcd00 competed in Codeforces Round #278 (Div. 2) and gained +161 rating points taking place 46Share on vkShare on facebookShare on twitterA. Giga Towertime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputGiga Tower is the tallest and deepest building in Cyberland. There are 17 777 777 777 floors, numbered from  - 8 888 888 888 to 8 888 888 888. In particular, there is floor 0 between floor  - 1 and floor 1. Every day, thousands of tourists come to this place to enjoy the wonderful view.In Cyberland, it is believed that the number "8" is a lucky number (that's why Giga Tower has 8 888 888 888 floors above the ground), and, an integer is lucky, if and only if its decimal notation contains at least one digit "8". For example, 8,  - 180, 808 are all lucky while42,  - 10 are not. In the Giga Tower, if you write code at a floor with lucky floor number, good luck will always be with you (Well, this round is #278, also lucky, huh?).Tourist Henry goes to the tower to seek good luck. Now he is at the floor numbered a. He wants to find the minimum positive integer b, such that, if he walks b floors higher, he will arrive at a floor with a lucky number.InputThe only line of input contains an integer a ( - 109 ≤ a ≤ 109).OutputPrint the minimum b in a line.Sample test(s)input179output1input-1output9input18output10NoteFor the first sample, he has to arrive at the floor numbered 180.For the second sample, he will arrive at 8.Note that b should be positive, so the answer for the third sample is 10, not 0.题意是有着一座顶天入地的塔，我现在在其中的一层，问向上爬最少几层就可以到一个含有数字8的楼层鉴于最多走10层就能变成个位数为8，so……为何不枚举？需要注意的是楼层可以为负数不要直接简单相加弄错了哦~Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}bool judge(ll n){ll nn=abs(n);while(nn){int now=nn%10;if(now==8)return true;else nn/=10;}return false;}int main(){ll n;cin>>n;for(ll i=1;;i++){if(judge(n+i)){printf("%d",i);return 0;} }return 0;}B. Candy Boxestime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputThere is an old tradition of keeping 4 boxes of candies in the house in Cyberland. The numbers of candies are special if their arithmetic mean, their median and their range are all equal. By definition, for a set {x1, x2, x3, x4} (x1 ≤ x2 ≤ x3 ≤ x4) arithmetic mean is , median is  and range is x4 - x1. The arithmetic mean and median are not necessary integer. It is well-known that if those three numbers are same, boxes will create a "debugging field" and codes in the field will have no bugs.For example, 1, 1, 3, 3 is the example of 4 numbers meeting the condition because their mean, median and range are all equal to 2.Jeff has 4 special boxes of candies. However, something bad has happened! Some of the boxes could have been lost and now there are only n (0 ≤ n ≤ 4) boxes remaining. The i-th remaining box contains ai candies.Now Jeff wants to know: is there a possible way to find the number of candies of the 4 - n missing boxes, meeting the condition above (the mean, median and range are equal)?InputThe first line of input contains an only integer n (0 ≤ n ≤ 4).The next n lines contain integers ai, denoting the number of candies in the i-th box (1 ≤ ai ≤ 500).OutputIn the first output line, print "YES" if a solution exists, or print "NO" if there is no solution.If a solution exists, you should output 4 - n more lines, each line containing an integer b, denoting the number of candies in a missing box.All your numbers b must satisfy inequality 1 ≤ b ≤ 106. It is guaranteed that if there exists a positive integer solution, you can always find such b's meeting the condition. If there are multiple answers, you are allowed to print any of them.Given numbers ai may follow in any order in the input, not necessary in non-decreasing.ai may have stood at any positions in the original set, not necessary on lowest n first positions.Sample test(s)input211outputYES33input3111outputNOinput41223outputYESNoteFor the first sample, the numbers of candies in 4 boxes can be 1, 1, 3, 3. The arithmetic mean, the median and the range of them are all2.For the second sample, it's impossible to find the missing number of candies.In the third example no box has been lost and numbers satisfy the condition.You may output b in any order.有四盒糖，糖的数量满足以下条件：四盒糖的平均数和中位数相等，这个数值同时等于最大值和最小值的差。我们优化一下，就是如果按照从小到大排序ABCD，那么A+D=B+C，2D-2A=B+C 故D=3A好了这题成了4个盒子，其中一个为另一个的三倍，剩下俩的和等于这俩的和即可。题目问：我现在只知道其中n个盒子（0~4）里的糖数，有没有可能满足上述条件，有的话输出糖数。于是分情况讨论咯~ 0）什么，你让我随便写？ 12231）有一个了，A范围在0-500，b的范围不大于1e6……那果断乘三得到D咯 AADD2）有俩了，那得看看，两个数相同的话直接AADD，不相同的话只要大的不超过小的数的三倍，那大的就是B（也可以是C，无妨），小的是A，然后D=3A，C=3A+A-B3）都给了仨了那就看看剩下的是谁呗：如果给的数有一个是另一个的三倍，剩下的那个只要在这俩之间就行，C=A+D-B如果没有三倍关系那说明是ABC或者BCD组合，我们把最小数乘三吧（反正范围大）4）四个都有了直接算看看是否满足条件咯~Code:#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))int a[5]={0};const int limit=1000000;bool cmp(const int a, const int b){return a > b;}int main(){int n;cin>>n;for(int i=0;i<n;i++) scanf("%d",&a[i]);if(n==0) printf("YES\n1\n1\n3\n3\n");else if(n==1){printf("YES\n%d\n%d\n%d\n",a[0]*2,a[0]*2,a[0]*3);}else if(n==2){sort(a,a+2);if(a[0]==a[1] && a[0]*3<=limit) printf("YES\n%d\n%d\n",a[0]*3,a[0]*3);else if(a[0]==a[1] && a[0]%3==0) printf("YES\n%d\n%d\n",a[0]/3,a[0]/3);else{if(a[1]%a[0]==0 && a[1]/a[0]==3) printf("YES\n%d\n%d\n",a[0],a[1]);else if(a[1]/a[0]<3 && a[0]*3<=limit) printf("YES\n%d\n%d\n",a[0]*3,a[0]*3+a[0]-a[1]);else printf("NO\n"); //nonsence, ignore it}} else if(n==3){sort(a,a+3);if(a[2]%a[0]==0 && a[2]/a[0]==3) printf("YES\n%d\n",a[2]-a[1]+a[0]);else {int rest1=a[2]+a[1]-a[0];//a_4int rest2=a[0]+a[1]-a[2];//a_1if(rest1%a[0]==0 && rest1/a[0]==3 && rest1<=limit) printf("YES\n%d\n",rest1);else if(a[2]%rest2==0 && a[2]/rest2==3 && rest2<=limit) printf("YES\n%d\n",rest2);else printf("NO\n");}}else if(n==4){sort(a,a+4);if(a[0]+a[3]==a[1]+a[2] && a[3]-a[0]==(a[1]+a[2])/2 && (a[1]+a[2])%2==0 ) printf("YES\n");else printf("NO\n");}return 0;}C. Fight the Monstertime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputA monster is attacking the Cyberland!Master Yang, a braver, is going to beat the monster. Yang and the monster each have 3 attributes: hitpoints (HP), offensive power (ATK) and defensive power (DEF).During the battle, every second the monster's HP decrease by max(0, ATKY - DEFM), while Yang's HP decreases bymax(0, ATKM - DEFY), where index Y denotes Master Yang and index M denotes monster. Both decreases happen simultaneously Once monster's HP ≤ 0 and the same time Master Yang's HP > 0, Master Yang wins.Master Yang can buy attributes from the magic shop of Cyberland: h bitcoins per HP, a bitcoins per ATK, and d bitcoins per DEF.Now Master Yang wants to know the minimum number of bitcoins he can spend in order to win.InputThe first line contains three integers HPY, ATKY, DEFY, separated by a space, denoting the initial HP, ATK and DEF of Master Yang.The second line contains three integers HPM, ATKM, DEFM, separated by a space, denoting the HP, ATK and DEF of the monster.The third line contains three integers h, a, d, separated by a space, denoting the price of 1 HP, 1 ATK and 1 DEF.All numbers in input are integer and lie between 1 and 100 inclusively.OutputThe only output line should contain an integer, denoting the minimum bitcoins Master Yang should spend in order to win.Sample test(s)input1 2 11 100 11 100 100output99input100 100 1001 1 11 1 1output0NoteFor the first sample, prices for ATK and DEF are extremely high. Master Yang can buy 99 HP, then he can beat the monster with 1 HP left.For the second sample, Master Yang is strong enough to beat the monster, so he doesn't need to buy anything.数据范围都这么少了不模拟枚举不开心Code：#include <cstdio>#include <algorithm>using namespace std;int main(){    int hy, ay, dy, hm, am, dm, h, a, d, ans = 1e9, i, j;        scanf("%d %d %d", &hy, &ay, &dy);    scanf("%d %d %d", &hm, &am, &dm);    scanf("%d %d %d", &h, &a, &d);        for (i = 0; i <= 200; i++) {        for (j = 0; j <= 100; j++) {            int x = max(0, ay + i - dm);            int y = max(0, am - dy - j);            int z, t;                        if (x == 0) continue;            t = (hm + x - 1) / x;            z = max(0, y * t + 1 - hy);            ans = min(ans, i * a + j * d + z * h);        }    }        printf("%d\n", ans);        return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/41375663	寝室外面有个男生在和女生打分手电话……时长85分钟，我只能含泪努力，结果还是坑掉了这场……55555‘Problems  #Name  ACalculating Functionstandard input/output1 s, 256 MB  x4256BOR in Matrixstandard input/output1 s, 256 MB  x2520CPalindrome Transformationstandard input/output1 s, 256 MB  x1769DValid Setsstandard input/output1 s, 256 MB  x643ELIS of Sequencestandard input/output2 s, 256 MB  x381大家都表示简单的一场，我一直被打断一直低级错误，WA数空前新高……哭A. Calculating Functiontime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputFor a positive integer n let's define a function f:f(n) =  - 1 + 2 - 3 + .. + ( - 1)nnYour task is to calculate f(n) for a given integer n.InputThe single line contains the positive integer n (1 ≤ n ≤ 1015).OutputPrint f(n) in a single line.Sample test(s)input4output2input5output-3Notef(4) =  - 1 + 2 - 3 + 4 = 2f(5) =  - 1 + 2 - 3 + 4 - 5 =  - 3题意的话就是说，-+-+-+-+这样的加减式子，有n个数字组成，问结果。分奇偶然后两两一组求和~Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int main(){long long n=0;cin>>n;if(n%2==0)cout<<n/2;else cout<<n/2-n;return 0;}B. OR in Matrixtime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputLet's define logical OR as an operation on two logical values (i. e. values that belong to the set {0, 1}) that is equal to 1 if either or both of the logical values is set to 1, otherwise it is 0. We can define logical OR of three or more logical values in the same manner: where  is equal to 1 if some ai = 1, otherwise it is equal to 0.Nam has a matrix A consisting of m rows and n columns. The rows are numbered from 1 to m, columns are numbered from 1 to n. Element at row i (1 ≤ i ≤ m) and column j (1 ≤ j ≤ n) is denoted as Aij. All elements of A are either 0 or 1. From matrix A, Nam creates another matrix B of the same size using formula:.(Bij is OR of all elements in row i and column j of matrix A)Nam gives you matrix B and challenges you to guess matrix A. Although Nam is smart, he could probably make a mistake while calculating matrix B, since size of A can be large.InputThe first line contains two integer m and n (1 ≤ m, n ≤ 100), number of rows and number of columns of matrices respectively.The next m lines each contain n integers separated by spaces describing rows of matrix B (each element of B is either 0 or 1).OutputIn the first line, print "NO" if Nam has made a mistake when calculating B, otherwise print "YES". If the first line is "YES", then also printm rows consisting of n integers representing matrix A that can produce given matrix B. If there are several solutions print any one.Sample test(s)input2 21 00 0outputNOinput2 31 1 11 1 1outputYES1 1 11 1 1input2 30 1 01 1 1outputYES0 0 00 1 0有一个矩阵A，是由01组成的，然后逐行逐列进行OR逻辑运算，得到的结果为B矩阵。简单来说，就是如果A里有个1，那么B里这个1的所在行和所在列都成1了。给结果矩阵问原矩阵是什么。先逐行读，找出全为1的行，记录位置，然后逐列读，找出全为1的列，同时判断不为全1行却出现1的话直接判NO。获得行列位置之后一一对应，行、列用剩下的都和对方的第一个下标挤一挤就好。Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;int mat[111][111]={0};int ans[111][111]={0};int visrow[111]={0};int col[111]={0},vcol=0;int row[111]={0},vrow=0;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int main(){int n,m;cin>>n>>m;int flag=0,zero=0;for(int i=0;i<n;i++){scanf("%d",&mat[i][0]);flag=0;if(mat[i][0]) flag=1,zero=1;for(int j=1;j<m;j++){scanf("%d",&mat[i][j]);if(mat[i][j]) zero=1;if(mat[i][j]!=mat[i][0]){flag=0;}}if(flag) row[vrow++]=i, visrow[i]=1;}for(int j=0;j<m;j++){flag=0;if(mat[0][j]) flag=1;for(int i=1;i<n;i++){if(mat[i][j]!=mat[0][j]){flag=0;}}if(flag) col[vcol++]=j;else{for(int i=0;i<n;i++){if(mat[i][j] && visrow[i]==0){cout<<"NO";return 0;}}}}if(zero==0){cout<<"YES"<<endl;for(int i=0;i<n;i++){printf("%d",mat[i][0]);for(int j=1;j<m;j++){printf(" %d",mat[i][j]);}printf("\n");}return 0;}if(vcol==0 || vrow==0){cout<<"NO";return 0;}int l=max(vcol,vrow),s=min(vcol,vrow),cntp=0;for(cntp=0;cntp<s;cntp++){ans[row[cntp]][col[cntp]]=1;}if(l==vrow)for(;cntp<l;cntp++){ans[row[cntp]][col[0]]=1;}else for(;cntp<l;cntp++){ans[row[0]][col[cntp]]=1;}printf("YES\n");for(int i=0;i<n;i++){printf("%d",ans[i][0]);for(int j=1;j<m;j++){printf(" %d",ans[i][j]);}printf("\n");}return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/41289429	以数值积分的方法计算Pi的值，采用Win32 API来实现程序的并行化。步骤： 1、用Microsoft Visual Studio 2013创建控制台项目WinPi 2、创建WinPi.cpp将代码加入到程序中合适的位置，输出计算时间。3、 编译执行， Pi的值为:  3.141592654  The time ofcalculationwas 1.062000(calc 12345678times)seconds4 、将WinPi.cpp程序修改为WindowsThreads并行程序。（1）    分析代码中的并行域是： x = (i + 0.5)*step;       sum += 4.0 / (1.0 + x*x);（2）定义线程执行的函数。函数原型为DWORDWINAPI 函数名(LPVOIDp);  见源代码（3）提取并行域代码，作为（2）中定义的函数的函数体（4）生成多个线程调用（3）中的函数（5）解决线程间的同步和互斥。 5 、采用临界区的方法进行必要的互斥。要多线程实现的话，我们主要是把for循环的计算过程分到几个线程中去，由于每次计算我们都要更新sum的值，就有可能发生一个线程已经更新了sum的值，而另一个线程读到的还是旧的sum值，所以在这里我们使用临界区，把sum放到临界区中，这样一次只能有一个线程访问和修改sum的值。 【临界区主要代码】CRITICAL_SECTIONg_cs;InitializeCriticalSection(&g_cs);EnterCriticalSection(&g_cs);临界区计算LeaveCriticalSection(&g_cs);DeleteCriticalSection(&g_cs); 6、编译执行，Pi的值为： 3.141592654  The time ofcalculationwas  1.375   seconds 7、不同线程数，相同计算量，计算时间对比分析。线程数时间线程数时间11.34381.29621.32891.31231.343101.32841.375121.34451.328151.35961.313201.31271.328251.343301.3288、线程数相同，计算量不同，计算时间对比分析。（调整num_step可调整计算量）计算量时间15000000150000000.1251.50E+091.3121500000000013.196// WinPi.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include <Windows.h>#include <stdio.h>#include <time.h>int i = 0;double step, pi;clock_t start, stop, allstart, allstop;double x, sum = 0.0;const int numThreads = 5;//5-threads calcstatic long num_steps = 1500000000;CRITICAL_SECTION g_cs;DWORD WINAPI calc(LPVOID p){int cnt = 0;printf("Now a new Thread is calc-ing\n");start = clock();EnterCriticalSection(&g_cs);for (; cnt<num_steps / numThreads; cnt++, i++){x = (i + 0.5)*step;sum += 4.0 / (1.0 + x*x);}LeaveCriticalSection(&g_cs);stop = clock();printf("the time of calc was %f s\n", ((double)(stop - start) / 1000.0));return 0;}int _tmain(int argc, _TCHAR* argv[]){HANDLE hThread[numThreads];int tNum[50];step = 1.0 / (double)num_steps;allstart = clock();InitializeCriticalSection(&g_cs);for (i = 0; i < numThreads; i++){tNum[i] = i;hThread[i] = CreateThread(NULL, 0, calc, (LPVOID)&tNum[i], 0, NULL);}WaitForMultipleObjects(numThreads, hThread, TRUE, INFINITE);allstop = clock();printf("Now step=%f ,sum=%f \n", step, sum);pi = step*sum;printf("Pi=%12.9f\n", pi);printf("the time of total was %f s\n", ((double)(allstop - allstart) / 1000.0));DeleteCriticalSection(&g_cs);system("pause");return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/41286901	步骤： 1、 用Microsoft Visual Studio 2005创建控制台项目HelloThreads 。 2、 创建HelloThreads.cpp文件3、点击项目—>HelloThreads属性菜单，按图1-1~图1-4配置项目属性。4、编译执行，输出结果：5、修改代码，使之输出结果可以表示出各线程的输出顺序。// HelloThreads.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include <Windows.h>#include <stdio.h>const int numThreads = 4;DWORD WINAPI helloFunc(LPVOID pArg){int j = *(int*)pArg;printf("Hello Thread %d\n",j);return 0;}int _tmain(int argc, _TCHAR* argv[]){HANDLE hThread[numThreads];int tNum[4];for (int i = 0; i < numThreads; i++){tNum[i] = i;hThread[i] = CreateThread(NULL, 0, helloFunc, &tNum[i], 0, NULL);}WaitForMultipleObjects(numThreads, hThread, TRUE, INFINITE);system("pause");return 0;}结果截图版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/41155587	A. Footballtime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputPetya loves football very much. One day, as he was watching a football match, he was writing the players' current positions on a piece of paper. To simplify the situation he depicted it as a string consisting of zeroes and ones. A zero corresponds to players of one team; a one corresponds to players of another team. If there are at least 7players of some team standing one after another, then the situation is considered dangerous. For example, the situation 00100110111111101 is dangerous and 11110111011101 is not. You are given the current situation. Determine whether it is dangerous or not.InputThe first input line contains a non-empty string consisting of characters "0" and "1", which represents players. The length of the string does not exceed 100 characters. There's at least one player from each team present on the field.OutputPrint "YES" if the situation is dangerous. Otherwise, print "NO".Sample test(s)input001001outputNOinput1000000001outputYES题意是问是否存在7个或以上相同的数字相连读入从左到右依次遍历计数即可Code：#include <cstdio>#include <string>#include <cstring> #include <iostream>#include <algorithm>using namespace std;typedef long long ll;// http://codeforces.com/contest/96// Footballint main(){string s;cin>>s;int cnt=1;for(int i=1;i<s.length();i++){if(s[i]==s[i-1]) cnt++;else cnt=1;if(cnt==7) {cout<<"YES";return 0;} } cout<<"NO";return 0;} 版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/41151343	A. Restoring Passwordtime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputIgor K. always used to trust his favorite Kashpirovsky Antivirus. That is why he didn't hesitate to download the link one of his groupmates sent him via QIP Infinium. The link was said to contain "some real funny stuff about swine influenza". The antivirus had no objections and Igor K. run the flash application he had downloaded. Immediately his QIP Infinium said: "invalid login/password".Igor K. entered the ISQ from his additional account and looked at the info of his main one. His name and surname changed to "H1N1" and "Infected" correspondingly, and the "Additional Information" field contained a strange-looking binary code 80 characters in length, consisting of zeroes and ones. "I've been hacked" — thought Igor K. and run the Internet Exploiter browser to quickly type his favourite search engine's address.Soon he learned that it really was a virus that changed ISQ users' passwords. Fortunately, he soon found out that the binary code was actually the encrypted password where each group of 10 characters stood for one decimal digit. Accordingly, the original password consisted of 8 decimal digits.Help Igor K. restore his ISQ account by the encrypted password and encryption specification.InputThe input data contains 11 lines. The first line represents the binary code 80 characters in length. That is the code written in Igor K.'s ISQ account's info. Next 10 lines contain pairwise distinct binary codes 10 characters in length, corresponding to numbers 0, 1, ..., 9.OutputPrint one line containing 8 characters — The password to Igor K.'s ISQ account. It is guaranteed that the solution exists.Sample test(s)input010011001001011000000101100010010110010001011001100101101000010110101001011011000100110000010011001001011000000101100010010110010001011001100101101000010110101001011011000101101110output12345678input101011011110010000101001000110101011011100101101110110001000110111100101100010001001000010110111100110010001101010110111001011011111010011011011000001111001010110110110000110001000output30234919题目名就告诉你们这个题目叫做【存密码】给一个长字符串，然后给你0-9的表示方法，问刚刚那个字符串是怎样一个8位数我们就用str[i] i=0~9 来存储每个数字代表的串咯~然后怎么匹配呢，我们可以用substr这个函数 str.substr(pos,len) 是代表从str字符串的pos开始，获得一个长度为len的字符串，这是一个字符串问题常用的很方便快捷的函数。那么来看看源码？#include <cstdio>#include <string>#include <cstdlib>#include <cstring> #include <iostream>#include <algorithm>using namespace std;typedef long long ll;// http://codeforces.com/contest/94// Restoring Passwordint main(){string acinfo;cin>>acinfo;string s[10];for(int i=0;i<10;i++)cin>>s[i];for(int i=0;i<8;i++){string tmp=acinfo.substr(i*10,10);//cout<<tmp<<endl;for(int i=0;i<10;i++){if(tmp==s[i]){cout<<i;break;}} }return 0;} 版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/41148839	ACM-ICPC 2014 Beijing Warm-up (北京赛区热身赛)这次四道题好萌好萌……萌的裁判都一脸血……比赛是一次不错的经历，要好好把握锻炼的机会~这四题太萌了点反而觉得没有比赛的氛围不过C题做不出来还是深深感受到不足Q^Q明天要加油呢……我们比赛的时候问了这么个问题……然后被AllTeam广播回复了……紧接着就有人问也被公共频道回复了……简述题意：A题 ACM请数出整本题册中出现的所有“ACM”字符串（大小写均可）的个数。即数ACM在这本题册里出现了多少次，封面里的要算，封面贴图里的acm也要算，页眉页脚的也要算，题目里出现的甚至连这个问题中的ACM也要算，共26个。因为不知道这个算不算那个算不算诸如此类的问题，赛场中掀起一场提交狂潮，裁判机都哭了…… 裁判表示你们数数都数不对不能怪裁判机慢什么你要源码？Code：#include<iostream>using namespace std;int main(){cout<<26;return 0;}B题 Brilliant Prim-Number给一个数字，如果这个数字的质因数个数是质数，则输出Prim，反之输出Kruskal。先筛法筛1e5的素数（两个99997乘起来肯定大于1e9啦），然后？直接质因数分解数个数呗~ 这里需要注意的是素数都试完了之后还没有被分解过可能是超过1e5的大素数哦~Code:#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <vector>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;int prime[100050]={0},T,n;vector <int> pri;void init(){for(int i=2;i<100001;i++){if(prime[i]==0){pri.push_back(i);for(int j=i;j<=100000;j+=i) prime[j]=1;}}} int main(){init();cin>>T;for(int z=1;z<=T;z++){cin>>n;int ans=0;while(n!=1){for(int i=0;i<=pri.size()-1;i++){bool f=false;while(n%pri[i]==0){n=n/pri[i];if(!f)ans++;f=true;}}if(n>pri[pri.size()-1]){ans++;break;}}bool flag=false;for(int i=0;i<pri.size();i++){if(pri[i]==ans){flag=true;break;}else if(pri[i]>ans) break;}flag?printf("Case #%d: Prim!\n",z):printf("Case #%d: Kruskal!\n",z);}return 0;}C题 Construction题意为给定N，P，Q要求构造一个长度为N的数列，要求每相邻P个的和都为正，相邻Q个的和都为负。可构造则输出任意一组，不可构造则输出NoSolution当前想到的是这么几点：1） N>= (P+Q)+gcd(P,Q) 为NoSolution2）N>= [P,Q] 为NoSolution3）答案为PQ中较小的那个作为长度的一个小数组一直循环到N个的数列Code:暂缺D题 （题目叫啥我忘了不好意思……）这道题是一个编译模拟题，给一个GCC的程序问你结果是WA还是TLE……当时吓呆了简直……然后发现……HINT：只有一组测试数据，请大家放心大胆的猜答案吧……呃呃呃呃呃……因为组数T∈[1,3]，答案只有两种，WA或者TLE，所以最多试验2+4+8=14种必然有一个是结果。但是因为裁判机可以返回TLE和WA两种（如果可以PE和OLE就可以同时实验4种情况了可惜……），所以我们可以if(n==1||n==2) while(1)n++;来判断T的规模是多大。然后得知是T=3就是实验咯我们的顺序：TWT WAWTW WATTT WAWWW WATWW WATTW YES所以这道题也真是萌一脸……Code：#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;int main(){int T=0;cin>>T;for(int i=0;i<T;i++){int n=0;cin>>n;for(int j=0;j<n;j++){string str;getline(cin,str);} }cout<<"Case #1: Time Limit Exceeded!"<<endl;cout<<"Case #2: Time Limit Exceeded!"<<endl;cout<<"Case #3: Wrong Answer!"<<endl;return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/41019041	老师可萌可萌的~ 看下面的项目实验吐槽~就是编界面挺恼火的……QtCreator的界面打死我都不想再碰第二次……以前的Bug制造出强大的心灵阴影所以……废话不多说……START项目要求【重要部分代码说明】for(int i = 1; i <= n; i++)              {                  g.setFont(fontLetter);                  g.drawString("A", matrixXStart, YStart + di);                  matrixXStart = matrixXStart + 12;                  g.setFont(fontNumber);                  g.drawString(String.valueOf(i), matrixXStart, YStart + di);                  matrixXStart = matrixXStart + 10;                  g.setFont(fontLetter);                  g.drawString(": " + p[i - 1] + "*" + p[i] + " ", matrixXStart, YStart + di);                  matrixXStart = matrixXStart + di * 3/2;              }  仔细看这里，所使用的是drawString(str,xpos,ypos),三个参数分别为字符串，x坐标和y坐标。有了这个是不是就跟在PPT里写字符串一样了呢~for(int i = 1; i <= n; i++)          {              m[i][i] = 0;              int x = polygonArrayM[i][i].xpoints[0];              int y = polygonArrayM[i][i].ypoints[0];                            setColorAndFill(g, Color.GREEN, polygonArrayM[i][i]);              setColorAndDrawStr(g, Color.BLACK, m[i][i], x, y, 10, 5);              sleepAndPossiblePause(interval);          }  setColorAndFill，如同字面意思，把【Graphics g】，填充为某种颜色，第三个参数是polygon，就是我要画的是哪一个方块。setColorAndDrawStr则为填充颜色后把字符串（这里的m[i][i]是longlong型的）也扔上去。以上两个为自写函数，但只是合并调用减少代码长度罢了，如下： private void setColorAndFill(Graphics g, Color c, Polygon p)        {            g.setColor(c);            g.fillPolygon(p);            g.setColor(Color.BLACK);            g.drawPolygon(p);        }                private void setColorAndDrawStr(Graphics g, Color c, Object value, int x, int y, int xDeviation, int yDeviation)        {            g.setColor(c);            g.drawString(String.valueOf(value), x + xDeviation, y + yDeviation);        }        //睡眠并可能暂停      private void sleepAndPossiblePause(int interval)      {          try          {              Thread.sleep(interval);              synchronized(so)              {                  while(so.status.equals("1"))                  {                      so.wait();                  }              }          }          catch (InterruptedException e)          {              e.printStackTrace();          }      }  这个很方便的暂停函数是借鉴来的，十分的方便，代码倒是相当短啦~不过用在小游戏什么的里面作为pause使用应该也相当不错的。【源码】package pack;import java.awt.Color;  import java.awt.Container;  import java.awt.EventQueue;  import java.awt.Font;  import java.awt.Frame;  import java.awt.Graphics;  import java.awt.Polygon;  import java.awt.event.ActionEvent;  import java.awt.event.ActionListener;    import java.util.Scanner;import javax.swing.JButton;  import javax.swing.JComboBox;  import javax.swing.JFrame;  import javax.swing.JLabel;  import javax.swing.JOptionPane;  import javax.swing.JPanel;  import javax.swing.SwingUtilities;  import javax.swing.WindowConstants;        @SuppressWarnings("serial")public class MatrixChainGUI extends JFrame  {      int n;// Num of Rec      int di;//Length of dia_ratio      int XMStart;//M_Matrix left.xpos      int YStart;//Matrix left.pos    int xSStart;//S_Matrix left.xpos      int rstStrXStart;//Answer_xpos    Polygon[][] polygonArrayM;//m_Array      Polygon[][] polygonArrayS;//S_Array      int[] p;    JPanel charPanel;      @SuppressWarnings("rawtypes")JComboBox change;      JButton calculate = new JButton("开始/暂停");      Container pane;      DrawPolygon d;//drawP  //Rst_ WriteAnswer    DrawCalculateRst dr;      Thread algThread;  //Resume and Pause    PauseOrResume pOR;      Thread pORThread;      SynObj so = new SynObj();//用以同步      int interval; //speed    boolean awake = false;//init     Font fontLetter = new Font("letter", 0, 18);    Font fontNumber = new Font("number", 0, 10);      Font fontBracket = new Font("number", 0, 17);      @SuppressWarnings({ "unchecked", "rawtypes" })public MatrixChainGUI(int[] p, int di)      {          super();          n = p.length - 1;          if(n <= 2)          {              JOptionPane.showMessageDialog(MatrixChainGUI.this,                     "矩阵数目最少为3", "", JOptionPane.ERROR_MESSAGE);              System.exit(0);          }          this.p = p;          this.di = di;          XMStart = di/2;          YStart = di * (n+2)/2;          xSStart = XMStart + n*di;          rstStrXStart = XMStart;          polygonArrayM = new Polygon[n+1][n+1];          polygonArrayS = new Polygon[n+1][n+1];                    pane = this.getContentPane();          d = new DrawPolygon();          d.setIgnoreRepaint(true);          charPanel = new JPanel();          String str[] = { "1", "2", "3" };          change = new JComboBox(str);          charPanel.add(new JLabel("速度："));          charPanel.add(change);          charPanel.add(calculate);          pane.add("South", charPanel);          pane.add("Center", d);                    calculate.addActionListener(new ActionListener()          {              public void actionPerformed(ActionEvent arg0)               {                  if(so.status.equals("0"))                  {                      pOR = new PauseOrResume();                      pORThread = new Thread(pOR);                      pORThread.start();//pause of resume Thread                                          if(change.getSelectedItem().toString().equals("1"))                      {                          interval = 1000;                      }                      else if(change.getSelectedItem().toString().equals("2"))                      {                          interval = 600;                      }                      else                      {                          interval = 200;                      }                      dr = new DrawCalculateRst();                      pane.add(dr);                      algThread = new Thread(dr);                      algThread.start();//Calculate Thread                }                  //judge status                else if(so.status.equals("2") || so.status.equals("1"))                  {                      awake = true;                  }              }          });      }            public class DrawPolygon extends JPanel      {          public void paintComponent(Graphics g)          {              super.paintComponents(g);              //PAINT Matrix_M            int outCount = 1;              int q = 0;//纵坐标偏移单位              while(outCount < n + 1)              {                  int inCount = 1;                  int p = 0;//横坐标偏移单位                  int j = outCount, i = 1;                  while(inCount < n + 2 - outCount)                  {                      int X[] = {XMStart+di*p+di/2*q,XMStart+di/2+di*p+di/2*q,XMStart+di+di*p+di/2*q,XMStart+di/2+di*p+di/2*q};                      int Y[] = {YStart-di/2*q,YStart+di/2-di/2*q,YStart-di/2*q,YStart-di/2-di/2*q};                      polygonArrayM[i][j] = new Polygon(X,Y,4);                      g.drawPolygon(polygonArrayM[i][j]);                      p++; i++; j++; inCount++;                  }                  q++; outCount++;              }                            g.drawString("Matrix M_ij\n(m)", XMStart + di * n/2 - 25 , YStart - di * (n + 1)/2);                            //Paint No.            for(int i = 1; i <= n; i++)              {                  int xl = polygonArrayM[1][i].xpoints[0];                  int yl = polygonArrayM[1][i].ypoints[0];                  int xr = polygonArrayM[i][n].xpoints[0];                  int yr = polygonArrayM[i][n].ypoints[0];                                    setColorAndDrawStr(g, Color.BLACK, i, xl, yl, 0, -9*di/25);                  setColorAndDrawStr(g, Color.BLACK, i, xr, yr, 4*di/5, -9*di/25);              }                            //Paint Axis            int midv=n/2;            int xj = polygonArrayM[1][midv].xpoints[0] -75;              int yj = polygonArrayM[1][midv].ypoints[0] +25;              int xi = polygonArrayM[midv+1][n].xpoints[0] ;              int yi = polygonArrayM[midv+1][n].ypoints[0] + 25;                            setColorAndDrawStr(g, Color.BLACK, "Matrix M_ij\n(j)", xj, yj, 0, -di);              setColorAndDrawStr(g, Color.BLACK, "Matrix M_ij\n(i)", xi, yi, di, -di);                            //Paint Matrix_S              int outCount1 = 2;              int q1 = 1;//纵坐标偏移单位              while(outCount1 < n + 1)              {                  int inCount = 1;                  int p = 1;//横坐标偏移单位                  int j = outCount1, i = 1;                  while(inCount < n + 2 - outCount1)                  {                      int X[] = {xSStart+di*p+di/2*q1,xSStart+di/2+di*p+di/2*q1,xSStart+di+di*p+di/2*q1,xSStart+di/2+di*p+di/2*q1};                      int Y[] = {YStart-di/2*q1,YStart+di/2-di/2*q1,YStart-di/2*q1,YStart-di/2-di/2*q1};                      polygonArrayS[i][j] = new Polygon(X,Y,4);                      g.drawPolygon(polygonArrayS[i][j]);                      p++; i++; j++; inCount++;                  }                  q1++; outCount1++;              }                            g.drawString("Value Matrix of S", xSStart + di * (n + 2)/2 - 50, YStart - di * (n + 1)/2);                            //绘制s值编号              for(int i = 2; i <= n; i++)              {                  int xl = polygonArrayS[1][i].xpoints[0];                  int yl = polygonArrayS[1][i].ypoints[0];                                    setColorAndDrawStr(g, Color.BLACK, i, xl, yl, 0, -9*di/25);              }              for(int i = 1; i <= n - 1; i++)              {                    int xr = polygonArrayS[i][n].xpoints[0];                  int yr = polygonArrayS[i][n].ypoints[0];                                    setColorAndDrawStr(g, Color.BLACK, i, xr, yr, 4*di/5, -9*di/25);              }                            int matrixXStart = XMStart;              g.setFont(fontLetter);          g.drawString("[CD's HINT]: \t       [ Green ]   Already Calculated ", matrixXStart, YStart + di*9/3);        g.drawString("[IOTClass1]: \t       [ Yellow]   Now is Calculating ", matrixXStart, YStart + di*10/3);        g.drawString("[20125209]: \t        [ Pink ]   Calculating Related", matrixXStart, YStart + di*11/3);              for(int i = 1; i <= n; i++)              {                  g.setFont(fontLetter);                  g.drawString("A", matrixXStart, YStart + di);                  matrixXStart = matrixXStart + 12;                  g.setFont(fontNumber);                  g.drawString(String.valueOf(i), matrixXStart, YStart + di);                  matrixXStart = matrixXStart + 10;                  g.setFont(fontLetter);                  g.drawString(": " + p[i - 1] + "*" + p[i] + " ", matrixXStart, YStart + di);                  matrixXStart = matrixXStart + di * 3/2;              }               }      }            public class SynObj      {          String status = "0";      }            public class DrawCalculateRst extends JPanel implements Runnable      {          public void run()           {              synchronized(so)              {                  so.status = "2";              }              matrixChainMul(d.getGraphics());          }      }            public class PauseOrResume implements Runnable      {            public void run()           {              while(true)              {                  while(!awake)                  {                      try                       {                          Thread.sleep(50);                      }                       catch (InterruptedException e)                       {                          e.printStackTrace();                      }                  }                  // Runtime Set                if(so.status.equals("1"))                  {                      if(change.getSelectedItem().toString().equals("1"))                      {                          interval = 1000;                     }                      else if(change.getSelectedItem().toString().equals("2"))                      {                          interval = 600;                      }                      else                      {                          interval = 200;                      }                      synchronized(so)                      {                          so.status = "2";                          so.notifyAll();                      }                  }                  else if(so.status.equals("2"))                  {                      so.status = "1";                  }                  awake = false;              }          }                }            //Main Algorithm Here     public void matrixChainMul(Graphics g)       {          long[][] m = new long[n + 1][n + 1];          int[][] s = new int[n][n + 1];                    for(int i = 1; i <= n; i++)          {              m[i][i] = 0;              int x = polygonArrayM[i][i].xpoints[0];              int y = polygonArrayM[i][i].ypoints[0];                            setColorAndFill(g, Color.GREEN, polygonArrayM[i][i]);              setColorAndDrawStr(g, Color.BLACK, m[i][i], x, y, 10, 5);              sleepAndPossiblePause(interval);          }                    for(int l = 2; l <= n; l++)          {              for(int i = 1; i <= n - l + 1; i++)              {                  int j = i + l - 1;                  m[i][j] =  Integer.MAX_VALUE;                  int x = polygonArrayM[i][j].xpoints[0];                  int y = polygonArrayM[i][j].ypoints[0];                  int xs = polygonArrayS[i][j].xpoints[0];                  int ys = polygonArrayS[i][j].ypoints[0];                  setColorAndFill(g, Color.YELLOW, polygonArrayM[i][j]);                  setColorAndFill(g, Color.YELLOW, polygonArrayS[i][j]);                                    sleepAndPossiblePause(interval);                                    for(int k = i; k <= j - 1; k++)                  {                      int x1 = polygonArrayM[i][k].xpoints[0];                      int y1 = polygonArrayM[i][k].ypoints[0];                      int x2 = polygonArrayM[k+1][j].xpoints[0];                      int y2 = polygonArrayM[k+1][j].ypoints[0];                      setColorAndFill(g, Color.PINK, polygonArrayM[i][k]);                      setColorAndDrawStr(g, Color.BLACK, m[i][k], x1, y1, 10, 5);                      setColorAndFill(g, Color.PINK, polygonArrayM[k+1][j]);                      setColorAndDrawStr(g, Color.BLACK, m[k+1][j], x2, y2, 10, 5);                      long q = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j];                      if(q < m[i][j])                      {                          m[i][j] = q;                          s[i][j] = k;                      }                                            sleepAndPossiblePause(interval);                                            setColorAndFill(g, Color.GREEN, polygonArrayM[i][k]);                      setColorAndDrawStr(g, Color.BLACK, m[i][k], x1, y1, 10, 5);                      setColorAndFill(g, Color.GREEN, polygonArrayM[k+1][j]);                      setColorAndDrawStr(g, Color.BLACK, m[k+1][j], x2, y2, 10, 5);                  }                  setColorAndFill(g, Color.GREEN, polygonArrayM[i][j]);                  setColorAndDrawStr(g, Color.BLACK, m[i][j], x, y, 10, 5);                  setColorAndFill(g, Color.GREEN, polygonArrayS[i][j]);                  setColorAndDrawStr(g, Color.BLACK, s[i][j], xs, ys, 10, 5);                                    sleepAndPossiblePause(interval);              }          }                  g.drawString("最优的加括号的序列： ", rstStrXStart, YStart + di * 2);          rstStrXStart = rstStrXStart + 120;          printRstSequence(s, 1, n, g);      }            //Paint Answer    public void printRstSequence(int[][] s, int i, int j, Graphics g)      {          if(i == j)           {              g.setFont(fontLetter);              g.drawString("A", rstStrXStart, YStart + di * 2);              rstStrXStart = rstStrXStart + di/4;              g.setFont(fontNumber);              g.drawString(String.valueOf(i), rstStrXStart, YStart + di * 2);              rstStrXStart = rstStrXStart + di/4;              System.out.print("A" + i + " ");          }          else          {             g.setFont(fontBracket);              g.drawString("(", rstStrXStart, YStart + di * 2);              rstStrXStart = rstStrXStart + di/4;              System.out.print("(");              printRstSequence(s, i, s[i][j], g);              printRstSequence(s, s[i][j] + 1, j, g);              g.setFont(fontBracket);              g.drawString(")", rstStrXStart, YStart + di * 2);              rstStrXStart = rstStrXStart + di/4;              System.out.print(")");          }      }            //Set Sleep(Pause) Status    private void sleepAndPossiblePause(int interval)      {          try          {              Thread.sleep(interval);              synchronized(so)              {                  while(so.status.equals("1"))                  {                      so.wait();                  }              }          }          catch (InterruptedException e)          {              e.printStackTrace();          }      }        private void setColorAndFill(Graphics g, Color c, Polygon p)      {          g.setColor(c);          g.fillPolygon(p);          g.setColor(Color.BLACK);          g.drawPolygon(p);      }            private void setColorAndDrawStr(Graphics g, Color c, Object value, int x, int y, int xDeviation, int yDeviation)      {          g.setColor(c);          g.drawString(String.valueOf(value), x + xDeviation, y + yDeviation);      }            private static class FrameShower implements Runnable       {                      private final Frame frame;                    FrameShower(Frame frame)           {            this.frame = frame;          }                    public void run()           {           frame.setVisible(true);          }                }               public static void main(String[] args)      {          SwingUtilities.invokeLater(new Runnable()          {              public void run()               {              Scanner in=new Scanner(System.in);                //矩阵行列数组              //int[] p = {27, 33, 20, 18, 15, 18, 25};              System.out.println("Please tell me how many matrix are there?(Recommend 6~15)");                int vnum=in.nextInt();                int [] p=new int[vnum+1];                System.out.println("Please input values of these Matrix Size:");            System.out.printf("(Hint: %d matrix need %d numbers)\n",vnum,vnum+1);                for(int i=0;i<p.length;i++)                {                int tmp=in.nextInt();                if(tmp<=0){System.out.println("Invalid Input!");break;}                p[i]=tmp;                }                int di = 50;                  int n = p.length - 1;                  MatrixChainGUI c = new MatrixChainGUI(p, di);                  c.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);                  c.pack();                  c.setSize(di * (2 * n + 2), di * (n+2)/2 + 280);                  c.setResizable(false);                  c.setTitle("MatrixChain_DP By CD_20125209");                  EventQueue.invokeLater(new FrameShower(c));                  System.out.println("单文件JAVA_GUI矩阵链动态规划算法演示结束，友情提示：这个可以打高分^_^");                System.out.println("作者：陈点 物联网1班 20125209");            }          });      }  }  【运行演示】【源码超·中文注释完全版】 package pack;import java.awt.Color;  import java.awt.Container;  import java.awt.EventQueue;  import java.awt.Font;  import java.awt.Frame;  import java.awt.Graphics;  import java.awt.Polygon;  import java.awt.event.ActionEvent;  import java.awt.event.ActionListener;    import java.util.Scanner;import javax.swing.JButton;  import javax.swing.JComboBox;  import javax.swing.JFrame;  import javax.swing.JLabel;  import javax.swing.JOptionPane;  import javax.swing.JPanel;  import javax.swing.SwingUtilities;  import javax.swing.WindowConstants;        @SuppressWarnings("serial")public class MatrixChainGUI extends JFrame  {      int n;//矩阵个数      int di;//正方形斜对角线长      int XMStart;//m值菱形数组最左边的x坐标      int YStart;//菱形数组最左边的y坐标      int xSStart;//s值菱形数组最左边的x坐标      int rstStrXStart;//最优加括号矩阵链起始横坐标      Polygon[][] polygonArrayM;//m值菱形数组      Polygon[][] polygonArrayS;//s值菱形数组      int[] p;      JPanel charPanel;      @SuppressWarnings("rawtypes")JComboBox change;      JButton calculate = new JButton("开始/暂停");      Container pane;      DrawPolygon d;//画表格      DrawCalculateRst dr;//计算并向屏幕写结果的任务      Thread algThread;//计算向屏幕写结果的线程      PauseOrResume pOR;//暂停、恢复的任务      Thread pORThread;//暂停、恢复的线程      SynObj so = new SynObj();//用以同步      int interval;//计算速度      boolean awake = false;//暂停、恢复计算线程初始化为睡眠状态      Font fontLetter = new Font("letter", 0, 18);//字母字体      Font fontNumber = new Font("number", 0, 10);//角标字体      Font fontBracket = new Font("number", 0, 17);//括号字体      @SuppressWarnings({ "unchecked", "rawtypes" })public MatrixChainGUI(int[] p, int di)      {          super();          n = p.length - 1;          if(n <= 2)          {              JOptionPane.showMessageDialog(MatrixChainGUI.this,                     "矩阵数目最少为3", "", JOptionPane.ERROR_MESSAGE);              System.exit(0);          }          this.p = p;          this.di = di;          XMStart = di/2;//m值菱形数组最左边的x坐标          YStart = di * (n+2)/2;//菱形数组最左边的y坐标          xSStart = XMStart + n*di;//s值菱形数组最左边的x坐标          rstStrXStart = XMStart;//最优加括号矩阵链起始横坐标          polygonArrayM = new Polygon[n+1][n+1];//m值菱形数组          polygonArrayS = new Polygon[n+1][n+1];//s值菱形数组                    pane = this.getContentPane();          d = new DrawPolygon();          d.setIgnoreRepaint(true);          charPanel = new JPanel();          String str[] = { "1", "2", "3" };          change = new JComboBox(str);          charPanel.add(new JLabel("速度："));          charPanel.add(change);          charPanel.add(calculate);          pane.add("South", charPanel);          pane.add("Center", d);                    calculate.addActionListener(new ActionListener()          {              public void actionPerformed(ActionEvent arg0)               {                  if(so.status.equals("0"))                  {                      pOR = new PauseOrResume();                      pORThread = new Thread(pOR);                      pORThread.start();//启动暂停或恢复计算的线程                                            if(change.getSelectedItem().toString().equals("1"))                      {                          interval = 1000;                      }                      else if(change.getSelectedItem().toString().equals("2"))                      {                          interval = 600;                      }                      else                      {                          interval = 200;                      }                      dr = new DrawCalculateRst();                      pane.add(dr);                      algThread = new Thread(dr);                      algThread.start();//启动开始计算的线程                  }                  //若正在运行，则进入暂停状态;若已经暂停，则恢复                  else if(so.status.equals("2") || so.status.equals("1"))                  {                      awake = true;                  }              }          });      }            public class DrawPolygon extends JPanel      {          public void paintComponent(Graphics g)          {              super.paintComponents(g);                            //绘制m值表格              int outCount = 1;              int q = 0;//纵坐标偏移单位              while(outCount < n + 1)              {                  int inCount = 1;                  int p = 0;//横坐标偏移单位                  int j = outCount, i = 1;                  while(inCount < n + 2 - outCount)                  {                      int X[] = {XMStart+di*p+di/2*q,XMStart+di/2+di*p+di/2*q,XMStart+di+di*p+di/2*q,XMStart+di/2+di*p+di/2*q};                      int Y[] = {YStart-di/2*q,YStart+di/2-di/2*q,YStart-di/2*q,YStart-di/2-di/2*q};                      polygonArrayM[i][j] = new Polygon(X,Y,4);                      g.drawPolygon(polygonArrayM[i][j]);                      p++;                      i++;                      j++;                      inCount++;                  }                  q++;                  outCount++;              }                            g.drawString("Matrix M_ij\n(m)", XMStart + di * n/2 - 25 , YStart - di * (n + 1)/2);                            //绘制m值编号              for(int i = 1; i <= n; i++)              {                  int xl = polygonArrayM[1][i].xpoints[0];                  int yl = polygonArrayM[1][i].ypoints[0];                  int xr = polygonArrayM[i][n].xpoints[0];                  int yr = polygonArrayM[i][n].ypoints[0];                                    setColorAndDrawStr(g, Color.BLACK, i, xl, yl, 0, -9*di/25);                  setColorAndDrawStr(g, Color.BLACK, i, xr, yr, 4*di/5, -9*di/25);              }                            //绘制i，j字母              int midv=n/2;            int xj = polygonArrayM[1][midv].xpoints[0] -75;              int yj = polygonArrayM[1][midv].ypoints[0] +25;              int xi = polygonArrayM[midv+1][n].xpoints[0] ;              int yi = polygonArrayM[midv+1][n].ypoints[0] + 25;                            setColorAndDrawStr(g, Color.BLACK, "Matrix M_ij\n(j)", xj, yj, 0, -di);              setColorAndDrawStr(g, Color.BLACK, "Matrix M_ij\n(i)", xi, yi, di, -di);                            //绘制s值表格              int outCount1 = 2;              int q1 = 1;//纵坐标偏移单位              while(outCount1 < n + 1)              {                  int inCount = 1;                  int p = 1;//横坐标偏移单位                  int j = outCount1, i = 1;                  while(inCount < n + 2 - outCount1)                  {                      int X[] = {xSStart+di*p+di/2*q1,xSStart+di/2+di*p+di/2*q1,xSStart+di+di*p+di/2*q1,xSStart+di/2+di*p+di/2*q1};                      int Y[] = {YStart-di/2*q1,YStart+di/2-di/2*q1,YStart-di/2*q1,YStart-di/2-di/2*q1};                      polygonArrayS[i][j] = new Polygon(X,Y,4);                      g.drawPolygon(polygonArrayS[i][j]);                      p++;                      i++;                      j++;                      inCount++;                  }                  q1++;                  outCount1++;              }                            g.drawString("Value Matrix of S", xSStart + di * (n + 2)/2 - 50, YStart - di * (n + 1)/2);                            //绘制s值编号              for(int i = 2; i <= n; i++)              {                  int xl = polygonArrayS[1][i].xpoints[0];                  int yl = polygonArrayS[1][i].ypoints[0];                                    setColorAndDrawStr(g, Color.BLACK, i, xl, yl, 0, -9*di/25);              }              for(int i = 1; i <= n - 1; i++)              {                    int xr = polygonArrayS[i][n].xpoints[0];                  int yr = polygonArrayS[i][n].ypoints[0];                                    setColorAndDrawStr(g, Color.BLACK, i, xr, yr, 4*di/5, -9*di/25);              }                            int matrixXStart = XMStart;              g.setFont(fontLetter);          g.drawString("[CD's HINT]: \t       [ Green ]   Already Calculated ", matrixXStart, YStart + di*9/3);        g.drawString("[IOTClass1]: \t       [ Yellow]   Now is Calculating ", matrixXStart, YStart + di*10/3);        g.drawString("[20125209]: \t        [ Blue ]   Calculating Related", matrixXStart, YStart + di*11/3);              for(int i = 1; i <= n; i++)              {                  g.setFont(fontLetter);                  g.drawString("A", matrixXStart, YStart + di);                  matrixXStart = matrixXStart + 12;                  g.setFont(fontNumber);                  g.drawString(String.valueOf(i), matrixXStart, YStart + di);                  matrixXStart = matrixXStart + 10;                  g.setFont(fontLetter);                  g.drawString(": " + p[i - 1] + "*" + p[i] + " ", matrixXStart, YStart + di);                  matrixXStart = matrixXStart + di * 3/2;              }               }      }            public class SynObj      {          String status = "0";      }            public class DrawCalculateRst extends JPanel implements Runnable      {          public void run()           {              synchronized(so)              {                  so.status = "2";              }              matrixChainMul(d.getGraphics());          }      }            public class PauseOrResume implements Runnable      {            public void run()           {              while(true)              {                  while(!awake)                  {                      try                       {                          Thread.sleep(50);                      }                       catch (InterruptedException e)                       {                          e.printStackTrace();                      }                  }                  if(so.status.equals("1"))                  {                      if(change.getSelectedItem().toString().equals("1"))                      {                          interval = 1000;                      }                      else if(change.getSelectedItem().toString().equals("2"))                      {                          interval = 600;                      }                      else                      {                          interval = 200;                      }                      synchronized(so)                      {                          so.status = "2";                          so.notifyAll();                      }                  }                  else if(so.status.equals("2"))                  {                      so.status = "1";                  }                  awake = false;              }          }                }            //矩阵链乘法最优算序寻找算法      public void matrixChainMul(Graphics g)       {          long[][] m = new long[n + 1][n + 1];          int[][] s = new int[n][n + 1];                    for(int i = 1; i <= n; i++)          {              m[i][i] = 0;              int x = polygonArrayM[i][i].xpoints[0];              int y = polygonArrayM[i][i].ypoints[0];                            setColorAndFill(g, Color.GREEN, polygonArrayM[i][i]);              setColorAndDrawStr(g, Color.BLACK, m[i][i], x, y, 10, 5);              sleepAndPossiblePause(interval);          }                    for(int l = 2; l <= n; l++)          {              for(int i = 1; i <= n - l + 1; i++)              {                  int j = i + l - 1;                  m[i][j] =  Integer.MAX_VALUE;                  int x = polygonArrayM[i][j].xpoints[0];                  int y = polygonArrayM[i][j].ypoints[0];                  int xs = polygonArrayS[i][j].xpoints[0];                  int ys = polygonArrayS[i][j].ypoints[0];                  setColorAndFill(g, Color.YELLOW, polygonArrayM[i][j]);                  setColorAndFill(g, Color.YELLOW, polygonArrayS[i][j]);                                    sleepAndPossiblePause(interval);                                    for(int k = i; k <= j - 1; k++)                  {                      int x1 = polygonArrayM[i][k].xpoints[0];                      int y1 = polygonArrayM[i][k].ypoints[0];                      int x2 = polygonArrayM[k+1][j].xpoints[0];                      int y2 = polygonArrayM[k+1][j].ypoints[0];                      setColorAndFill(g, Color.BLUE, polygonArrayM[i][k]);                      setColorAndDrawStr(g, Color.BLACK, m[i][k], x1, y1, 10, 5);                      setColorAndFill(g, Color.BLUE, polygonArrayM[k+1][j]);                      setColorAndDrawStr(g, Color.BLACK, m[k+1][j], x2, y2, 10, 5);                      long q = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j];                      if(q < m[i][j])                      {                          m[i][j] = q;                          s[i][j] = k;                      }                                            sleepAndPossiblePause(interval);                                            setColorAndFill(g, Color.GREEN, polygonArrayM[i][k]);                      setColorAndDrawStr(g, Color.BLACK, m[i][k], x1, y1, 10, 5);                      setColorAndFill(g, Color.GREEN, polygonArrayM[k+1][j]);                      setColorAndDrawStr(g, Color.BLACK, m[k+1][j], x2, y2, 10, 5);                  }                  setColorAndFill(g, Color.GREEN, polygonArrayM[i][j]);                  setColorAndDrawStr(g, Color.BLACK, m[i][j], x, y, 10, 5);                  setColorAndFill(g, Color.GREEN, polygonArrayS[i][j]);                  setColorAndDrawStr(g, Color.BLACK, s[i][j], xs, ys, 10, 5);                                    sleepAndPossiblePause(interval);              }          }                              g.drawString("最优的加括号的序列： ", rstStrXStart, YStart + di * 2);          rstStrXStart = rstStrXStart + 120;          printRstSequence(s, 1, n, g);      }            //打印加括号顺序      public void printRstSequence(int[][] s, int i, int j, Graphics g)      {          if(i == j)           {              g.setFont(fontLetter);              g.drawString("A", rstStrXStart, YStart + di * 2);              rstStrXStart = rstStrXStart + di/4;              g.setFont(fontNumber);              g.drawString(String.valueOf(i), rstStrXStart, YStart + di * 2);              rstStrXStart = rstStrXStart + di/4;              System.out.print("A" + i + " ");          }          else          {             g.setFont(fontBracket);              g.drawString("(", rstStrXStart, YStart + di * 2);              rstStrXStart = rstStrXStart + di/4;              System.out.print("(");              printRstSequence(s, i, s[i][j], g);              printRstSequence(s, s[i][j] + 1, j, g);              g.setFont(fontBracket);              g.drawString(")", rstStrXStart, YStart + di * 2);              rstStrXStart = rstStrXStart + di/4;              System.out.print(")");          }      }            //睡眠并可能暂停      private void sleepAndPossiblePause(int interval)      {          try          {              Thread.sleep(interval);              synchronized(so)              {                  while(so.status.equals("1"))                  {                      so.wait();                  }              }          }          catch (InterruptedException e)          {              e.printStackTrace();          }      }        private void setColorAndFill(Graphics g, Color c, Polygon p)      {          g.setColor(c);          g.fillPolygon(p);          g.setColor(Color.BLACK);          g.drawPolygon(p);      }            private void setColorAndDrawStr(Graphics g, Color c, Object value, int x, int y, int xDeviation, int yDeviation)      {          g.setColor(c);          g.drawString(String.valueOf(value), x + xDeviation, y + yDeviation);      }            private static class FrameShower implements Runnable       {                      private final Frame frame;                    FrameShower(Frame frame)           {            this.frame = frame;          }                    public void run()           {           frame.setVisible(true);          }                }               public static void main(String[] args)      {          SwingUtilities.invokeLater(new Runnable()          {              public void run()               {              Scanner in=new Scanner(System.in);                //矩阵行列数组              //int[] p = {27, 33, 20, 18, 15, 18, 25};              System.out.println("Please tell me how many matrix are there?(Recommend 6~15)");                int vnum=in.nextInt();                int [] p=new int[vnum+1];                System.out.println("Please input values of these Matrix Size:");            System.out.printf("(Hint: %d matrix need %d numbers)\n",vnum,vnum+1);                for(int i=0;i<p.length;i++)                {                int tmp=in.nextInt();                if(tmp<=0){System.out.println("Invalid Input!");break;}                p[i]=tmp;                }                int di = 50;                  int n = p.length - 1;                  MatrixChainGUI c = new MatrixChainGUI(p, di);                  c.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);                  c.pack();                  c.setSize(di * (2 * n + 2), di * (n+2)/2 + 280);                  c.setResizable(false);                  c.setTitle("MatrixChain_DP By CD_20125209");                  EventQueue.invokeLater(new FrameShower(c));                  System.out.println("单文件JAVA_GUI矩阵链动态规划算法演示结束，友情提示：这个可以打高分^_^");                System.out.println("作者：陈点 物联网1班 20125209");            }          });      }  }  ==== 部分非原创说明 ====（以下提及的辅助函数中注释大多为xglv2013的函数自带注释）此版本依照 software8_co的 Swing动态演示中的· “线程”概念 （线程函数摘自网络教程）· 三速切换控制 （此函数摘自xglv）版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/40950637	 ﻿#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <pthread.h>//线程1用来求1~n之间的素数void *MyThread1(void){   int n;   int h=0,leap=1,k,m,i;   printf("[pid_prime]input the value of n:\n");//输入n的值   scanf("%d",&n);    printf("the prime number between 1~%d is:\n",n);   for(m=2;m<=n;m++)  {       // k=sqrt(m+1);        for(i=2;i<=m/2;i++)        {            if(m%i==0)            {               leap=0;break;            }          }         if(leap)      {         printf("%4d",m);         h++;        if(h%10==0)           printf("\n");      }    leap=1;  }  printf("\nthread1 exit!\n");//线程1退出  pthread_exit(0);}//线程2用来求fib序列void *MyThread2(void){   int fib0=0,fib1=1,fib2,i,N;    printf("[pid_fib]input the value of N:\n");//输入N的值   scanf("%d",&N);   printf("the fib sequence as following:\n");   for(i=0;i<N;i++)   {      if(i==0)      {         printf("0 ");       }       else if(i==1)       {           printf("1 ");       }       else       {          fib2=fib0+fib1;          printf("%d ",fib2);          fib0=fib1;          fib1=fib2;        }   }    printf("\nthread2 exit!\n");//线程2退出    pthread_exit(0);}//线程3用来求闰年void *MyThread3(void){int year=0;printf("[pid_run]input the value of year:\n");//输入n的值scanf("%d",&year);if(year%4!=0){ printf("%d is not a 闰年\n",year);}else{ if(year%100!=0) printf("%d is a 闰年\n",year); else  {  if(year%400==0) printf("%d is a 闰年\n",year);  else printf("%d is not a 闰年\n",year); }}    printf("\nthread3 exit!\n");//线程3退出    pthread_exit(0);}//线程4用来求回文void *MyThread4(void){int num=0;printf("[pid_palid]input the value of num:\n");//输入num的值scanf("%d",&num);int a1=num/10000;int a2=num/1000%10;int a3=num/10%10;int a4=num%10;if(a1==a4 && a2==a3) printf("number %d is a palindome\n",num);else printf("number %d is not a palindome\n",num);    printf("\nthread4 exit!\n");//线程4退出    pthread_exit(0);}//主线程来创建两个线程int mainthread(){    int ret1=0,ret2=0,ret3=0,ret4=0;    pthread_t id1,id2,id3,id4;//定义两个线程id   //调用pthread_create()函数来创建线程1   ret1=pthread_create(&id1,NULL,(void*)MyThread1,NULL);   //ret1=0表示创建成功，否则表示出错   if(ret1)   {       //如果出错就打印错误信息       printf("Create pthread error!\n");     return 1;   }   //调用pthread_create()函数来创建线程2   ret2=pthread_create(&id2,NULL,(void*)MyThread2,NULL);   //ret2=0表示创建成功，否则表示出错   if(ret2)   {       //如果出错就打印错误信息       printf("Create pthread error!\n");       return 1;   }   //调用pthread_create()函数来创建线程3   ret3=pthread_create(&id3,NULL,(void*)MyThread3,NULL);   //ret3=0表示创建成功，否则表示出错    if(ret3)   {     //如果出错就打印错误信息     printf("Create pthread error!\n");     return 1;   }   //调用pthread_create()函数来创建线程4   ret4=pthread_create(&id4,NULL,(void*)MyThread4,NULL);   //ret4=0表示创建成功，否则表示出错    if(ret4)   {     //如果出错就打印错误信息     printf("Create pthread error!\n");     return 1;   }  pthread_join(id1,NULL);//主线程等待线程1结束  pthread_join(id2,NULL);//主线程等待线程2结束  pthread_join(id3,NULL);//主线程等待线程3结束  pthread_join(id4,NULL);//主线程等待线程4结束  printf("main thread exit!\n");//主线程退出  return 0;  }//被4号进程创建的两个子进程分别调用下面这个函数来完成不同的任务//CD：现在是仨进程了void childfun(int i){    switch(i)    {      case 5 : printf("This is NO.5 process,ID is %d,parent ID is %d,will create 2 thread\n",getpid(),getppid());               mainthread();//调用线程创建的函数               break;      case 6 : printf("This is NO.6 process,ID is %d,parent ID is %d,will execute ./proc2 \n",getpid(),getppid());              //用execl来执行用户写的可执行文件proc2              execl("proc2","./proc2",NULL);              break;case 7 : printf("This is NO.7 process,ID is %d,parent ID is %d,will execute ./proc2 \n",getpid(),getppid());break;    }    exit(0);}int createprocess()  //4号进程来创建两个子进程{  int i;  for(i=5;i<=7;i++)  {      pid_t child;      child=fork();      //创建失败      if(child==-1)    {      printf("Error happened in fork function!\n");      return 0;    }   //子进程的返回值为0,   else if(child==0)   {      childfun(i);//调用这个函数来分别让进程执行不同的程序   } }  for(i=0;i<3;i++) {   //进程等待其子进程的退出   pid_t cpid=wait(NULL);   printf("the process %d exit\n",cpid); }   return 0;}//父进程创建的两个进程分别调用下面函数来完成不同的任务//CD:现在是三个进程了，多了个2void fun(int i){    switch(i)    {case 2 : printf("this is NO.2 process,ID is %d,parent ID is %d,will execute command: ls -l:\n",getpid(),getppid());// NAME.ID.PID is okbreak;      case 3 : printf("this is NO.3 process,ID is %d,parent ID is %d,will execute command: ls -l:\n",getpid(),getppid());               //3号进程调用execl函数来执行ls -l命令               execl("/bin/ls","ls","-l",NULL);               break;      case 4 : printf("I am NO.4 process,ID is %d,parent ID is %d,will create 2 process\n",getpid(),getppid());                createprocess();//4号进程调用这个函数来创建两个子进程               break;    }    exit(0);}int main(){  int i;  for(i=2;i<=4;i++)  {      pid_t child;      child=fork();//调用fork函数来创建子进程     //创建失败      if(child==-1)    {      printf("Error happened in fork function!\n");      return 0;    }   //子进程的返回值为0,   else if(child==0)   {      printf("process ID is %d:\n",getpid());      fun(i);   } } for(i=0;i<3;i++) {   //父进程等待子进程的退出   pid_t cpid=wait(NULL);   printf("The process %d exit\n",cpid); }  //最后父进程退出  printf("The NO.1 parent process ID is %d exit\n",getpid());   return 0;} Terminal 调试过程_Logcatcqu@cqu:~$ lscd                Linux  公共的  视频  文档  音乐examples.desktop  lyh    模板    图片  下载  桌面cqu@cqu:~$ cd cdcqu@cqu:~/cd$ lsexp2  exp2.c  proc2  proc2.c  process  process.ccqu@cqu:~/cd$ gcc exp2.c -lpthread -o exp2cqu@cqu:~/cd$ ./exp2process ID is 2713:this is NO.2 process,ID is 2713,parent ID is 2712,will execute command: ls -l:The process 2713 exitprocess ID is 2714:this is NO.3 process,ID is 2714,parent ID is 2712,will execute command: ls -l:总计 52-rwxr-xr-x 1 cqu cqu 11935 2014-11-09 16:17 exp2-rwxr--r-- 1 cqu cqu  6390 2014-11-09 16:17 exp2.c-rwxrw-rw- 1 cqu cqu  7159 2014-11-09 15:04 proc2-rwxrw-rw- 1 cqu cqu    75 2014-11-09 15:04 proc2.c-rwxrw-rw- 1 cqu cqu 11890 2014-11-09 15:04 process-rwxrw-rw- 1 cqu cqu  4466 2014-11-09 15:04 process.cThe process 2714 exitprocess ID is 2715:I am NO.4 process,ID is 2715,parent ID is 2712,will create 2 processThis is NO.6 process,ID is 2717,parent ID is 2715,will execute ./proc2 Hello world!the process 2717 exitThis is NO.7 process,ID is 2718,parent ID is 2715,will execute ./proc2 the process 2718 exitThis is NO.5 process,ID is 2716,parent ID is 2715,will create 2 thread[pid_fib]input the value of N:[pid_run]input the value of year:[pid_prime]input the value of n:[pid_palid]input the value of num:5the fib sequence as following:0 1 1 2 3 thread2 exit!12341234 is not a 闰年thread3 exit!15the prime number between 1~15 is:   2   3   5   7  11  13thread1 exit!12321number 12321 is a palindomethread4 exit!main thread exit!the process 2716 exitThe process 2715 exitThe NO.1 parent process ID is 2712 exit   ¢  1号父进程再创建2号进程。¢  2号进程输出自己的进程信息，包括名称，ID,PID等。¢  4号进程再创建7号进程。Thread3：判断某个年份是否是闰年Thread4：判断一个5位数是不是回文数。例如12321是回文数，个位与万位相同，十位与千位相同。编译运行编写的程序查看运行输出查看各个线程运行结果版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/40851651	真是状况百出的一次CF啊……最终还Unrated了，你让半夜打cf 的我们如何释怀（中途茫茫多的人都退场了）……虽说打得也不好……在这里写一下这一场codeforces的解题报告，A-E的 题目及AC代码，部分题目有简单评析，代码还算清晰，主要阅读代码应该不难以理解。Questions about problems  #AuthorProblemWhenQuestionAnswer   2014-11-05 21:24:38AnnouncementGeneral announcement*****Issue of problem locking was fixed. Now you should be able to lock task if you passed pretests.   2014-11-05 21:18:46AnnouncementGeneral announcement*****You may be unable to lock some problems for hacking. This will be fixed soon.   2014-11-05 20:23:29AnnouncementGeneral announcement*****This round will be unrated due to technical issues. Duration will be extended by 30 minutes. Testing queue is really long. Continue solving other problems. We are sorry for an inconvenience.A. Factorytime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputOne industrial factory is reforming working plan. The director suggested to set a mythical detail production norm. If at the beginning of the day there were x details in the factory storage, then by the end of the day the factory has to produce  (remainder after dividing x by m) more details. Unfortunately, no customer has ever bought any mythical detail, so all the details produced stay on the factory.The board of directors are worried that the production by the given plan may eventually stop (that means that there will be а moment when the current number of details on the factory is divisible by m).Given the number of details a on the first day and number m check if the production stops at some moment.InputThe first line contains two integers a and m (1 ≤ a, m ≤ 105).OutputPrint "Yes" (without quotes) if the production will eventually stop, otherwise print "No".Sample test(s)input1 5outputNoinput3 6outputYes给两个数字a和m，工厂每次看a是多少就生产a个东西，然后把a变为a%m，如果a为0工序就崩盘了，问是否会崩盘那就用大小为m的一个vis数组来记录当前余数是否被用过，然后模拟，每次记录当前余数，如果余数变成0了输出Yes，如果余数到达了曾经有过的余数位置，那么就会以此为一个循环永远循环下去，那么我们break，输出NoCode：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))int main(){int a,m;cin>>a>>m;int vis[100086]={0};while(1){if(a==0){cout<<"Yes";return 0;}if(vis[a]==1){cout<<"No";return 0;}vis[a]=1;a=(a+a)%m;}return 0;}B. Valuable Resourcestime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputMany computer strategy games require building cities, recruiting army, conquering tribes, collecting resources. Sometimes it leads to interesting problems.Let's suppose that your task is to build a square city. The world map uses the Cartesian coordinates. The sides of the city should be parallel to coordinate axes. The map contains mines with valuable resources, located at some points with integer coordinates. The sizes of mines are relatively small, i.e. they can be treated as points. The city should be built in such a way that all the mines are inside or on the border of the city square.Building a city takes large amount of money depending on the size of the city, so you have to build the city with the minimum area. Given the positions of the mines find the minimum possible area of the city.InputThe first line of the input contains number n — the number of mines on the map (2 ≤ n ≤ 1000). Each of the next n lines contains a pair of integers xi and yi — the coordinates of the corresponding mine ( - 109 ≤ xi, yi ≤ 109). All points are pairwise distinct.OutputPrint the minimum area of the city that can cover all the mines with valuable resources.Sample test(s)input20 02 2output4input20 00 3output9有一个城市需要建造，给你许多矿坑d坐标点，问把这么多矿坑全都包进城市的话，城市所需最小面积是多少（注意，城市为平行于坐标轴的正方形）这不知道算不算凸包，反正记录最大最小的x和y，然后相减获得最小矩形长宽，取两者较长边平方即可。Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;const int inf=(int)1e9+10086;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int main(){int n;cin>>n;int up=-inf,down=inf,left=inf,right=-inf;for(int i=0;i<n;i++){int x,y;cin>>x>>y;if(x<left)left=x;if(x>right)right=x;if(y<down)down=y;if(y>up)up=y;}int len=max(up-down,right-left);cout<<(long long)len*len;return 0;}C. Bitstime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputLet's denote as  the number of bits set ('1' bits) in the binary representation of the non-negative integer x.You are given multiple queries consisting of pairs of integers l and r. For each query, find the x, such that l ≤ x ≤ r, and is maximum possible. If there are multiple such numbers find the smallest of them.InputThe first line contains integer n — the number of queries (1 ≤ n ≤ 10000).Each of the following n lines contain two integers li, ri — the arguments for the corresponding query (0 ≤ li ≤ ri ≤ 1018).OutputFor each query print the answer in a separate line.Sample test(s)input31 22 41 10output137NoteThe binary representations of numbers from 1 to 10 are listed below:110 = 12210 = 102310 = 112410 = 1002510 = 1012610 = 1102710 = 1112810 = 10002910 = 100121010 = 10102这题是给一个范围（L是左边界，R是有边界）问你在这个范围内哪个数载二进制下1的数量是最多的（有多个解请输出最小数）。也就是，要二进制的1尽量多，还要求尽量小，那就从低位开始把0变成1呗那么我们就从左边界开始，从低位向高位按位或（0变成1，1也还是1）1，直到比R大停止，输出前一个（即比R小的最后一个数）。Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))int main(){int cases=0;scanf("%d",&cases);for(int _case=1;_case<=cases;_case++){ll l,r,t,p=1;cin>>l>>r;for(ll i=0;i<63;i++){ll t=l|p;if(t>r)break;l=t,p<<=1;//cout<<t<<endl;}cout<<l<<endl;}return 0;}D. Maximum Valuetime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputYou are given a sequence a consisting of n integers. Find the maximum possible value of  (integer remainder of ai divided byaj), where 1 ≤ i, j ≤ n and ai ≥ aj.InputThe first line contains integer n — the length of the sequence (1 ≤ n ≤ 2·105).The second line contains n space-separated integers ai (1 ≤ ai ≤ 106).OutputPrint the answer to the problem.Sample test(s)input33 4 5output2短小精悍却烦人至深的题，我原先想的太简单了，写了个int n=0;cin>>n;for(int i=0;i<n;i++)scanf("%d",&num[i]);sort(num,num+n,cmp);int modmax=0;for(int i=0; num[i]>modmax; i++)for(int j=i+1;num[j]>modmax && j<n; j++)update( num[i] % num[j]);cout<<modmax;return 0;这样的东西……TLE的飞起……想了想就不能暴力啊，暴力的话剪枝也没用Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;int n,a[200048]={0},ans=0;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))#define update(x) ans=(ans<(x)?x:ans);int main(){scanf("%d",&n);for(int i=0;i<n;++i) scanf("%d",&a[i]);sort(a,a+n);for(int i=0;i<n-1;++i)if(i==0||a[i]!=a[i-1]){int j=a[i]+a[i],p;while(j <= a[n-1]){p = lower_bound(a,a+n,j)-a;if(p > 0) update(a[p-1] % a[i]);j+=a[i];}update(a[n-1] % a[i]); }printf("%d\n",ans);return 0;}E. Strange Sortingtime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputHow many specific orders do you know? Ascending order, descending order, order of ascending length, order of ascending polar angle... Let's have a look at another specific order: d-sorting. This sorting is applied to the strings of length at least d, where d is some positive integer. The characters of the string are sorted in following manner: first come all the 0-th characters of the initial string, then the 1-st ones, then the 2-nd ones and so on, in the end go all the (d - 1)-th characters of the initial string. By the i-th characters we mean all the character whose positions are exactly i modulo d. If two characters stand on the positions with the same remainder of integer division byd, their relative order after the sorting shouldn't be changed. The string is zero-indexed. For example, for string 'qwerty':Its 1-sorting is the string 'qwerty' (all characters stand on 0 positions),Its 2-sorting is the string 'qetwry' (characters 'q', 'e' and 't' stand on 0 positions and characters 'w', 'r' and 'y' are on 1 positions),Its 3-sorting is the string 'qrwtey' (characters 'q' and 'r' stand on 0 positions, characters 'w' and 't' stand on 1 positions and characters 'e' and 'y' stand on 2 positions),Its 4-sorting is the string 'qtwyer',Its 5-sorting is the string 'qywert'.You are given string S of length n and m shuffling operations of this string. Each shuffling operation accepts two integer arguments kand d and transforms string S as follows. For each i from 0 to n - k in the increasing order we apply the operation of d-sorting to the substring S[i..i + k - 1]. Here S[a..b] represents a substring that consists of characters on positions from a to b inclusive.After each shuffling operation you need to print string S.InputThe first line of the input contains a non-empty string S of length n, consisting of lowercase and uppercase English letters and digits from 0 to 9.The second line of the input contains integer m – the number of shuffling operations (1 ≤ m·n ≤ 106).Following m lines contain the descriptions of the operations consisting of two integers k and d (1 ≤ d ≤ k ≤ n).OutputAfter each operation print the current state of string S.Sample test(s)inputqwerty34 26 35 2outputqertwyqtewryqetyrwNoteHere is detailed explanation of the sample. The first modification is executed with arguments k = 4, d = 2. That means that you need to apply 2-sorting for each substring of length 4 one by one moving from the left to the right. The string will transform in the following manner:qwerty  →  qewrty  →  qerwty  →  qertwyThus, string S equals 'qertwy' at the end of first query.The second modification is executed with arguments k = 6, d = 3. As a result of this operation the whole string S is replaced by its 3-sorting:qertwy  →  qtewryThe third modification is executed with arguments k = 5, d = 2.qtewry  →  qertwy  →  qetyrw给一串字符串，每次给两个数字k和d，即要求从左到右每k个数进行一次 d-sorting，这种sorting的意思是，每d个数字选一个，这么分好组之后排序，详见hintDIV2全场只有一个人（joker99）出了E，看了下代码暂时囫囵吞了下，贴一下代码等日后学习下。Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))const int size = 2 * 1000 * 1000 + 10;const int ssize = 21;char buf[size];char nbuf[size];int n=0, m=0;int pwr[ssize][size];void combine(int* tg, int* a, int* b, int shift) {    for (int i = 0; i < n; i++) {        if (a[i] < shift) tg[i] = a[i];        else tg[i] = b[a[i] - shift] + shift;    }}int main() {    scanf("%s", buf); n = strlen(buf);    scanf("%d", &m);    for (int i = 0; i < m; i++) {        int k, d;        scanf("%d%d", &k, &d);        int num = n - k + 1, cur = 0;        for (int j = 0; j < d; j++) {            int p = j;            while (p < k) {                pwr[0][p] = cur++;                p += d;            }        }        for (int j = k; j < n; j++)pwr[0][j] = j;        int lim = 0, vl = 1;        while (vl <= num) {            vl *= 2;            lim++;        }        for (int j = 1; j < lim; j++)             combine(pwr[j], pwr[j - 1], pwr[j - 1], (1 << (j - 1)));        for (int j = 0; j < n; j++) {            int ps = j;            int vl = num;            int sh = 0;            for (int h = lim - 1; h >= 0; h--)                if (vl >= (1 << h)) {                    if (ps >= sh)ps = pwr[h][ps - sh] + sh;                    vl -= (1 << h);                    sh += (1 << h);                }            nbuf[ps] = buf[j];         }        for (int j = 0; j < n; j++)buf[j] = nbuf[j];        printf("%s\n", buf);    }    return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/40692071	历经千辛万苦，小Hi和小Ho终于到达了举办美食节的城市！虽然人山人海，但小Hi和小Ho仍然抑制不住兴奋之情，他们放下行李便投入到了美食节的活动当中。美食节的各个摊位上各自有着非常多的有意思的小游戏，其中一个便是这样子的：小Hi和小Ho领到了一个大小为N*M的长方形盘子，他们可以用这个盒子来装一些大小为2*1的蛋糕。但是根据要求，他们一定要将这个盘子装的满满的，一点缝隙也不能留下来，才能够将这些蛋糕带走。这么简单的问题自然难不倒小Hi和小Ho，于是他们很快的就拿着蛋糕离开了~但小Ho却不只满足于此，于是他提出了一个问题——他们有多少种方案来装满这个N*M的盘子呢？值得注意的是，这个长方形盘子的上下左右是有区别的，如在N=4, M=3的时候，下面的两种方案被视为不同的两种方案哦！提示：我们来玩拼图吧！不过不同的枚举方式会导致不同的结果哦！小Ho的观察力一向不错，这不，他很快便发现了M的取值范围只可能为3、4、5三种情况，但是这一发现并没有能够给他减轻多少烦恼。虽然在过去一段时间的训练下，小Ho很快就意识到这道题目可能仍然是需要使用动态规划进行解决，但是他苦思冥想也没有能够想到很好的状态定义方式：“如果我每次枚举一块蛋糕的放置位置，那么我就需要存储下整个盘子的放置情况——也就是说2的(N*M)次方种状态，存不下呀存不下！”小Hi看着小Ho憋闷的样子，也是知道他想错了方向，于是道：“你先别急，让我们从头来看看这个问题，首先你先告诉我，我们的问题是甚么？”小Ho摇了摇头，想了想，道：“有多少种方案可以用1*2的正方形填满一个N*M的长方形？”小Hi笑道：“是的，我们不妨称这个答案为sum(N, M)，那么我们接下来要做的事情是不是要想办法把这个问题分解成若干子问题呢？”小Ho道：“是的，我之前也是想到这里，我首先枚举一块蛋糕的放置位置，那么剩下的空闲位置有多少种方案被填满就是一个子问题了！由于这个位置的数量是在一直减少的，所以我可以按照一定的顺序依次求解出所有这样的问题的答案，但是这样的问题的数量太多了，根本计算不过来。”小Hi道：“你可是想的太简单了呢，真的只有算不过来的问题么？你且看这两种情况，虽然我第一次枚举的位置不同，但是只要第二次枚举的是另一种情况的第一次枚举，那么最终都会到达同样的状态，那么接下来是不是就会出现重复的统计啊？”小Ho惊道：“是这样！那……那我应该怎么办呢？”小Hi笑道：“我有一计，可解上述两大难题！”小Ho道：“快快道来！”小Hi挥挥手，表示不要着急，接着说：“你看！对于这样一种方案，按照你之前的方法，无论是1234的顺序枚举，还是4321的顺序枚举，最后统计到的都是这样一种方案，也就是无论是1~4的哪一种排列，都会是这样的方案，那么是不是说明，每一种方案都被统计了(N*M)!次？”小Ho点了点头道：“是的！”想了想又接着说：“那么我是不是只要把最终答案都除以(N*M)!就能够得到正确的答案了呢？”小Hi满脸无奈道：“真是个没志气的家伙，你为什么不干脆想办法使得每种方案都只被统计一次呢？”小Ho：“怎么做？！教教我~”小Hi道：”你想想，既然无论以什么样的排列顺序都会致使同样的结果，那么我们就想办法给它定义一个顺序便是了呢？比如说，对于每一块蛋糕，以其左（上）边一块的行号为第一关键字，列号为第二关键字的顺序，只有按照这个顺序递增的排列才是合法的！”小Ho低头算了算，道：”是的！这样就只有1234这样一种顺序合法了，同样的，其他的每一种方案也都会只有一种对应的方案。但是我仍然不懂的是，我怎么保证在求解这个子问题的时候，一定能够只搜索出这样的方案呢？“小Hi道：”这个简单！只要不是枚举每一块蛋糕放在什么地方？而是按照行号为第一关键字，列号为第二关键字的顺序，依次枚举每个位置上的蛋糕是如何放置的！通过这样的方式，来将一个问题分解成子问题！比如在下面的这个问题中，我当前要决定的便是黑色方块的蛋糕放置方案，而不同的放置方案——横放还是竖放，便会导出不同的子问题，并且这样是不会像之前的方法那样，有重复统计的。”小Ho道：“原来是这样！仔细想想就会发现，这样导出的方案一定是符合我们之前的要求的，是合法的！但是不是说要解决两个问题么，现在我似乎还是要记录棋盘的局面呀，不然的话出现这种情况的时候，我是没有办法知道当前这个位置是否可以横放竖放，又是否已经在之前的放置中已经放置过了！”小Hi忙道：“别急别急，你再想想到底要记录多少东西~”“唔……其实好像只用记录两行就可以了！因为在枚举到(i, j)这个位置的时候，也就是当前枚举的位置所在的这一行，以及下一行。因为这之前的位置肯定都已经放置满了蛋糕，而这之后的位置肯定都还没有放置任何东西！”小Ho恍然大悟道。“那你准备如何定义状态呢~”“像这样，我令sum(i, j, p1, p2, ... , pM, q1, q2, ... , qM)表示：已经将第一行至第i-1行的盘子都已经填满了，当前正在尝试往(i, j)这个位置放置蛋糕，而第i行的放置情况用p1...pM表示，第i+1行的放置情况用q1...qM表示——0表示为空，1表示放置了蛋糕。那么sum(i, j, p1, p2, ... , pM, q1, q2, ... , qM)便表示在这种情况下，剩余的格子有多少种填充的方法，而我们要求的问题便是sum(1, 1, 0, 0, 0, ..., 0)了！”小Hi笑道：“诶，你居然注意到了这个问题要求的是sum而不是best~这并不像之前的动态规划一样是求一个全局最优解，而是单纯的统计方案数！”小Ho拍拍胸脯道：“你也不看看我是谁！而我觉得转移会是这样的……其中第一、二种情况是用于当前位置并不是空白位置时；第三种到第六种分别代表着当前位置的蛋糕摆放方向的2*2种可能。”查看大图小Hi点了点头，道：“没错！那你有没有觉得你这样的状态定义还是没有办法很好的根据M来进行转移？”小Ho惊道：“是的呢！对了！我们还可以用上一周说的那种“状态压缩”的方式，将p1 ... pM, q1 ... qM 这2M个0/1表示成为一个整数，这样我的状态转移方程就会变成这样了！其中si表示s转换为2进制后从高到低第i位的值~”查看大图“是的呢！”小Hi点了点头：“赶紧去写个程序算出来，我们就可以去吃蛋糕了！”
http://blog.csdn.net/okcd00/article/details/40691763	小Hi和小Ho在兑换到了喜欢的奖品之后，便继续起了他们的美国之行，思来想去，他们决定乘坐火车前往下一座城市——那座城市即将举行美食节！但是不幸的是，小Hi和小Ho并没有能够买到很好的火车票——他们只能够乘坐最为破旧的火车进行他们的旅程。不仅如此，因为美食节的吸引，许多人纷纷踏上了和小Hi小Ho一样的旅程，于是有相当多的人遭遇到了和小Hi小Ho一样的情况——这导致这辆车上的人非常非常的多，以至于都没有足够的位置能让每一个人都有地方坐下来。小Hi和小Ho本着礼让他们的心情——当然还因为本来他们买的就是站票，老老实实的呆在两节车厢的结合处。他们本以为就能够这样安稳抵达目的地，但事与愿违，他们这节车厢的乘务员是一个强迫症，每隔一小会总是要清扫一次卫生，而时值深夜，大家都早已入睡，这种行为总是会惊醒一些人。而一旦相邻的一些乘客被惊醒了大多数的话，就会同乘务员吵起来，弄得大家都睡不好。将这一切看在眼里的小Hi与小Ho决定利用他们的算法知识，来帮助这个有着强迫症的乘务员——在不与乘客吵起来的前提下尽可能多的清扫垃圾。小Hi和小Ho所处的车厢可以被抽象成连成一列的N个位置，按顺序分别编号为1..N，每个位置上都有且仅有一名乘客在休息。同时每个位置上都有一些垃圾需要被清理，其中第i个位置的垃圾数量为Wi。乘务员可以选择其中一些位置进行清理，但是值得注意的是，一旦有编号连续的M个位置中有超过Q个的位置都在这一次清理中被选中的话（即这M个位置上的乘客有至少Q+1个被惊醒了），就会发生令人不愉快的口角。而小Hi和小Ho的任务是，计算选择哪些位置进行清理，在不发生口角的情况下，清扫尽可能多的垃圾。提示一：无论是什么动态规划，都需要一个状态转移方程！小Hi面对这个问题也是不慌不忙，反倒决定借此机会让小Ho学习一下状态压缩动态规划，于是推了推一旁仍然晕晕乎乎的小Ho，问道：“小Ho，你说这样的问题能否使用动态规划进行解决？”小Ho思索了一番，在心中默默将这个问题与背包问题进行类比后，道：“我觉得似乎不可以，这个问题和背包问题其实是很类似的，不过背包问题对于选取物品的限制是总重量不能超过一定数额。但在这里却是要求不能够在连续的一段位置中选取太多，如果我仍然以编号从小到大划分阶段，单单以best(i)表示当前已经决定了编号为1..i的位置是否选取的情况下最多可以清扫的垃圾数量的话，因为我不知道之前具体的选取方案，我是没有办法判断当前这个位置能否进行选取的，这便是违反了动态规划状态定义的无后效性！”小Hi点了点头表示赞同，但随即继续问道：”在背包问题中，正如我们之前经历时所说，我们是通过将best(i)变成best(i, j)，增加一个量——当前已经选取物品的总重量j到状态中，从而能够判断当前是否能够继续选取物品，那么在这里，你觉得我们需要添加什么样的量才能够达成我们的目的呢？”这个问题顿时难倒了小Ho，但他也不是轻易放弃的性格，便拿出纸笔开始写写画画：“正如我之前所说，我不知道之前具体的选取方案，我是肯定没有办法判断当前这个位置能否进行选取的！那么我需要做的事情无非就是在状态中记录之前的选取方法，并且这些记录需要能够让我推算出当前这个位置的垃圾是否能被清扫而不引起口角！”思路一旦清晰，各种想法便接踵而至，小Ho思索片刻便得出了结论：“如果我将之前每一个位置是否选取的信息都存储下来的话，那么到了决定最后一个位置的时候，最坏情况下我就有2^(N-1)种可能的状态，这个是我所不能接受的，但是我真的需要这么多的信息么？”“不需要！”小Ho说道：“我只需要知道我之前的M-1个位置中选取了多少个位置就可以了！如果这个数目小于Q，那么我当前就有两种决策方案——选与不选，不然就就只有不选这一种方案。”小Hi听闻此言，皱了皱眉头，问道：“那你的状态难道就要定义成best(i, j)表示当前已经决定了编号为1..i的位置，并且从i-M+1 ... i-1这M-1个位置中已经选取了j个位置的情况下最多可以清扫的垃圾数量么？”小Ho刚想称是，却想道小Hi不会无缘无故的问这种问题，于是仔细考虑，顿时发现其中不对：“状态固然是可以了，但是却没有办法进行转移，best(i, j)的下一步肯定是某个best(i+1, k)，但是因为无法知晓i-M+1这个位置究竟是否在j个选取的位置中，所以是根本没有办法计算k的！”“而一旦记录了i-M+1这个位置是否选取了的话，我就还需要记录i-M+2这个位置——因为在best(i+1, k)中它便是(i+1)-M+1的这个位置，以此类推，也就是说我不能够光记录从i-M+1 ... i-1 这M-1个位置中选取了多少个位置，我还要将具体选择了哪些位置都一一记录下来！”小Ho思考道：“那我便只有如此定义状态了——以best(i, p1, p2, p3, ... , pM-1)表示当前已经决定了编号为1..i的位置，并且第(i-j+1)个位置是否选取用pj进行记录（0表示未选取，1表示选取）的情况下最多可以清扫的垃圾数量！”听完小Ho新的想法，小Hi终于点了点头，但也没放弃继续考校小Ho：“那你准备如何转移状态？”“这个简单，我只需要统计p1..pM-1之和S——即选取的位置总数，并且根据这个数目进行决策！”小Ho说罢在纸上写出一个公式。“那具体的计算顺序呢？”小Hi也是将每个步骤都问的详详细细的。小Ho张口便道：“这个容易，因为每次转移都是从i向i+1进行的，所以我只需要按照i从小到大的顺序进行计算就可以了！”提示二：好像什么不对劲？状态压缩哪里去了？在得出结论之后，小Ho便拿出笔记本开始写程序，写着写着便注意到：“这个M是根据输入来的，那么我怎么开数组呢！难道要使用一些动态的方法？这样也未免太过复杂了吧，更何况即使我动态的开了数组，我也没有很好的方法来枚举这些位置，难道要写一大串的条件分支语句？”思索无奈之下，只能够去询问小Hi，小Hi仿佛早就预料到了这个情况，掏出一张草稿纸来，写下了一个长度为5的01串10101，问道：“你看这是什么？”“一个2进制串？我算算……等于21？”小Ho耿直的算了出来。小Hi笑了笑“如果我说这便是M=6的情况下，以第一个01来表示你状态中的p1，第二个01来表示你状态中的p2，并依次类推，那么我是否可以用(i, 21)来表示你的(i, 1, 0, 1, 0, 1)这样一个状态呢？”小Ho顿时恍然大悟：“是了！既然是01串，那么我就将这M-1个01视作一个二进制数又有何不可！这样一来，我的状态和状态转移方程岂非可以这样定义？”“是的！这便是所说的状态压缩，它在处理一些变长/变维度的状态时时非常有效的，同时也可以利用位运算来优化代码，方便计算！”小Hi适时的做了总结。“嗯嗯！我这便去写~”
http://blog.csdn.net/okcd00/article/details/40691439	且说之前的故事里，小Hi和小Ho费劲心思终于拿到了茫茫多的奖券！而现在，终于到了小Ho领取奖励的时刻了！等等，这段故事为何似曾相识？这就要从平行宇宙理论说起了………总而言之，在另一个宇宙中，小Ho面临的问题发生了细微的变化！小Ho现在手上有M张奖券，而奖品区有N种奖品，分别标号为1到N，其中第i种奖品需要need(i)张奖券进行兑换，并且可以兑换无数次，为了使得辛苦得到的奖券不白白浪费，小Ho给每件奖品都评了分，其中第i件奖品的评分值为value(i),表示他对这件奖品的喜好值。现在他想知道，凭借他手上的这些奖券，可以换到哪些奖品，使得这些奖品的喜好值之和能够最大。提示一： 切，不就是0~1变成了0~K么令人欣慰的是，在这个平行世界里小Ho已经学习了一般的01背包问题，所以他并没有思考太久，便提出了自己的想法。“我们的首要目标仍然是将问题抽象化！在我看来，这个问题其实和01背包问题很像，我们在解决01背包问题的时候是按照奖品的标号从1到N依次决定每件奖品是否选取，那么对于每种奖品有无数件的这个问题，我可以按照奖品的标号从1到N依次决定每种奖品选取的件数！”小Hi点了点头表示赞同。小Ho于是继续说道：“那么按照01背包的想法，我可以使用best(i, x)表示已经决定了前i件物品每件物品选择多少件，当前已经选取的物品的所需奖券数总和不超过x时，能够获取的最高的喜好值的和，那么最终的答案便是best(N, M)。”小Hi道：”的确可以这样，那么你准备如何转移呢？”小Ho道：“仍然是根据01背包的做法，对于一个问题best(i, x)，考虑最后一步——即第i件物品选择多少件，不妨就假设选择k件吧，那么k的取值范围肯定是在0~(x / need(i))这个范围内。这个时候我们可以知道best(i - 1, x - need(i) * k) + value(i) * k将会是一种可能的方案。”小Hi挠了挠头，问道：”你所说的‘可能的方案’是什么意思？”小Ho笑道：“就是说best(i, x)的求解满足这个公式~”说罢，拿过纸笔，列出了一个式子。小Hi接过纸来，看完说道：“的确没错，总共就是这些可能~那你是否求解这个问题也是用与01背包类似的方法进行求解呢？”“是的，我会使用这样的方法来做！”小Ho刷刷刷又在纸上写下来几行伪代码。“应该没有问题，时间复杂度也很不错了~~但是我看着总有点难受！”小Hi点了点头又摇头。“怎么说？”提示二：强迫症患者总是会将状态转移方程优化一遍又一遍小Hi嘻嘻笑了两声，说道：“我们不妨换一种问题定义的方式：用best(i, x)表示已经决定了前i件物品每件物品选择多少件，当前已经选取的物品的所需奖券数总和不超过x时，能够获取的最高的喜好值的和！”小Ho仔仔细细回忆了下，确认小Hi所说和自己先前并无区别，怒道：“你这和我的定义方法有什么区别呀？”小Hi道：“别急别急，这部分的确没有区别，有区别的在后头~”小Ho撇了撇嘴：“那你就说呗~”小Hi继续道：“我们还是考虑最后一步——要不要再选一件第i种奖品！”小Ho有点不能理解，道：“什么叫再选一件？”“你想想，在你的状态转移方程（即问题求解公式）中是否满足这样两个公式？”小Hi问道。小Ho低头想了想，点了点头表示赞同。小Hi于是继续问道：“那你有没有意识到这样一个等式？”“似乎……是的！”小Ho惊道：“这么说，其实best(i, x)的大部分计算都在best(i, x - need(i))中已经计算过了！”小Hi问出了最后一个问题：“所以你的公式是不是就可以变成这样子呢？”“是的！所以……代码就可以这么写了~是么！”“是的嗯~”提示三：同样不要忘了优化空间哦！转到Hiho6提示二：且说小Ho搞清楚了计算方法，正在埋头苦写代码，在一旁看他写代码的小Hi是在看不下去了，决定再指点指点小Ho：“小Ho啊！”“怎么了？”小Ho眼睛盯着屏幕，望都没望小Hi一眼。“你现在是不是需要开一个N * M大小的二维数组best，来记录求解出的best值呀？”小Ho终于有了点反应，抬起头来说道：“是啊，怎么了？““我有办法不用开这么大空间哦~”小Hi笑嘻嘻道：”可我就是不告诉你！”“诶，别这样，我请你吃雪糕！”小Ho一听就急了，连忙许下了报酬。“开玩笑啦~”小Hi也是随便逗了逗乐子就没继续：“你想想，在i已经是10以上的时候，best(5, j)这样的值还有用么？”“没有用了……你是说，我并不需要在内存中存下来所有的best(i, j)，没有用了的值都可以不进行保存……也就是说，实际上只要开一个2*M大小的数组就可以了，然后像这样的方式进行来回的计算，是不是就可以了？”“是的呢！但是还可以更少哦~让我来写这个程序的话，我只需要开一个M大小的一维数组就可以了”小Hi自信的说道：“你想想，如果我按照j从M到1的顺序，也就是跟之前相反的顺序来进行计算的话。另外根据我们的状态转移方程，可以显然得出如果状态(iA, jA)依赖于状态(iB, jB)，那么肯定有iA = iB+1, jA>=jB。所以不难得出一个结论：我在计算best(i, j)的时候，因为best(i, j+1..M)这些状态已经被计算过了，所以意味着best(i - 1, k)，k=j..M这些值都没有用了——所有依赖于他们的值都已经计算完了。于是它们原有的存储空间都可以用来存储别的东西，所以我不仿直接就将best(i, j)的值存在best(i-1, j)原有的位置上，就像这样。”“原来还可以这样！这样一处理，不仅空间复杂度小了很多，代码也很好看了呢！”小Ho开心道。“那你还不去写？”
http://blog.csdn.net/okcd00/article/details/40691211	且说上一周的故事里，小Hi和小Ho费劲心思终于拿到了茫茫多的奖券！而现在，终于到了小Ho领取奖励的时刻了！小Ho现在手上有M张奖券，而奖品区有N件奖品，分别标号为1到N，其中第i件奖品需要need(i)张奖券进行兑换，同时也只能兑换一次，为了使得辛苦得到的奖券不白白浪费，小Ho给每件奖品都评了分，其中第i件奖品的评分值为value(i),表示他对这件奖品的喜好值。现在他想知道，凭借他手上的这些奖券，可以换到哪些奖品，使得这些奖品的喜好值之和能够最大。提示一：合理抽象问题、定义状态是动态规划最关键的一步小Hi想了想，问道：“你打算怎么做？”“枚举2^N种可能的选取方案，先计算他们需要的奖券之和sum，在sum不超过M的情况下，计算他们的喜好值之和value，并统计一个最优的方案，也就是value的最大值！”天真的小Ho给出了一个同样天真的方案。“简直白教你动态规划了……”小Hi不禁扶额道：“这道题目你还是考虑一下如何使用动态规划来解决吧！”“好的！让我回忆一下……动态规划要求问题存在两种性质：重复子问题和无后效性~但是...我怎么也看不出这道题目怎么套上这两种性质呀，什么样算是一个子问题？”小Ho想了想，说道。“先别急，你想要知道子问题是什么？那么首先，我们要想办法把我们现在遇到的问题给抽象化！”小Ho低头思索了一会，说道：“唔，我想想，如果用best(x)表示手中有x张奖券时能够获取的最高的喜好值的和，那么我们的问题就是best(M)是多少？”“你这样定义的话，是没有办法把‘求解best(M)’这样一个问题分解成不同的子问题的哦~”小Hi笑道：“也罢，初学者往往都很难自己想出如何好的抽象问题，这次就让我先来告诉你~”“就知道卖关子~快说！”小Hi笑了笑，继续说道：“这个问题——best(M)的求解，其实问的便是每个奖品是否选择是么？那么你在遍历这2^N种可能的选取方案的时候，是不是按照顺序，一一确定每一个奖品是否选取？”“是的！”小Hi继续道：“那么我们不妨就按照你遍历时的情况来，不过做一点小改动，以best(i, x)表示已经决定了前i件物品是否选取，当前已经选取的物品的所需奖券数总和不超过x时，能够获取的最高的喜好值的和。”“听起来的确和搜索很像，搜索时就是按照编号从小到大的顺序一一决定每件物品是否选取，并且维护一个当前已经选取的物品的所需奖券书的总和。”忽然小Ho似乎想到了什么：“诶，那么这个best(i, x)其实就是和之前遇到的数字三角形迷宫问题中用于解决问题的记忆化搜索很相似的？”“没错，记忆化搜索的确就是和动态规划极为相似，或者可以说，他们用以解决问题的原理是一样的。”小Hi回答道。“原来如此，我想想……那么最终的答案其实就是best(N, M)是么？”小Ho得出了结论。“是的！这个时候我们就可以称best(N, M)的求解为我们的问题了！”小Hi高兴道。“那么子问题呢？”小Hi挥了挥手示意小Ho不要着急：“子问题通常会采取将问题分成若干部分来进行，有的时候是均分，也有的时候仅仅是在规模上减一。比如这里，我们不妨考虑best(N, M)这个问题的最后一个决策——第N件奖品是否进行选择：首先，如果选择第N件奖品，当然首先要保证第N件商品所需的奖券数不超过M，我们可以知道这种方案的最佳收益为best(N - 1, M - need(N)) + value(N)。”“其次呢，如果不选择第N件奖品，我们可以知道这种方案的最佳收益为best(N - 1, M)。”小Hi顿了顿，继续道：”由于第N件奖品只有选取和不选取两种可能，我们于是可以知道best(N, M) = max{best(N - 1, M - need(N)) + value(N), best(N - 1, M)}！”“没错！”小Ho道：“同样的道理，对于任意i>1, j，我们都可以知道best(i, j)=max{best(i-1, j-need(i)) + value(i), best(i - 1, j)}!”“归纳的不错！那么你接检验一下这个问题的定义方法是否拥有动态规划所需要的两种性质？”小Ho想了想，决定一条一条的来：“首先看重复子问题——这是动态规划之所以比搜索高效的原因，如果最后四件奖品分别为所需奖券为1，喜好值为1、所需奖券为2，喜好值为2、所需奖券为3，喜好值为3、所需奖券为4，喜好值为4的四个奖品，那么无论是选择1、4还是2、3，都会要求解best(N-4, M-5)这样一个子问题，而这个子问题只需要求解一次就能够进行计算，所以重复子问题这一性质是满足的。”“没错，接着说。”“其次再看无后效性……同样的，如果分别有所需奖券为1，喜好值为1、所需奖券为2，喜好值为2、所需奖券为3，喜好值为3、所需奖券为4，喜好值为4的四个奖品，那么无论是选取第1个和第4个，还是选取第2个和第3个，他们的所需奖券数都为5，喜好值之和都为5。所以我只需要知道best(4, 5)=5就够了，它为什么等于5对我而言没有区别，不会对之后的决策产生影响。这就是无后效性，所以想来也是满足的。“说的挺正确~那么接下来要考虑的是如何使用best(i, j)=max{best(i-1, j-need(i)) + value(i), best(i - 1, j)}来求解每一个best(i, j)了~”小Hi道：“这部分我便直接告诉你吧，我们定义一个问题A依赖于另一个问题B当且仅当求解A的过程中需要事先知道B的值，那么我们很容易的发现best(i, j)是依赖于best(i-1, j-need(i))和best(i-1, j)两个问题的，也就是说这两个问题要先于best(i, j)进行求解~”“所以我们只要按照i从小到大的顺序，以这样的方式进行计算，就可以了！”小Ho插嘴道。“你又抢我台词！”提示二：说过了减少时间消耗，我们再来看看如何减少空间消耗且说小Ho搞清楚了计算方法，正在埋头苦写代码，在一旁看他写代码的小Hi是在看不下去了，决定再指点指点小Ho：“小Ho啊！”“怎么了？”小Ho眼睛盯着屏幕，望都没望小Hi一眼。“你现在是不是需要开一个N * M大小的二维数组best，来记录求解出的best值呀？”小Ho终于有了点反应，抬起头来说道：“是啊，怎么了？““我有办法不用开这么大空间哦~”小Hi笑嘻嘻道：”可我就是不告诉你！”“诶，别这样，我请你吃雪糕！”小Ho一听就急了，连忙许下了报酬。“开玩笑啦~”小Hi也是随便逗了逗乐子就没继续：“你想想，在i已经是10以上的时候，best(5, j)这样的值还有用么？”“没有用了……你是说，我并不需要在内存中存下来所有的best(i, j)，没有用了的值都可以不进行保存……也就是说，实际上只要开一个2*M大小的数组就可以了，然后像这样的方式进行来回的计算，是不是就可以了？”“是的呢！但是还可以更少哦~让我来写这个程序的话，我只需要开一个M大小的一维数组就可以了”小Hi自信的说道：“你想想，如果我按照j从M到1的顺序，也就是跟之前相反的顺序来进行计算的话。另外根据我们的状态转移方程，可以显然得出如果状态(iA, jA)依赖于状态(iB, jB)，那么肯定有iA = iB+1, jA>=jB。所以不难得出一个结论：我在计算best(i, j)的时候，因为best(i, j+1..M)这些状态已经被计算过了，所以意味着best(i - 1, k)，k=j..M这些值都没有用了——所有依赖于他们的值都已经计算完了。于是它们原有的存储空间都可以用来存储别的东西，所以我不仿直接就将best(i, j)的值存在best(i-1, j)原有的位置上，就像这样。”“原来还可以这样！这样一处理，不仅空间复杂度小了很多，代码也很好看了呢！”小Ho开心道。“那你还不去写？”
http://blog.csdn.net/okcd00/article/details/40690809	小Hi和小Ho在经历了螃蟹先生的任务之后被奖励了一次出国旅游的机会，于是他们来到了大洋彼岸的美国。美国人民的生活非常有意思，经常会有形形色色、奇奇怪怪的活动举办，这不，小Hi和小Ho刚刚下飞机，就赶上了当地的迷宫节活动。迷宫节里展览出来的迷宫都特别的有意思，但是小Ho却相中了一个其实并不怎么像迷宫的迷宫——因为这个迷宫的奖励非常丰富~于是小Ho找到了小Hi，让小Hi帮助他获取尽可能多的奖品，小Hi把手一伸道：“迷宫的介绍拿来！”小Ho选择的迷宫是一个被称为“数字三角形”的n(n不超过200)层迷宫，这个迷宫的第i层有i个房间，分别编号为1..i。除去最后一层的房间，每一个房间都会有一些通往下一层的房间的楼梯，用符号来表示的话，就是从第i层的编号为j的房间出发会有两条路，一条通向第i+1层的编号为j的房间，另一条会通向第i+1层的编号为j+1的房间，而最后一层的所有房间都只有一条离开迷宫的道路。这样的道路都是单向的，也就是说当沿着这些道路前往下一层的房间或者离开迷宫之后，小Ho没有办法再次回到这个房间。迷宫里同时只会有一个参与者，而在每个参与者进入这个迷宫的时候，每个房间里都会生成一定数量的奖券，这些奖券可以在通过迷宫之后兑换各种奖品。小Ho的起点在第1层的编号为1的房间，现在小Ho悄悄向其他参与者弄清楚了每个房间里的奖券数量，希望小Hi帮他计算出他最多能获得多少奖券。提示一：盲目贪心不可取，搜索计算太耗时小Hi拿到迷宫的介绍，仔细想了想，问道：“你自己有什么思路么？”小Ho想了想，道：“反正每次只有两种选择，我就选通向有更多奖券的房间的那条路呗~”小Hi笑了笑：“你这叫盲目贪心，如果我是迷宫的创造者，一定在第2层的第1个房间放10张奖券，第2个房间一张不放，然后在第3层的第3个房间放999张奖券，这样你就因为占一点小便宜就失掉了大头，你说是不是？”小Ho一惊：“似乎是的！切记不可因小失大，那……既然我们都是学计算机的学生，不如我们用计算机枚举一下所有可能的路径，然后找到最优的那一条？”小Hi点了点头：“自然是要用计算机来解决这个问题，不过你得先计算一下总共有多少条可能的路径，估算一下运行时间，这样才能确定能不能在迷宫节结束之前计算完是不是~”“我来算算，从出发点开始，每次我都有两种选择，而我总共要做n-1次选择，也就是2的n-1次方，而n最大可能是200，也就是说有2^199条路径……哪怕每条路径我只用一次运算就可以算出它的奖券总数，我毕业之前都肯定算不出来了吧QAQ”小Ho得出了一个非常忧伤的结论。“是的，但是这种搜索的方法其实是可以有方法进行优化的哦~”小Hi循循诱导着。“什么样的方法？”“别急，听我慢慢说~”提示二：记忆深搜逞神威，宽度优先解难题“我们可以来分分情况，我们要搜索所有的路径，然后依次计算每条路径的收益，这是我们现在的问题模型是不是？”小Hi问道。小Ho点头：“仔细分析这个迷宫的话，我们有两种搜索方法，一种是深度优先搜索，就像这幅图画的一样，我们先试着顺着每个房间的第一条路一直下去，一直走到最后一层，然后返回至倒数第二层，选择第二条路走到最后一个房间，然后返回到倒数第三层，选择第二条路走到倒数第二层，然后选择第一条路走到最后一层……期间维护已经走过的房间的奖券之和sum，然后每次到达最后一层的房间的时候将sum与全局最优解ans进行比较，如果sum>ans的话就用sum替换ans。这样在所有路径都计算过一遍之后，Ans中存储的就是我们要的答案了~~而第二种……”“先别说第二种，我们来看看这种方法有什么办法优化么~”小Hi打断了小Ho的喋喋不休。“哦，但是该怎么优化呢？”小Ho问道。“老规矩，我们来看看这个过程中有什么冗余计算~”小Hi还是那一套说辞，也不担心小Ho听了这么多遍听厌：“看这张图，当你枚举到绿色的‘-》右-》左’这样一条路径的时候，是不是发现它和红色的‘-》左-》右’这条路径一样都到达了第三层的第二个房间？”“是的！”“在你枚举到绿色路径的时候，是不是红色路径已经被枚举过了？”小Hi接着问道。“没错！““那么你看，绿色路径的奖券和是8，红色路径的奖券和是10，而你们都处于了相同的结点——第3层的第2个房间上，这时候无论你绿色路径接下来延续出什么样的路径，我将从第3层第2个房间开始的这一段连在红色路径之后的话，奖券和都会要比绿色路径要多？”小Hi继续问。“嗯……对的~”“而这些路径中的最优值都肯定不超过Ans，不然Ans就会在当时变得和它们一样，这不就说明了绿色路径无论接下来如何走，都不可能对Ans造成任何变化，那我们是不是完全可以不进行接下来的计算了呢？”小Hi做出了最后的结论。“是的……为了进行这样的优化，我们需要记录一个值best(i, j)——当前搜索过的路径中到达第i层第j个房间时最多能获取多少奖券，然后在每次进入一个房间的时候，都检查当前的sum与best(i, j)的大小关系，如果sum小于等于best(i, j)的话，就没有必要继续搜索了呢。比如在之前的例子中，当通过绿色路径到达第3层第2个房间的时候，best(i, j)=10，而sum = 8，所以是没有必要继续往下搜索的。”聪明的小Ho很快就将这个算法总结了出来。“而这种做法，由于是通过之前的记忆来避免不必要的搜索，所以被大家称为‘记忆化搜索’”小Ho笑道：“这样，只要不是那种非常坏的卡你的情况——比如第i层第j个房间的奖券数是j这种，都能够在O(n^2)的复杂度通过了呢。”“而如果我先右再左呢？”小Ho不死心。“那我就第i层第j个房间的奖券数是i-j”小Ho邪恶的笑着：“其实你不用纠结这个，你只要随机一下就能够保证几乎所有情况都是O(n^2)的时间复杂度，或者说平均复杂度是O(n^2)，但是你的最坏情况复杂度肯定是降不下去的，所以还是老老实实想想别的方法吧~比如之前你想说的第二种方法？”“与深度优先搜索相对应的自然就是宽度优先遍历啦~如果我们用<i, j, k>表示到达第i行的第j个房间，当前获得的奖券数为k这样一个状态，rewards(i, j)表示第i层第j个房间中的奖券数，那么遍历方式就是利用一个队列，先将ə, 1, rewards(1, 1)>这个状态放入队列中。然后每次取出队首<i, j, k>，如果i==n，就用k更新Ans，不然就将它代表的房间所能到达的两个房间的状态<i + 1, j, k + rewards(i + 1, j)>和<i + 1, j + 1, k + rewards(i + 1, j + 1)>放入队尾，直到整个队列清空，这时候Ans就是我们要的答案。”小Ho缓缓道来。“那你觉得这个地方又有什么可以优化的呢？”“本来我还没想到，但是你说了之前深度优先搜索的问题之后我就有点思路了，你看状态(2, 1, 8)和状态(2, 2, 6)在处理时一个会拓展出(3, 2, 10)这个状态，而另一个会拓展出(3, 2, 8)这个状态，但是就像我们之前的分析那样(3, 2, 8)这个状态是没有什么用的，它之后无论怎么走，换成(3, 2, 10)按它一样的走法肯定获得的奖券数要更多。”小Ho触类旁通，一下就找到了问题所在：“所以我可以像深度优先搜索那样用一个best(i, j)记录当前搜索过的路径中到达第i层第j个房间时最多能获取多少奖券，然后在一个状态(i, j, k)想要入队的时候，判断k与best(i, j)的大小，如果k小于等于best(i, j)就没有必要进队了~”“看来你还陷在了死胡同里，你这样在最坏情况复杂度根本没有变化不是？”小Hi无奈道：“你仔细想想，按照宽度优先搜索的顺序，是不是一个状态(i, j, k)在拓展出(i', j', k')的时候，(i', j', k')要么从来没有入队列，要么就仍然在队列里？”“唔...这个问题看来，基本上就是这样一层一层的顺序出队列的，那还是那个问题，如果我在判断状态(i, j, k)是否应该入队列的时候，发现了k大于best(i, j)，这个时候如果我再去判断一下队列中是否有一个(i, j, k')的状态。如果没有，就将(i, j, k)入队列，不然因为k'大于k，那么就像我们之前分析的那样(i, j, k')这个状态时无用的，不如就用k去替换掉状态(i, j, k')中的k'，这样也会减少运算不是？”“没错~而且你仔细分析的话，每个房间都只会入队列和出队列一次，这样就保证了平均情况时间复杂度和最坏情况时间复杂度都是O(n^2)哦！~”“原来是这样，那么现在问题差不多解决了呢！”小Ho高兴道：“赶紧算出来，我好去拿奖品。”“急什么！你从这之中可学到了什么知识么？”小Hi拦住了急冲冲的小Ho，问道。“啊？”提示三：总结归纳提公式，减少冗余是真理“且不说深度优先这样一个最坏情况下仍然有问题的方法，我们来说这个宽度优先搜索，我们能够使用best(i, j)来进行优化，无非是因为这个问题存在这样两个性质。”小Hi道。“第一便是无论我是通过怎么样的方式到达第i层第j个房间的，我之前做出的选择不会对我之后的选择做出限制与优待。就像如果我规定至少要向右走3次，那么状态就不仅仅是(i, j, k)这样，还要加上一个已经向右走的次数t，那么你觉得还能就直接像我们之前的方法进行计算么？如果到达第i层第j个房间的路上向右走过3次了，那么之后的走法就没有任何限制，不然就仍会有一个至少要向右走一定次数的限制。这样对于两个状态(i, j, k, l)和(i, j, k', l')，我们就不能够直接判断出那个状态是更加好的。“没错~其实就是best(i, j)有两个关键字进行参考，而这样的话就不是任意两个状态都可以进行比较的了。”小Ho总结道。“这样的性质被我们称为无后效性，顾名思义，当前的抉择不会对后面抉择产生影响。”“那第二个性质呢？”“第二个性质被我们称为重复子问题，在我们之前的例子中，我们将从起点出发到走出迷宫的最优路分解成了两个子问题，其一是从第2层的第1个房间走出迷宫的最优路，其二是从第2层的第2个房间走出迷宫的最优路，只要能算出这两个部分的最优值，我就可以知道从起点出发到走出迷宫的最优路。”小Hi道：”而按照这样的方法，这两个子问题都有一个相同的子问题——从第3层的第2个房间出发走出迷宫的最优路。”“这就是重复的子问题了，而我们的做法就是，重复的子问题只计算一次！也就是说我们要先计算出从起点到达第3层的第2个房间的最优线路，然后再考虑接下来怎么走~”小Ho感觉自己渐渐的把握到了关键之处。“对的，所以综合这样两个性质，我们可以考虑用best(i, j)表示从起点出发，走到第i层第j个房间出发最多可以获得的奖券数。”小Hi提出了一个新的定义：“那么我们要求的答案，便是所有best(n, j)中最大的那一个对不对？“是的，那该如何求这个呢……”小Ho思索着：“第i层第j个房间可以由第i-1层第j个房间和第i-1层第j-1个房间到达，所以best(i, j) = max{best(i - 1, j - 1), best(i - 1, j)} + rewards(i, j)这样么？”“是的，这个公式便是我们俗称的状态转移方程，你要做的，就是按照这样的顺序，依次计算出每一个房间的best(i, j)，然后在最后统计所有best(n, j)的最大值，就可以得到答案了。”“这个过程和宽度优先搜索的确很像，但是由于顺序是确定了的，我可以用一个两重循环，外层是i从1到n枚举层数，内层是j从1到i枚举房间编号，就可以直接进行计算了！”小Ho道。“你这个公式的边界情况还有待考虑嘛，比如j=1的时候就不需要取max了，直接使用best(i - 1, j)计算即可~”小Hi指出了小Ho存在的一个问题。“哦~那么j=i的时候也有相似的处理是吧。”“是的呢！所以快去写程序吧~”小Hi笑了笑：“抓紧时间，迷宫节就要结束了哦！”
http://blog.csdn.net/okcd00/article/details/40690415	前情回顾上回说到，小Hi和小Ho接受到了河蟹先生伟大而光荣的任务：河蟹先生将要给与他们一篇从互联网上收集来的文章，和一本厚厚的河蟹词典，而他们要做的是判断这篇文章中是否存在那些属于河蟹词典中的词语。当时，小Hi和小Ho的水平还是十分有限，他们只能够想到：“枚举每一个单词，然后枚举文章中可能的起始位置，然后进行匹配，看能否成功。”这样非常朴素的想法，但是这样的算法时间复杂度是相当高的，如果说词典的词语数量为N，每个词语长度为L，文章的长度为M，那么需要进行的计算次数是在N*M*L这个级别的，而这个数据在河蟹先生看来是不能够接受的。于是河蟹先生决定先给他们个机会学习一下，于是给出了一个条件N=1，也就是说词典里面事实上只有一个词语，但是希望他们能够统计这个词语在文章中出现的次数，这便是我们常说的模式匹配问题。而小Hi和小Ho呢，通过这一周的努力，学习钻研了KMP算法，并在互相帮助之下，已经成功的解决掉了这个问题！这便是Hiho一下第三周发生的事情，而现在第四周到了，小Hi和小Ho也要踏上解决真正难题的旅程了呢！任务回顾小Hi和小Ho是一对好朋友，出生在信息化社会的他们对编程产生了莫大的兴趣，他们约定好互相帮助，在编程的学习道路上一同前进。这一天，他们……咳咳，说远了，且说小Ho好不容易写完了第三周程序，却发现自己错过了HihoCoder上的提交日期，于是找小Hi哭诉，小Hi虽然身为管理员，但是也不好破这个例，于是把小Ho赶去题库交了代码，总算是哄好了小Ho。小Ho交完程序然后屁颠屁颠的跑回了小Hi这边，问道：“小Hi，你说我们是不是可以去完成河蟹大大的任务了呢？”小Hi思索半天，道：“老夫夜观星象……啊不，我这两天查阅了很多资料，发现这个问题其实也是很经典的问题，早在06年就有信息学奥林匹克竞赛国家集训队的论文中详详细细的分析了这一问题，而他们使用的就是Trie图这样一种数据结构！”“Trie图？是不是和我们在第二周遇到的那个Trie树有些相似呀？”小Ho问道。“没错！Trie图就是在Trie树的基础上发展成的一种数据结构。如果要想用一本词典构成Trie图的话，那么就首先要用这本词典构成一棵Trie树，然后在Trie树的基础上添加一些边，就能够变成Trie图了！”小Hi又作老师状。“哦！但是你说了这么多，我都不知道Trie图是什么样的呢！”小Ho无奈道。“也是！那我们还是从头开始，先讲讲怎么用Trie树来解决这个问题，然后在Trie树的基础上，讨论下一步应该如何。”小Hi想了想说道。提示一：如何用Trie树进行“河蟹”“还记得我们在第二周时，是如何使用Trie树解决字符串自动补全问题的么？”小Hi如是问道。“还记得，就是对于每一个询问，根据其每个位置上的字符，在Trie树上走出对应的边！”小Ho的记忆力还是挺不错的，很快便答了上来。小Hi满意的点了点头，继续问道：“那你想想怎么用Trie树来解决河蟹先生交代的任务？”“好的！”小Ho满口答应，随即分析道：“现在的这个问题和第二周遇到的问题的不同之处在于，第二周时一定是从询问的第一个字符开始匹配，然后找出所有可能的匹配，而我们现在遇到的问题是可以从询问的任意一个位置开始匹配，看是否会在Trie树上走到一个标记结点（标记结点对应路径为一个属于词典的单词）。”“没错，那你准备怎么做呢？”“我准备对于螃蟹先生给我的文章，还是像之前我们相出的朴素算法那样，枚举一个起始位置，然后我们的问题就变成了：是否从这个起始位置开始的一段字符（也就是从这个起始位置开始的字符串的一个前缀字符串），它存在于“河蟹”词典里面 ？而这个问题，就和第二周的问题几乎一样了，唯一不同的是，我是要一直在Trie树中走下去直到无边可走，或者走到一个标记结点的时候才能够停下来，前者代表没有任何需要河蟹的单词，后者则说明我们找到了。”小Ho井井有条的分析道。“也就是说，第二周我们成功解决了计算前缀匹配的数量这样一个问题，而这一周的任务却是可以在任意位置匹配，所以我们就枚举一个起始点，将这个问题转化成前缀匹配这样一个我们已知的问题来做，这样的思路么？”小Hi总结道。“嗯！我就是这么想的~”小Ho道。“嗯，这个方法听起来挺有意思的，而且仔细分析一下，这样做所需要的计算次数会在M*L这个数量级上，比我们之前的朴素算法已经好了很多呢~”小Hi夸奖了一番。“嘿嘿，但是你之前说的Trie图是怎么回事，它又能将计算次数缩减到怎样的数量级呢？”小Ho的好奇心也是燃烧了起来。“且听我说~”“现在我们有了一个时间复杂度在O(ML)级别的方法，但是我们的征途在星辰大海，啊不，我们不能满足于这样一个60分的方法。所以呢，我们还是要贯彻我们一贯的做法，寻找在这个算法中那些冗余的计算！“小Hi道：”那么我们现在来看看Trie树进行计算的时候都发生了些什么。”提示二：Trie树的优化思路——后缀结点“你看这组输入——文章str、词典dic还有我们构建的Trie树tree，我们在算法过程中，先枚举第一个字符作为起始位置，并最多匹配到第k个字符，因为str[1..k]这一段在tree中对应的结点A结点没有str[k+1]这一条边。这时候我们便要枚举第二个字符作为起始位置，并最多匹配到第k2个字符，这同样是因为str[2..k2]这一段在tree中对应的结点B结点没有str[k2+1]这一条边。也就是说我们在最开始的计算中，要先从tree的0号结点走到A结点，然后回到0号结点，再走到B结点。”小Hi在黑板上画了一些奇奇怪怪的符号，对小Ho如是解说道。“是的！等等，我怎么觉得这里似曾相识呢？”小Ho奇道。“问得好~那么你觉不觉得这个过程和上一周的KMP算法很相似，都是枚举原串（文章、str）的起始位置，然后在模式串（Trie树）中依次进行匹配？”小Hi说道。“是的！不同之处就在于模式串就是在一个数组里一个个匹配下来，而Trie树则是在一个树结构中一个个顺着边走~这无非就是单个词语和多个词语的差别了是么？”小Ho也是一点就透。“没错！那我们再回想一下我们当时是怎么优化KMP的——我们既然已经从str的当前起点i开始匹配了l个长度，那么在枚举str的下一个起点i+1的时候，就意味着最开始的l-1个字符都已经在之前的计算中匹配过了，如果我们能够利用好这个信息的话，就能够大大的减少时间复杂度。”“换句话说，如果我们从str的当前起点开始，匹配了l个长度走到了A结点，如果我们把A结点对应的字符串（即从tree的0号走到A结点的路径）去掉第一个字符，形成一个新的字符串，那么这个字符串肯定是和从str的下一个起点开始，长度为l-1的子串是一样的，而如果我们能够预先找到这个字符串在tree中对应的结点B'，我们就不用像之前所说的那样从0号节点走到A结点然后回到0号结点再走到B结点，而是可以直接从0号结点走到A结点然后直接跳转到B’结点然后再根据从str[i+l..k1]这一段走到B结点！”小Hi一口气说道，顿时感觉口干舌燥，于是拿起了一旁的杯子，猛灌了一口凉开水。”哦！那么如果用之前的这个例子的话，从str的第一个位置开始，匹配了3个字符走到了A结点，对应的字符串是abc，如果第一个字符a去掉变成bc，这个字符和从str的第二个位置开始长度为2的字串bc的确是一样的，此时bc在tree中对应的结点是B'结点，所以我们用之前的算法的话就是从0号结点走到A结点，然后再从0号结点走到B结点，现在可以直接从A结点走到B‘结点，然后根据str的第4（i+l=1+3）个字符走到B结点！”小Ho趁着小Hi休息的功夫，也是拿起了之前小Hi给出的例子推演道。”“没错！所以我们的问题规约成了：如何对于一棵给定的Trie树，找到其中每一个结点对应的后缀结点——这个结点在Trie中对应路径去掉第一个字符之后在Trie中对应的结点。“小Hi擦了把汗，感觉舒爽许多，于是继续说道。“我大致懂了！这个后缀结点就和我们在KMP算法中求解的NEXT数组是一个意思！”小Ho开心道。“你真聪明~”小Hi夸奖道。“那么现在……”小Hi刚要开口，就被小Ho无情打断。“可是小Hi老师~你看在这种情况下，结点C找不到对应的后缀结点，它对应的路径是aaabc，而aabc在Trie里面是走不出来的！”小Ho手中挥舞着一张纸，问道。“你个瓜娃子，老是拆老子台做啥子！……阿不，小Ho你别担心，我这就要讲解如何求后缀结点呢~”小Hi笑容满面的说道。提示三：如何求解Trie树中每个结点的后缀结点“先看之前你说的那个例子，如果tree中存在一个结点D，其对应的路径是aabc，那么这个结点的后缀结点是哪一个？”小Hi问道。“aabc……去掉第一个字符就是abc，对应的是A结点，所以D结点的后缀结点是A！”小Ho很快便做出了回答。“那么问题不就简单了么，既然结点D是不存在的，那么不就意味着这个开始结点的枚举，是肯定在中途就要找不到实际上是没有意义的么，直接从C结点跳转到A结点就可以了！所以只需要令C结点的后缀结点是A结点，像D结点这种不存在的结点当然要视为冗余计算，扔掉就行了！”小Hi老师斩钉截铁道。“D结点好可怜……但是，如果从tree的根节点到D结点的路径中有标记结点怎么办？这样的跳过会不会导致标记结点被忽略掉了？”小Ho问道。“如果不注意的话是会的呢！这就要引进一个新的概念，后缀结点为标记结点的结点也需要被标记，比如像对应路径为aab的E结点就是标记点对么？而aaab对应的F结点的后缀结点便是E结点，所以需要对F结点进行标记，这样在走到F结点的时候，就知道已经匹配出了一个河蟹词语了呢。”小Hi耐心答道。“那么接下来就开始说怎么快速有效的求后缀结点！小Ho，你先回答我：树结构最大的特点是什么？”小Hi问道。“是递归结构！”小Ho想也没想就回答道。“真聪明！虽然是导演安排好的台词，但是回答速度真是一流呢！”小Hi点了点头，继续说道：“所以我们想要求Trie树种每个结点的后缀结点，最直观的方法也就是像当初我们求解KMP的NEXT数组时那种从左到右的拓扑顺序一样，从根节点开始，以宽度优先遍历的顺序，依次求解每一个结点的后缀结点。”“嗯！这样可以保证每个结点对应的后缀结点，由于其对应字符串长度一定至少少1，所以一定会在它之前得到计算？但是这样有什么用呢？诶，我想到一个，这样就可以知道它的后缀结点是不是标记结点了，从而决定自己是不是要被标记是么？”小Ho决定打破砂锅问到底。“别急！听我慢慢说来。”小Hi不知从哪摸出一把羽扇，扇了两下，问道：“你看这棵Trie树，根节点的后缀结点是哪个？””根节点对应的字符串是空，去掉第一个字符……还是空，所以就是根节点自己了是吧？”小Ho想了想，说道。“是的，那你看从根节点连出去的这三个点n1,n2,n3他们的后缀结点是哪个？”小Hi继续问道。“他们对应的字符串都只有一个字符，所以去掉一个字符就变成空了，于是他们的后缀结点也都是根节点。”小Ho也继续答道。“那么现在，假设所有深度小于B结点的结点的后缀结点都已经算出来了，我想要算B结点的后缀结点，有没有什么好的方法呢？”小Hi随手填了几个结点的后缀结点，向小Ho问道。“如果考虑递归的思路的话，B结点的父亲结点是对应字符串为bc的B'结点，B'结点的后缀结点是n3结点，所以从B'结点出发经'd'这样一条边到达的结点B的后缀结点自然应该就是从B'结点的后缀结点n3出发经'd'这样一条边到达的结点——G结点了！”小Ho仔细研究了下，答道。”这么说来，是不是所有结点都可以这么求呀，如果它父亲结点是通过编号为char的一条边走向它的，那么只要找到它父亲的后缀结点，并且走出编号为char的一条边，就能够找到它的后缀结点了？”“差不多就是这个思路呢！但是你有没有想过如果它父亲结点的后缀结点并没有编号为char的一条边，你该怎么办？”小Hi也是不厌其烦，继续问道。“我想想，比如说结点G的父亲结点I的后缀结点J没有'c'这样一条边，但是结点J的后缀结点n1却有'c'这样一条边，由于后缀结点每次都是去掉前几个字符，所以后缀结点的后缀结点也相当于是“弱”一点的后缀结点，在没有更好的选择的情况下（因为这是第一次找到的有'c'这样一条边的后缀结点），G的后缀结点就应该是结点K了吧！”小Ho仔细想想，答道。“你这样的话，会不会觉得，每次都要往回不停的找后缀结点，挺浪费时间的呢？”这下子换到小Hi打破砂锅问到底了。“那该怎么办？”小Ho也是没辙了。“你看看这么做怎么样，我还是按照宽度优先搜索的顺序遍历整棵树，对于每一个结点，我不仅仅要求出它的后缀结点，我还要求出到达这个点后，经由每一个char（比如'a'..'d'）会走到的结点。由于到达这个结点之后，所有深度比它小的结点的这些值都算出来了，于是我可以直接通过父亲节点的后缀结点经由“父亲节点走到当前结点经过的边”走到的结点来计算我的后缀结点，同时这个后缀结点所要计算的值也都计算出来了，所以我可以通过这个后缀结点经由每一个char（比如'a'..'d'）会走到的结点来计算我经由每一个char（比如'a'..'d'）会走到的结点。”小Hi大致的说了一下思路。“小Hi老师，我听晕了！”小Ho报告说。“这个简单，我就拿这个例子给你依次算一算。”“如果用trie(X)表示X的根节点，next(X)('a')表示从X出发标号为'a'的边指向的结点，我们可以知道trie(0)=0, next(0)('a')=1, next(0)('b')=2, next(0)('c')=3, next(0)('d')=0。”“由于trie(1)=0, 我们可以补上从1出发的'a','d'这两条边：next(1)('a')=next(0)('a')=1, next(1)('d')=next(0)('d')=0”“由于trie(2)=0, 我们可以补上从2出发的'a','b','d'这三条边：next(2)('a')=next(0)('a')=1, next(2)('b')=next(0)('b')=2, next(2)('d')=next(0)('d')=0”“由于trie(2)=0, 我们可以补上从3出发的'a','b','c'这三条边：next(3)('a')=next(0)('a')=1, next(3)('b')=next(0)('b')=2, next(2)('c')=next(0)('c')=3”“由于trie(4)=next(trie(1))('b')=2, 我们可以补上从4出发的'a','b','d'这三条边：next(4)('a')=next(2)('a')=1, next(4)('b')=next(2)('b')=2, next(4)('d')=next(2)('d')=0”“由于trie(5)=next(trie(1))('c')=3, 我们可以补上从5出发的'a','b','c','d'这四条边：next(5)('a')=next(3)('a')=1, next(5)('b')=next(3)('b')=2, next(5)('c')=next(3)('c')=3, next(5)('d')=next(3)('d')=7”“由于trie(6)=next(trie(2))('c')=3, 我们可以补上从6出发的'a','b','c'这三条边：next(6)('a')=next(3)('a')=1, next(6)('b')=next(3)('b')=2, next(6)('c')=next(3)('c')=3”“由于trie(7)=next(trie(3))('d')=0, 我们可以补上从7出发的'a','b','c','d'这四条边：next(7)('a')=next(0)('a')=1, next(7)('b')=next(0)('b')=2, next(7)('c')=next(0)('c')=3, next(7)('d')=next(0)('d')=0”“由于trie(8)=next(trie(4))('c')=6, 我们可以补上从8出发的'a','b','c','d'这四条边：next(8)('a')=next(6)('a')=1, next(8)('b')=next(6)('b')=2, next(8)('c')=next(6)('c')=3, next(8)('d')=next(6)('d')=9”“由于trie(9)=next(trie(6))('d')=7, 我们可以补上从9出发的'a','b','c','d'这四条边：next(9)('a')=next(7)('a')=1, next(9)('b')=next(7)('b')=2, next(9)('c')=next(7)('c')=3, next(9)('d')=next(7)('d')=0”“此时这个图已经变得过于复杂了，我就不画出来了，但是我想你已经可以从我上面所说的知道每个节点的后缀结点了呢！”小Hi道。“原来如此！这样我就知道了每一个结点的后缀结点了，接下来我就可以很轻松的解决河蟹先生交给我的问题了呢！”小Ho高兴的说道：“但是，说好的Trie图在哪里呢？”小Hi不由笑道：“你这叫买椟还珠你知道么？还记得我们再计算后缀结点的时候计算出的从每个点出发，经由每一个char（比如'a'..'d'）会走到的结点么？把这些边添加到Trie树上，就是Trie图了！”“原来是这样，但是这些边感觉除了计算后缀结点之外，没有什么用处呀？”小Ho又开始问问题了。“这就是Trie图的巧妙之处了，你想想你什么时候需要知道一个结点的后缀结点？”小Hi实在不忍看自己的兄弟这般呆萌，只能耐着性子解释。小Ho顿时恍然大悟，“在这个结点不能够继续和文章str继续匹配了的时候，也就是这个结点没有“文章的下一个字符”对应的那条边，哦！我知道了，在Trie图中，每个结点都补全了所有的边，所以原来需要先找到后缀结点再根据“str的下一个字符”这样一条边找到下一个结点，现在可以直接通过当前结点的“str的下一个字符”这样一条边就可以接着往下匹配了，如果本来是有这条边的，那不用多说，而如果这条边是根据后缀结点补全的，那便是我们想要的结果！”“所以呢！完成这个任务的方法总的来说就是这样，先根据字典构建一棵Trie树，然后根据我们之前所说的构建出对应的Trie图，然后从Trie图的根节点开始，沿着文章str的每一个字符，走出对应的边，直到遇到一个标记结点或者整个str都已经匹配完成了~”小Hi适时的总结道。“而这样的时间复杂度则在O(NL+M)级别的呢！想来是足以完成河蟹先生的要求了呢~”小Ho搬了搬手指，说道。“是的！但是河蟹先生要求的可不是想法哦，他可是希望我们写出程序给它呢！”
http://blog.csdn.net/okcd00/article/details/40689177	小Hi和小Ho是一对好朋友，出生在信息化社会的他们对编程产生了莫大的兴趣，他们约定好互相帮助，在编程的学习道路上一同前进。这一天，他们遇到了一只河蟹，于是河蟹就向小Hi和小Ho提出了那个经典的问题：“小Hi和小Ho，你们能不能够判断一段文字（原串）里面是不是存在那么一些……特殊……的文字（模式串）？”小Hi和小Ho仔细思考了一下，觉得只能想到很简单的做法，但是又觉得既然河蟹先生这么说了，就肯定不会这么容易的让他们回答了，于是他们只能说道：“抱歉，河蟹先生，我们只能想到时间复杂度为（文本长度 * 特殊文字总长度）的方法，即对于每个模式串分开判断，然后依次枚举起始位置并检查是否能够匹配，但是这不是您想要的方法是吧？”河蟹点了点头，说道：”看来你们的水平还有待提高，这样吧，如果我说只有一个特殊文字，你能不能做到呢？“小Ho这时候还有点晕晕乎乎的，但是小Hi很快开口道：”我知道！这就是一个很经典的模式匹配问题！可以使用KMP算法进行求解！“河蟹满意的点了点头，对小Hi说道：”既然你知道就好办了，你去把小Ho教会，下周我有重要的任务交给你们！“”保证完成任务！”小Hi点头道。提示一：KMP的思路小Hi和小Ho回到了学校，为了完成河蟹托付的伟大使命，小Hi立马把小Ho抓到了机房开始上课。“小Ho，你来看看这样一段原串和模式串~”小Hi说着递上了一张纸条。原串：bababababababababb模式串：bababb“嗯，这个例子中模式串bababb在原串中第13个字符开始的地方出现了”小Ho看了看，回答道。“我们假设仍然使用最普通的方法来进行判断，即我们先枚举原串中的一个起始位置，然后判断从这个位置开始的字符串是否能和模式串进行完匹配。”小HI说道，“然后我们来看这个过程中有没有什么可以缩减的计算量。”“好的！”小Ho点点头。“你看，在起始点为1的时候，匹配到第6个字符的时候发生了失败，这个时候我们应当做的是是不是将模式串右移一位，然后从头开始判断，就像这样？”小Hi又在纸上画了画，递给了小Ho。“原串：bababababababababb模式串：bababb原串：bababababababababb模式串：  bababb”是的，然后我们发现第一位就发现不能进行匹配。“小Ho老老实实的回答。”然后我们再将模式串右移一位，然后再从头开始判断，这次我们成功的越过了原串的第7个字符，在第8个字符产生了不同。“小Hi继续往下推演。原串：bababababababababb模式串：    bababb”然后之后的剧情非常的相似，都是要么最后一个字符匹配不成功，要么就是第一个字符就匹配不成功，一直到了最后一次机会的时候才匹配成功。“小Ho做了总结。”那你觉得这个过程中有没有什么没有必要计算的呢？“小Hi于是问道。”我是这么认为的，你看这条线。“小Ho在两个串上对着的一个位置画了一条线。原串：babab | ababababababb模式串：babab | b”嗯？”“这是我们第一次产生了字符不匹配的情况，那么接下来的过程中一定会出现两种情况之一：一种情况是模式串与原串的对齐点（即枚举的原串中的起点位置）越过了这条线，仍然没能匹配成功，而另一种情况是原串中这个位置的字符与模式串中某个位置的字符匹配上了。”小Ho分析道：”我们先不考虑第一种情况，而来看看第二种情况会发生什么。“原串：babab | ababababababb模式串(对齐点=1)：babab | b模式串(对齐点=3)：    bab | a”看不出嘛，小Ho你今天变成聪明了嘛！~”小Hi由衷的赞叹道。“那当然，毕竟我最近在讨论区解答了很多问题，这很锻炼人的好么！“小Ho笑嘻嘻的回答道。”那我也得表现下，接下来换我来说吧，反正你肯定也就差不多想到这么多是吧！“小Hi也是看破了小Ho的底细，这般说道。于是小Ho点了点头，让小Hi接着说。”我相信一个很容易注意到的事实就在于，如果我用i表示原串和模式串产生分歧的位置（模式串上的位置，注意！这个和对齐点是不一样的东西，一个在原串上，一个在模式串上），用j表示为了匹配掉位置i上产生分歧的字符而将模式串的对齐点移动到的位置，我们会发现，模式串[1, i-j]的这一段和[j, i - 1]这一段是相同的。比如在这个例子中i=6,j=3，我们会发现模式串[1, 3]和[3,5]是相同的。“小Hi整理了下思路，如是说道。原串：ba | bab | a babababababb模式串(i=1)：ba | bab | b模式串(i=3)：     | bab | a”而我们同时也会发现，只有在存在一个长度k，使得模式串[1, i-k]和[k, i-1]这两段相同的情况下，将模式串对其到位置k，才能保证原串和模式串的匹配过程能够进入到原串的位置i是否和模式串的对应字符相同的判定，在别的情况下，根本都进入不到位置i的判断就会发生不一致的情况了。”说着小Hi又抛出了另外一个命题。“我已经开始有点晕了！”小Ho提出了抗议。“那你就好好的读一遍我刚才说的话！然后自己在草稿纸上演算一下这个样例，很快就可以得出结果的！”小Hi如是说道。”总而言之我们现在需要的一个数据是，这个长度k最长是多少，而且我们对于模式串的每一个位置i，都要计算这个值。”而这就是KMP中最为重要的一个点——NEXT数组。提示二：NEXT数组的使用“那么，为了能够充分理解NEXT数组，我们再来回顾一下如何使用NEXT数组~"小Hi摆出一副老师的样子，说道。”首先我们来给出NEXT数组的数学定义~“NEXT[0] = -1NEXT[i] = max{ 0<=k< i | str.substring(1, k) == str.substring(i - k +1 , i) } 其中str.substring(i, j)表示str从位置i到位置j的子串，如果i>j则,substring为空”那么我们对之前例子中的模式串进行求解，可以得到这样的NEXT数组。“小Hi在纸上写了又写，画了又画。模式串：b a b a b bNEXT：0 0 1 2 3 1”然后再来看这个NEXT数组是如何使用的！为了表明NEXT的所有使用情况，我们换一个原串。然后首先，我们第一次匹配，如果用ori表示原串，用par表示模式串，用p表示原串的下标（从1开始），用q表示模式串的下标（从1开始）的话，会发现最多匹配到p=5, q=5就不能往下匹配了，因为此时ori[p +1]不等于par[q + 1]“小Hi为了使说明更加简洁，先下了一堆定义。”好的！小Hi老师好棒！“小Ho在一旁煽风点火道。原串(p=5)：babab | abcbababababb模式串(q=5)：babab | b”此时，令q = NEXT[q]，并将ori[1..p]和par[1..q]对齐，便会发现ori[1..p]和par[1..q]仍然是一一对应的。“原串(p=5)：babab | abcbababababb模式串(q=3)：    bab | abb“此时，ori[p+1]和par[q+1]相同了，于是可以继续往下匹配，但是到了p=7,q=5的时候又发现不能够接着匹配了。”原串(p=7)：bababab | cbababababb模式串(q=5)：    babab | b”此时，令q = NEXT[q]，并将ori[1..p]和par[1..q]对齐，便会发现ori[1..p]和par[1..q]仍然是一一对应的，这和之前是一样的。”原串(p=7)：bababab | cbababababb模式串(q=3)：        bab | abb“此时，ori[p+1]和par[q+1]仍然不相同，于是还得令q=NEXT[q]。”原串(p=7)：bababab | cbababababb模式串(q=1)：            b | ababb“此时，ori[p+1]和par[q+1]仍然不相同，令q=NEXT[q]。”原串(p=7)：bababab | cbababababb模式串(q=0)：               | bababb“此时，ori[p+1]和par[q+1]仍然不相同，令q=NEXT[q]。”原串(p=7)：bababab | cbababababb模式串(q=-1)：               |   bababb”到了这一步，就相当于我们之前所说的模式串与原串的对齐点（即枚举的原串中的起点位置）越过了这条线（当时指C右侧的那条线）的情况，这种情况下，就应当p和q均+1，然后继续之前的操作。”小Hi擦了一把汗，说道。“这样一说，我就大致能够理解NEXT数组是怎么用来求解模式匹配问题的了，但是它是如何求的呢？一般的方法不是要O(模式串长度的立方）的么？”小Ho问道。“这就是我接下来要和你说的啦！”小Hi笑道：“但是让我先喝口水！”提示三：如何求解NEXT数组“首先我们不想如何求整个NEXT数组，而是假设我们已经知道了之前例子中模式串的NEXT[1..4]，来求NEXT[5]如何？”小Hi建议道。“好的！这样我们就只需要平方级的算法就可以算出它的值了！”小Ho高兴道。“有点追求好不好！”小Hi深深的吸了一口气：“你这样和之前的解法有什么不同么！”“似乎没有。。那你说怎么算吧！我反正脑子已经成浆糊了。”小Ho郁闷道。“我们把par.substring(1, 5)当做新的原串ori_new，然后把par.substring(1, 4)当做新的模式串par，会如何？”小Hi微微一笑。“会。。我来试试！"小Ho接过小Hi手中的纸笔，便开始演算：“首先就直接匹配到了p=4, q=4的情况，这时候严格来说已经算匹配完成了，但是肯定不是就这么结束的，此时par_new[q +1]因为是空字符，所以肯定和ori_new[p+1]匹配不上。于是令q = NEXT[q]”原串(p=4)：baba | b模式串(q=4)：baba |原串(p=4)：baba | b模式串(q=2)：    ba | b”然后这时候ori_new[p + 1]就直接和par_new[q + 1]匹配上了，于是新的p=5，q=3，莫非……这个最后的q就是NEXT[5]！“小Ho忽然灵光一闪。”没错，就是这样！那你想想现在如何求NEXT[6]。“小Hi继续引导小Ho。”首先我们没有必要重新从头开始匹配，直接在原串和模式串的后面加上第6个字符就可以了。“小Ho分析道。原串(p=5)：babab | b模式串(q=3)：    bab | abb”没法继续匹配，于是令q=NEXT[q]。“原串(p=5)：babab | b模式串(q=1)：        b | ababb”还是没法继续匹配，于是令q=NEXT[q]。“原串(p=5)：babab | b模式串(q=0)：           | bababb”此时可以匹配了，新的p=6,q=1，所以NEXT[6]就是1！“小Ho高兴道：”没想到NEXT数组的本身会用一种递归的方式进行求解，真是太巧妙了！“”那你要不要赶紧去写一下代码，KMP算法的代码可是可以写的很短很巧妙的哦！~“小Hi建议道。”好！“#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))int next[64]={0};char s[1024],p[64];void GetNext(char* p,int next[])  {      int pLen = strlen(p);      next[0] = -1;      int k = -1;      int j = 0;      while (j < pLen - 1)      {          //p[k]表示前缀，p[j]表示后缀          if (k == -1 || p[j] == p[k])           {              ++j;              ++k;              next[j] = k;          }          else           {              k = next[k];          }      }  }  //优化过后的next 数组求法  void GetNextval(char* p, int next[])  {      int pLen = strlen(p);      next[0] = -1;      int k = -1;      int j = 0;      while (j < pLen - 1)      {          //p[k]表示前缀，p[j]表示后缀            if (k == -1 || p[j] == p[k])          {              ++j;              ++k;              //较之前next数组求法，改动在下面4行              if (p[j] != p[k])                  next[j] = k;   //之前只有这一行              else                  //因为不能出现p[j] = p[ next[j ]]，所以当出现时需要继续递归，k = next[k] = next[next[k]]                  next[j] = next[k];          }          else          {              k = next[k];          }      }  }  int KmpSearch(char* s, char* p)  {      int i = 0;      int j = 0;      int sLen = strlen(s);      int pLen = strlen(p);      while (i < sLen && j < pLen)      {          //①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++              if (j == -1 || s[i] == p[j])          {              i++;              j++;          }          else          {              //②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]                  //next[j]即为j所对应的next值                    j = next[j];          }      }      if (j == pLen)          return i - j;      else          return -1;  }  int main(){while(1){cin>>s>>p;memset(next,0,sizeof next);if(s=="exit")break;//GetNext(p,next);GetNextval(p,next);printf("The KMP Ans: %d\n",KmpSearch(s,p));}return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/40688707	小Hi和小Ho是一对好朋友，出生在信息化社会的他们对编程产生了莫大的兴趣，他们约定好互相帮助，在编程的学习道路上一同前进。这一天，他们遇到了一本词典，于是小Hi就向小Ho提出了那个经典的问题：“小Ho，你能不能对于每一个我给出的字符串，都在这个词典里面找到以这个字符串开头的所有单词呢？”身经百战的小Ho答道：“怎么会不能呢！你每给我一个字符串，我就依次遍历词典里的所有单词，检查你给我的字符串是不是这个单词的前缀不就是了？”小Hi笑道：“你啊，还是太年轻了！~假设这本词典里有10万个单词，我询问你一万次，你得要算到哪年哪月去？”小Ho低头算了一算，看着那一堆堆的0，顿时感觉自己这辈子都要花在上面了...小Hi看着小Ho的囧样，也是继续笑道：“让我来提高一下你的知识水平吧~你知道树这样一种数据结构么？”小Ho想了想，说道：“知道~它是一种基础的数据结构，就像这里说的一样！”小Hi满意的点了点头，说道：“那你知道我怎么样用一棵树来表示整个词典么？”小Ho摇摇头表示自己不清楚。提示一：Trie树的建立提示一：Trie树的建立小Hi于是在纸上画了一会，递给小Ho，道：“你看这棵树和这个词典有什么关系？”小Ho盯着手里的纸想了一会道：“我知道了！对于从树的根节点走到每一个黑色节点所经过的路径，如果将路径上的字母都连起来的话，就都对应着词典中的一个单词呢！”小Hi说道：“那你知道如何根据一个词典构建这样一棵树么？”“不造！”“想你也不知道，我来告诉你吧~”小Hi摆出一副老师的样子，说道：“你先这么想，如果我已经有了这样的一个词典和对应的一棵树，我要添加一个新的单词apart，我应该怎么做？”“让我想想……”小Ho又开始苦思冥想：“首先我要先看看已经能走到哪一步了对吧？比如我从1号节点走"a"这一条边就可以走到2号节点，然后从2号节点走"p"这一条边可以走到3号节点，然后……就没路可走了！这时候我就需要添加一条从3号节点出发且标记为"p"的边才可以接着往下走……最后就是这样了！然后我把最后到达的这个结点标记为黑色就可以了。”小Hi说道：“真聪明~那你不妨再算算如果是一个有10W个单词的词典，每个单词的长度不超过10的话，这棵树会有多大？”小Ho于是掏出笔来，一边画一遍念叨：“假设我已经将前三个单词构成了这样一棵树，那么我要添加一个新的单词的时候，最坏情况是这个单词和之前的三个单词都没有公共前缀，那么这个新的单词的长度如果是5的话，我就至少要添加5个结点到树中才能够继续表示这个词典！”“而如果每次都是最坏情况的话，这棵树最多也就100W个结点这么大！更何况最坏情况是不可能次次都发生的！毕竟字母表也才26个字母呢！”小Ho继续说道。“嗯~这样我们是不是就可以用（单词个数*单词长度）个结点来表示一个词典了呢？小Hi问道。“是的呢！”小Ho道：“但是这样一棵树又有什么用呢？”“可别小看了它，它就是传说中的Trie树哦~至于他有什么用，一会你就知道了！”小Hi笑嘻嘻的回答道。“你看，我们现在得到了这样一棵树，那么你看，如果我给你一个字符串ap，你要怎么找到所有以ap开头的单词呢？”小Hi又开始考校小Ho。“唔...一个个遍历所有的单词？”小Ho还是不忘自己最开始提出来的算法。“笨！这棵树难道就白构建了！”小Hi教训完小Ho，继续道：“看好了！”提示二：如何使用Trie树提示二：如何使用Trie树小Hi在树上用绿色标出了一个节点，递给小Ho。“这个结点……是从根节点先走"a"然后走"p"到达的结点呢！哦~~我知道了，以这个结点为根的子树里所有标记结点都是以"ap"为前缀的单词呢！而且所有以"ap"为前缀的单词都在以这个节点为根的子树里~”小Ho惊喜道。“是的呢~那你对怎么解决我的问题有想法了么？”小Hi追问道。“唔...那就是每次拿到你的字符串之后，我在树上找到其对应的那个结点，然后统计这个节点中有多少个标记节点？”小Ho不是很确定的答道：“但是这样...似乎在最坏情况，也就是你每次给个字符串都很短的时候，我还是要扫描这棵树的很大一部分呢？也就是说虽然平均时间复杂度降低了，但是最坏情况时间复杂度还是很高的样子！”小Hi笑嘻嘻道：”没想到你自己看出来了呢~我还以为又要教训你了！~那你有什么好的解决方法么？”“没呢！小Hi你就别卖关子了，赶紧告诉我吧！”被折磨的够呛的小Ho开始求饶。“好吧！就帮你这一回~”提示三：在建立Trie树时同时进行统计！“小Ho你有没有想过这样一个问题？不妨称以T为根的子树中标记节点的个数为L[T]，既然我要统计某个L[T1]，，而这个结点是不确定的，我有没有办法一次性把所有结点的L[T]求出来呢？”小Hi整理了下思绪，问道。“似乎是有的，老师以前说过，递归什么的。。”小Ho答道。“递归太复杂了！我们可以之后再说，你这么想，在你构建Trie树的时候，当你经过一个结点的时候，说明了什么？”小Hi撇了撇头，继续问道。“我想想，经过一个结点……标记结点……说明了以这个结点为根的子树中将要多出来一个标记结点？”“没错！那你有没有什么办法来记录这个改变呢？”“我想想，我在最开始置所有L[T]=0，然后每次添加一个新的单词的时候，都将它经过的所有结点的L[T]全部+1，这样我构建完这棵Trie树的时候，我也就能够同时统计到所有L[T]了，对么？”小Ho开心道。“那么现在！赶紧去用代码实现吧！”小Hi如是说道
http://blog.csdn.net/okcd00/article/details/40688487	<a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=fBMXHxhMTDwNDVIfExE" style="text-decoration:none;"><img src="http://rescdn.qqmail.com/zh_CN/htmledition/images/function/qm_open/ico_mailme_21.png"/></a>尝试了一下~效果如下~~~版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/40589695	A. Chipstime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputThere are n walruses sitting in a circle. All of them are numbered in the clockwise order: the walrus number 2 sits to the left of the walrus number 1, the walrus number 3 sits to the left of the walrus number 2, ..., the walrus number 1 sits to the left of the walrus number n.The presenter has m chips. The presenter stands in the middle of the circle and starts giving the chips to the walruses starting from walrus number 1 and moving clockwise. The walrus number i gets i chips. If the presenter can't give the current walrus the required number of chips, then the presenter takes the remaining chips and the process ends. Determine by the given n and m how many chips the presenter will get in the end.InputThe first line contains two integers n and m (1 ≤ n ≤ 50, 1 ≤ m ≤ 104) — the number of walruses and the number of chips correspondingly.OutputPrint the number of chips the presenter ended up with.Sample test(s)input4 11output0input17 107output2input3 8output1NoteIn the first sample the presenter gives one chip to the walrus number 1, two chips to the walrus number 2, three chips to the walrus number 3, four chips to the walrus number 4, then again one chip to the walrus number 1. After that the presenter runs out of chips. He can't give anything to the walrus number 2 and the process finishes.In the third sample the presenter gives one chip to the walrus number 1, two chips to the walrus number 2, three chips to the walrus number 3, then again one chip to the walrus number 1. The presenter has one chip left and he can't give two chips to the walrus number2, that's why the presenter takes the last chip.有n个小盆友坐成一圈等着发薯条吃，编号为1-n，每个人发的薯条数为他们的编号，问这么一直发下去最后到某个地方发不下去了的时候剩几根薯条。因为我们一圈一圈发，而每一圈的薯条数是一定的，故可以直接除以一整圈的薯条数，直接拿余数来模拟（因为这些都被之前的整圈发完了，肯定在最后一圈的时候停下）代码如下：#include <cstdio>#include <string>#include <cstring> #include <iostream>#include <algorithm>using namespace std;typedef long long ll;// http://codeforces.com/contest/92// Chipsint main(){int n,m;cin>>n>>m;int sum=(1+n)*n/2;m=m%sum;for(int i=1;i<=n;i++){if(m>=i) m-=i;else break;}cout<<m;return 0;} 版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/40589371	A. Cablewaytime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputA group of university students wants to get to the top of a mountain to have a picnic there. For that they decided to use a cableway.A cableway is represented by some cablecars, hanged onto some cable stations by a cable. A cable is scrolled cyclically between the first and the last cable stations (the first of them is located at the bottom of the mountain and the last one is located at the top). As the cable moves, the cablecar attached to it move as well.The number of cablecars is divisible by three and they are painted three colors: red, green and blue, in such manner that after each red cablecar goes a green one, after each green cablecar goes a blue one and after each blue cablecar goes a red one. Each cablecar can transport no more than two people, the cablecars arrive with the periodicity of one minute (i. e. every minute) and it takes exactly 30minutes for a cablecar to get to the top.All students are divided into three groups: r of them like to ascend only in the red cablecars, g of them prefer only the green ones and bof them prefer only the blue ones. A student never gets on a cablecar painted a color that he doesn't like,The first cablecar to arrive (at the moment of time 0) is painted red. Determine the least time it will take all students to ascend to the mountain top.InputThe first line contains three integers r, g and b (0 ≤ r, g, b ≤ 100). It is guaranteed that r + g + b > 0, it means that the group consists of at least one student.OutputPrint a single number — the minimal time the students need for the whole group to ascend to the top of the mountain.Sample test(s)input1 3 2output34input3 2 1output33NoteLet's analyze the first sample.At the moment of time 0 a red cablecar comes and one student from the r group get on it and ascends to the top at the moment of time30.At the moment of time 1 a green cablecar arrives and two students from the g group get on it; they get to the top at the moment of time31.At the moment of time 2 comes the blue cablecar and two students from the b group get on it. They ascend to the top at the moment of time 32.At the moment of time 3 a red cablecar arrives but the only student who is left doesn't like red and the cablecar leaves empty.At the moment of time 4 a green cablecar arrives and one student from the g group gets on it. He ascends to top at the moment of time34.Thus, all the students are on the top, overall the ascension took exactly 34 minutes.发现现在这样的A题好多呀，就是一个数组，每次来一个操作，直到某个条件满足时为止。因为数据范围小所以可以直接模拟，这题也是一样，有红绿蓝三种颜色的索道，按照红绿蓝的顺序每分钟来一个，每个索道的缆车每次最多搭载2个人，问啥时候所有人都送上山总共要花多少时间（上山的时间是30Min别忘了加上）那么我们就模拟一下，直到没人了为止，每次按顺序红绿蓝地每次减二（别忘了如果没人了不能减应该归零）。Code：#include <cstdio>#include <string>#include <cstring> #include <iostream>#include <algorithm>using namespace std;typedef long long ll;// http://codeforces.com/contest/90// Cablewayint main(){int r,g,b,now=29;cin>>r>>g>>b;int n[3]={r,g,b};while(n[0]+n[1]+n[2]){now++;if(n[now%3]>=2) n[now%3]-=2;else n[now%3]=0;} cout<<now;return 0;} 版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/40508857	A. Chordtime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputVasya studies music.He has learned lots of interesting stuff. For example, he knows that there are 12 notes: C, C#, D, D#, E, F, F#, G, G#, A, B, H. He also knows that the notes are repeated cyclically: after H goes C again, and before C stands H. We will consider the C note in the row's beginning and the C note after the H similar and we will identify them with each other. The distance between the notes along the musical scale is measured in tones: between two consecutive notes there's exactly one semitone, that is, 0.5 tone. The distance is taken from the lowest tone to the uppest one, that is, the distance between C and E is 4 semitones and between Eand C is 8 semitonesVasya also knows what a chord is. A chord is an unordered set of no less than three notes. However, for now Vasya only works with triads, that is with the chords that consist of exactly three notes. He can already distinguish between two types of triads — major and minor.Let's define a major triad. Let the triad consist of notes X, Y and Z. If we can order the notes so as the distance along the musical scale between X and Y equals 4 semitones and the distance between Y and Z is 3 semitones, then the triad is major. The distance between X and Z, accordingly, equals 7 semitones.A minor triad is different in that the distance between X and Y should be 3 semitones and between Y and Z — 4 semitones.For example, the triad "C E G" is major: between C and E are 4 semitones, and between E and G are 3 semitones. And the triplet "C# B F" is minor, because if we order the notes as "B C# F", than between B and C# will be 3 semitones, and between C# andF — 4 semitones.Help Vasya classify the triad the teacher has given to him.InputThe only line contains 3 space-separated notes in the above-given notation.OutputPrint "major" if the chord is major, "minor" if it is minor, and "strange" if the teacher gave Vasya some weird chord which is neither major nor minor. Vasya promises you that the answer will always be unambiguous. That is, there are no chords that are both major and minor simultaneously.Sample test(s)inputC E GoutputmajorinputC# B FoutputminorinputA B Houtputstrange这是一道音乐上的题目，说有三个琴键同时按下组成和弦，如果三个键从左到右分别相差4、3个音阶的话算作major和弦，相差4、3个则为minor，啥都不是就会很strange给三个琴键问是哪种和弦。枚举当然可以啦，反正也就3！=6种组合，只是感觉这么来的话没有用到算法多不高兴呀~那么我们就先在钢琴上给他们排个序呗，排好了序之后称作A\B\C（在一个12音阶中严格从左到右），那么我们只需要判断 ABC\BCA\CAB 三种情形下是否满足相差3、4或者4、3即可。#include <cstdio>#include <string>#include <cstring> #include <iostream>#include <algorithm>using namespace std;// http://codeforces.com/contest/88// Chordstring notes[12]={"C","C#","D","D#","E","F","F#","G","G#","A","B","H"};int dist(string a, string b, string c){int pos[3]={0};for(int i=0;i<12;i++){if(notes[i]==a) pos[0]=i;if(notes[i]==b) pos[1]=i;if(notes[i]==c) pos[2]=i;}sort(pos,pos+3);//cout<<pos[0]<<pos[1]<<pos[2]<<endl;int dis[3]={pos[1]-pos[0],pos[2]-pos[1],pos[0]+12-pos[2] };for(int i=0;i<3;i++){if(dis[i]==4 && dis[(i+1)%3]==3)return 1;if(dis[i]==3 && dis[(i+1)%3]==4)return 2;}return 0;}int main(){string X,Y,Z;cin>>X>>Y>>Z;int flag=dist(X,Y,Z);  if(flag==1)cout<<"major";else if(flag==2)cout<<"minor";else cout<<"strange";return 0;} 版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/40508097	A. Toy Armytime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputThe hero of our story, Valera, and his best friend Arcady are still in school, and therefore they spend all the free time playing turn-based strategy "GAGA: Go And Go Again". The gameplay is as follows.There are two armies on the playing field each of which consists of n men (n is always even). The current player specifies for each of her soldiers an enemy's soldier he will shoot (a target) and then all the player's soldiers shot simultaneously. This is a game world, and so each soldier shoots perfectly, that is he absolutely always hits the specified target. If an enemy soldier is hit, he will surely die. It may happen that several soldiers had been indicated the same target. Killed soldiers do not participate in the game anymore.The game "GAGA" consists of three steps: first Valera makes a move, then Arcady, then Valera again and the game ends.You are asked to calculate the maximum total number of soldiers that may be killed during the game.InputThe input data consist of a single integer n (2 ≤ n ≤ 108, n is even). Please note that before the game starts there are 2nsoldiers on the fields.OutputPrint a single number — a maximum total number of soldiers that could be killed in the course of the game in three turns.Sample test(s)input2output3input4output6NoteThe first sample test:1) Valera's soldiers 1 and 2 shoot at Arcady's soldier 1.2) Arcady's soldier 2 shoots at Valera's soldier 1.3) Valera's soldier 1 shoots at Arcady's soldier 2.There are 3 soldiers killed in total: Valera's soldier 1 and Arcady's soldiers 1 and 2.这题的代码长度已经突破天际了……意思是 有两组部队，V军和A军，V军先攻击然后轮到A军然后轮到V军。每个军人每次只能打死一个敌人但是必中必死，问就这三轮攻击最多死多少人。死的最多即活着的最少。最后一轮攻击后假设或者k个人，那么他们在最后一轮攻击的时候杀了敌人的k个人且是敌军的最后k个人，而这k个人活着的时候杀了这半边的k个人，再向前追溯一次就是第一次V军攻击的结果是：这边有2k个人，杀了对面一些人之后对面剩下k个，因为两边最初都是n个人，为了让杀的人最多，那么2k=n，所以死了3k的人，即n的1.5倍。读入然后输出1.5倍即可。#include <iostream>using namespace std;// http://codeforces.com/contest/84// Toy Armyint main(){int n;cin>>n;cout<<n/2*3;return 0;} 版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/40507755	A. Bus Gametime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputAfter Fox Ciel won an onsite round of a programming contest, she took a bus to return to her castle. The fee of the bus was 220 yen. She met Rabbit Hanako in the bus. They decided to play the following game because they got bored in the bus.Initially, there is a pile that contains x 100-yen coins and y 10-yen coins.They take turns alternatively. Ciel takes the first turn.In each turn, they must take exactly 220 yen from the pile. In Ciel's turn, if there are multiple ways to take 220 yen, she will choose the way that contains the maximal number of 100-yen coins. In Hanako's turn, if there are multiple ways to take 220 yen, she will choose the way that contains the maximal number of 10-yen coins.If Ciel or Hanako can't take exactly 220 yen from the pile, she loses.Determine the winner of the game.InputThe first line contains two integers x (0 ≤ x ≤ 106) and y (0 ≤ y ≤ 106), separated by a single space.OutputIf Ciel wins, print "Ciel". Otherwise, print "Hanako".Sample test(s)input2 2outputCielinput3 22outputHanakoNoteIn the first turn (Ciel's turn), she will choose 2 100-yen coins and 2 10-yen coins. In the second turn (Hanako's turn), she will choose 1 100-yen coin and 12 10-yen coins. In the third turn (Ciel's turn), she can't pay exactly 220 yen, so Ciel will lose.原先看到这个题说谁赢谁输还以为是博弈……意思是有x枚100元硬币、y枚10元硬币，两个人轮流取钱每次取220元，Ciel（希尔）每次尽可能多的取100元硬币，Hanako（花子）则每次尽可能多的取10元硬币（意味不明……），然后问谁第一次没法取了另一个人就赢了。那么我们就模拟他们取硬币的过程吧。希尔（Ciel）的话，100元不小于2个的情况下就取2个加上2个10元的，不足2个就取光剩下的10元来凑Hanako反之，同理。自然，当总钱数不足220或者10元硬币不足2个的时候失败。代码如下：#include <cstdio>#include <string>#include <cstring> #include <iostream>#include <algorithm>using namespace std;typedef long long ll;// http://codeforces.com/contest/79// Bus Gameint main(){int x,y,turn=1;//1-Ciel 2-Hanakocin>>x>>y;while(turn){if(y<2 || 100*x+10*y<220) break;if(turn==1){if(x>=2)x-=2,y-=2;else if(x==1)x-=1,y-=12;else if(x==0)y-=22;}else if(turn==2){if(y>=22)y-=22;else if(y>=12)y-=12,x-=1;else if(y>=2)y-=2,x-=2;}turn = 3-turn;}if(turn==1)printf("Hanako");else printf("Ciel");return 0;} 版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/40505665	A. Haikutime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputHaiku is a genre of Japanese traditional poetry.A haiku poem consists of 17 syllables split into three phrases, containing 5, 7 and 5 syllables correspondingly (the first phrase should contain exactly 5 syllables, the second phrase should contain exactly 7 syllables, and the third phrase should contain exactly 5 syllables). A haiku masterpiece contains a description of a moment in those three phrases. Every word is important in a small poem, which is why haiku are rich with symbols. Each word has a special meaning, a special role. The main principle of haiku is to say much using a few words.To simplify the matter, in the given problem we will consider that the number of syllable in the phrase is equal to the number of vowel letters there. Only the following letters are regarded as vowel letters: "a", "e", "i", "o" and "u".Three phases from a certain poem are given. Determine whether it is haiku or not.InputThe input data consists of three lines. The length of each line is between 1 and 100, inclusive. The i-th line contains the i-th phrase of the poem. Each phrase consists of one or more words, which are separated by one or more spaces. A word is a non-empty sequence of lowercase Latin letters. Leading and/or trailing spaces in phrases are allowed. Every phrase has at least one non-space character. See the example for clarification.OutputPrint "YES" (without the quotes) if the poem is a haiku. Otherwise, print "NO" (also without the quotes).Sample test(s)inputon  codeforces beta round is running   a rustling of keys outputYESinputhow many gallonsof edo s rain did you drink                                cuckoooutputNO给三句话问这是不是俳句~啊啦，做题目还可以学知识，妙哉妙哉~俳句是日本的一种古典短诗，由“五-七-五”，共十七字音组成，要求严格，受“季语”的限制。不过这里我们的题目被简化了，问三句里的元音字母是否是5/7/5的%……（嫌弃脸）好吧，遍历一遍数数字拿分走人这里因为每行中间是有空格的，而string的cin每次都会遇到空格结束，我们想一下读入一行怎么办呢？getline()函数—— getline(cin,s)就是在控制台录入单行赋值给s，这里cin是可以换成fin啥的哦，因为有的时候我们还需要文件读入呢~#include <cstdio>#include <string>#include <cstring> #include <iostream>#include <algorithm>using namespace std;typedef long long ll;// http://codeforces.com/contest/78 // Haikuint judge(string s,int n){int cnt=7-n%2*2;for(int i=0;i<s.length();i++){if(s[i]=='a'||s[i]=='e'||s[i]=='i'||s[i]=='o'||s[i]=='u')cnt--;}if(!cnt)return n;else return 0;}int main(){string s;int flag=0; for(int i=1;i<=3;i++){ getline(cin,s); flag+=judge(s,i);}if(flag==6)cout<<"YES";else cout<<"NO";return 0;} 版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/40505439	最近看到群里讨论起了JAVA里的final可否修改值的问题，然后引申到了C++的const……觉得还是写一个关于const int* 的东西好了……翻了下以前给@Zoecur 看的 const 的帖子，也在这里贴一下好了：http://triumple163.blog.163.com/blog/static/1279782662009102594241969/用两个简单的程序给你们看看：#include<iostream>using namespace std;int main(){int a[10];const int *p= a;//const int *a=new int[10];a[0] = 1;return 0;} 编译器: TDM-GCC 4.8.1 64-bit Release执行 g++.exe...g++.exe "D:\Temp\未命名1.cpp" -o "D:\Temp\未命名1.exe" -g3 -I"C:\Program Files (x86)\Dev-Cpp\MinGW64\include" -I"C:\Program Files (x86)\Dev-Cpp\MinGW64\x86_64-w64-mingw32\include" -I"C:\Program Files (x86)\Dev-Cpp\MinGW64\lib\gcc\x86_64-w64-mingw32\4.8.1\include" -I"C:\Program Files (x86)\Dev-Cpp\MinGW64\lib\gcc\x86_64-w64-mingw32\4.8.1\include\c++" -L"C:\Program Files (x86)\Dev-Cpp\MinGW64\lib" -L"C:\Program Files (x86)\Dev-Cpp\MinGW64\x86_64-w64-mingw32\lib" -static-libgcc -g3编译 0.81 秒后成功#include<iostream>using namespace std;int main(){//int a[10];//const int *p= a;const int *a=new int[10];a[0] = 1;return 0;} 9 7D:\Temp\未命名1.cpp[Error] assignment of read-only location '* a'所以呢，我们可以const int* a来指向一个已声明的数组地址，这样的话我们无法修改*a 但是却可以修改 a[n]然而使用new的话我们可以新建一个容量为10的数组，但是无法更改其中的值。大概就说到这就差不多了吧~ 主要是说一下指针常量而已啊刚刚老师来提醒我说还可以把const放后面就可以用new了~#include<iostream>using namespace std;int main(){//int a[10];//const int *p= a;int* const a=new int[10];a[0] = 1;return 0;} 编译器: TDM-GCC 4.8.1 64-bit Release执行 g++.exe...g++.exe "D:\Temp\未命名1.cpp" -o "D:\Temp\未命名1.exe" -g3 -I"C:\Program Files (x86)\Dev-Cpp\MinGW64\include" -I"C:\Program Files (x86)\Dev-Cpp\MinGW64\x86_64-w64-mingw32\include" -I"C:\Program Files (x86)\Dev-Cpp\MinGW64\lib\gcc\x86_64-w64-mingw32\4.8.1\include" -I"C:\Program Files (x86)\Dev-Cpp\MinGW64\lib\gcc\x86_64-w64-mingw32\4.8.1\include\c++" -L"C:\Program Files (x86)\Dev-Cpp\MinGW64\lib" -L"C:\Program Files (x86)\Dev-Cpp\MinGW64\x86_64-w64-mingw32\lib" -static-libgcc -g3编译 0.75 秒后成功版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/40481751	老师布置了个作业的说……然后就试试看写咯~#include <stdio.h>#include <pthread.h>#include <unistd.h>#include <stdlib.h>//use "gcc test01.c -o thread -lpthread" to compileint n=0;int mode=0;int arr[1024]={0};void maxv(void* args){        sleep(1);        int _max=-1,i=0;        for(i=0;i<n;i++)_max=(_max<arr[i]?arr[i]:_max);        if(mode) while(1) {sleep(1);printf("thr_1:the maximal value is: %d\n",_max);}        else printf("the maximal value is: %d\n",_max);}void minv(void* args){        sleep(2);        int _min=9999,i=0;        for(i=0;i<n;i++)_min=(_min>arr[i]?arr[i]:_min);        if(mode) while(1) {sleep(2);printf("thr_2:the minimal value is: %d\n",_min);}        else printf("the minimal value is: %d\n",_min);}void avgv(void* args){        sleep(3);        int sum=0,i=0;        for(i=0;i<n;i++)sum+=arr[i];        if(mode) while(1) {sleep(3);printf("thr_3:the average value is: %d\n",sum/n);}        else printf("the average value is: %d\n",sum/n);}int main(){        int tmp=0;        printf("Please Input numbers split by blanks(zero means end)\n");        while(scanf("%d",&tmp) && tmp) arr[n++]=tmp;        printf("If you want to show how thread works input '1',otherwise '0'\n");        scanf("%d",&mode);        pthread_t pid1,pid2,pid3;        printf("Author: Chendian 20125209 Class:IOT01\n");        printf("=====Multi Pthread Program Test01=====\n");        if(pthread_create(&pid1,NULL,maxv,NULL)){printf("pid1 is wrong\n");return -1;}        if(pthread_create(&pid2,NULL,minv,NULL)){printf("pid2 is wrong\n");return -1;}        if(pthread_create(&pid3,NULL,avgv,NULL)){printf("pid3 is wrong\n");return -1;}        while(1){sleep(3);}        printf("=====Multithread Program Test End=====\n");        return 0;}需要注意的其实也不多…… 使用UnixC编的东西在Linux编译的时候需要使用gcc -c xxxxx这样的指令，然而我们使用的是多线程，所以还少了个库需要添加，所以要多一个参数，gcc test01.c -o thread -lpthread这样来编译即可，作用为把 test01.c 的文件使用lpthread编译，输出为thread文件，运行的时候就./thread就可以啦~~~运行结果： （啊对了average老师要求用int的，不是我不愿意用double哦~）版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/40444763	A. Panoramix's Predictiontime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputA prime number is a number which has exactly two distinct divisors: one and itself. For example, numbers 2, 7, 3 are prime, and 1, 6,4 are not.The next prime number after x is the smallest prime number greater than x. For example, the next prime number after 2 is 3, and the next prime number after 3 is 5. Note that there is exactly one next prime number after each number. So 5 is not the next prime number for 2.One cold April morning Panoramix predicted that soon Kakofonix will break free from his straitjacket, and this will be a black day for the residents of the Gallic countryside.Panoramix's prophecy tells that if some day Asterix and Obelix beat exactly x Roman soldiers, where x is a prime number, and next day they beat exactly y Roman soldiers, where y is the next prime number after x, then it's time to wait for Armageddon, for nothing can shut Kakofonix up while he sings his infernal song.Yesterday the Gauls beat n Roman soldiers and it turned out that the number n was prime! Today their victims were a troop of mRomans (m > n). Determine whether the Gauls should wait for the black day after today's victory of Asterix and Obelix?InputThe first and only input line contains two positive integers — n and m (2 ≤ n < m ≤ 50). It is guaranteed that n is prime.Pretests contain all the cases with restrictions 2 ≤ n < m ≤ 4.OutputPrint YES, if m is the next prime number after n, or NO otherwise.Sample test(s)input3 5outputYESinput7 11outputYESinput7 9outputNO问m是不是n的下一个整数，那就先把50以内的素数背出来呗~然后从第一个开始一个一个往下看~ 啊当然如果m不在这个素数表里那肯定就是NO啦，然后看n是否在m和m前的素数间啦，要注意的是区间范围是左闭右开哦#include <cstdio>#include <string>#include <cstring> #include <iostream>#include <algorithm>using namespace std;typedef long long ll;// http://codeforces.com/contest/80  // Panoramix's Prediction1 int prime[]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47};int main(){int n,m;cin>>n>>m;for(int i=0;i<=14;i++){if(prime[i]>n){if(prime[i]==m){cout<<"YES";return 0;}cout<<"NO";return 0;}}cout<<"NO";return 0;} 版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/40445751	A. Diverse Permutationtime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputPermutation p is an ordered set of integers p1,   p2,   ...,   pn, consisting of n distinct positive integers not larger than n. We'll denote as n the length of permutation p1,   p2,   ...,   pn.Your task is to find such permutation p of length n, that the group of numbers |p1 - p2|, |p2 - p3|, ..., |pn - 1 - pn| has exactly k distinct elements.InputThe single line of the input contains two space-separated positive integers n, k (1 ≤ k < n ≤ 105).OutputPrint n integers forming the permutation. If there are multiple answers, print any of them.Sample test(s)input3 2output1 3 2input3 1output1 2 3input5 2output1 3 2 4 5NoteBy |x| we denote the absolute value of number x.吾辈的Div1的第一场，只做出来了A题（也就是Div2的C），19Min出的名次为我采取的是来回弹的方式~ 咱们1、1+k、2、k、3、k-1…… 这样是不是就是k、k-1、k-2……了呀^_^，等k一路到1之后，把没用到的数字按顺序排一遍~这样为啥成呢~ 首先，这样一定可以保证k一路到1的绝对值都存在，请使用数学归纳法~其次，为啥按顺序把剩下的写出来不会超出k呢？ 因为我们是从1和k+1两侧向中间走，所以最后剩一个数字和他后头那个数字的差距是k/2，依旧可行。代码如下：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}bool usd[100086];int main(){int n,k,f=1,now;scanf("%d%d",&n,&k);memset(usd,false,sizeof usd);for(int i=1;i<=k;i++){if(f) now=(i+1)/2;else now=2+k-i/2;f=1-f;if(i-1)printf(" %d",now);else printf("%d",now);usd[now]=true;}//cout<<"then"<<endl;for(int i=1;i<=n;i++){if(usd[i]==false)printf(" %d",i);}return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/40304213	A. Room Leadertime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputLet us remind you part of the rules of Codeforces. The given rules slightly simplified, use the problem statement as a formal document.In the beginning of the round the contestants are divided into rooms. Each room contains exactly n participants. During the contest the participants are suggested to solve five problems, A, B, C, D and E. For each of these problem, depending on when the given problem was solved and whether it was solved at all, the participants receive some points. Besides, a contestant can perform hacks on other contestants. For each successful hack a contestant earns 100 points, for each unsuccessful hack a contestant loses 50points. The number of points for every contestant is represented by the sum of points he has received from all his problems, including hacks.You are suggested to determine the leader for some room; the leader is a participant who has maximum points.InputThe first line contains an integer n, which is the number of contestants in the room (1 ≤ n ≤ 50). The next n lines contain the participants of a given room. The i-th line has the format of "handlei plusi minusi ai bi ci di ei" — it is the handle of a contestant, the number of successful hacks, the number of unsuccessful hacks and the number of points he has received from problems A, B,C, D, E correspondingly. The handle of each participant consists of Latin letters, digits and underscores and has the length from 1to 20 characters. There are the following limitations imposed upon the numbers:0 ≤ plusi, minusi ≤ 50;150 ≤ ai ≤ 500 or ai = 0, if problem A is not solved;300 ≤ bi ≤ 1000 or bi = 0, if problem B is not solved;450 ≤ ci ≤ 1500 or ci = 0, if problem C is not solved;600 ≤ di ≤ 2000 or di = 0, if problem D is not solved;750 ≤ ei ≤ 2500 or ei = 0, if problem E is not solved.All the numbers are integer. All the participants have different handles. It is guaranteed that there is exactly one leader in the room (i.e. there are no two participants with the maximal number of points).OutputPrint on the single line the handle of the room leader.Sample test(s)input5Petr 3 1 490 920 1000 1200 0tourist 2 0 490 950 1100 1400 0Egor 7 0 480 900 950 0 1000c00lH4x0R 0 10 150 0 0 0 0some_participant 2 1 450 720 900 0 0outputtouristNoteThe number of points that each participant from the example earns, are as follows:Petr — 3860tourist — 4140Egor — 4030c00lH4x0R —  - 350some_participant — 2220Thus, the leader of the room is tourist.这又是一道读入的时候更新最大值类型的问题……真的不知道该划分到哪个类型……直接就写个【水】不好意思哦……每次读入的时候就把这个人的分数算出来，如果是最大的就把最大值更新一下即可。Code：#include <map>#include <stack>#include <queue>#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int main(){int cases=0;scanf("%d",&cases);int max=-2999;string win="";for(int _case=1;_case<=cases;_case++){string name; int p,m,a,b,c,d,e,score;cin>>name>>p>>m>>a>>b>>c>>d>>e;score=p*100-m*50+a+b+c+d+e;if (score>max) max=score,win=name;}cout<<win;return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/40304027	A. Life Without Zerostime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputCan you imagine our life if we removed all zeros from it? For sure we will have many problems.In this problem we will have a simple example if we removed all zeros from our life, it's the addition operation. Let's assume you are given this equation a + b = c, where a and b are positive integers, and c is the sum of a and b. Now let's remove all zeros from this equation. Will the equation remain correct after removing all zeros?For example if the equation is 101 + 102 = 203, if we removed all zeros it will be 11 + 12 = 23 which is still a correct equation.But if the equation is 105 + 106 = 211, if we removed all zeros it will be 15 + 16 = 211 which is not a correct equation.InputThe input will consist of two lines, the first line will contain the integer a, and the second line will contain the integer b which are in the equation as described above (1 ≤ a, b ≤ 109). There won't be any leading zeros in both. The value of c should be calculated as c = a + b.OutputThe output will be just one line, you should print "YES" if the equation will remain correct after removing all zeros, and print "NO" otherwise.Sample test(s)input101102outputYESinput105106outputNO这道题呀，题意是说给你两个数字（然后你自己算出他们的和），如果把加数以及他们的和里面的零都去掉，这个等式是否还成立那么就直接把去掉零之后的数字都求出来，计算一下看是不是成立就好啦~ 咱们模拟一下就好~ 需要注意一下这个弃掉0的函数怎么写就好^_^int del0(int x){int ret=0,tmp=x,time=1; //tmp是这个数字，ret是用来存储去掉0的返回值 while(tmp){int digit=tmp%10;//获得当前最低位的数字 if(digit) ret+=(time)*digit,time*=10;//如果不是0就加进去，是0的话无视掉 tmp/=10;}return ret;}Code：#include <cstdio>#include <string>#include <cstring> #include <iostream>#include <algorithm>using namespace std;typedef long long ll;int del0(int x){int ret=0,tmp=x,time=1;while(tmp){int digit=tmp%10;if(digit) ret+=(time)*digit,time*=10;tmp/=10;}return ret;}int main(){int a,b;cin>>a>>b;int c=a+b;//cout<< del0(c)<<": "<<del0(a)<<": "<<del0(b)<<endl;if(del0(c)==del0(a)+del0(b))cout<<"YES"<<endl;else cout<<"NO"<<endl;return 0;} 版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/40284267	鞍山现场赛结束了呢…… 我们出的是D+E+I三道题……吾辈AC掉的是D和I两道，趁着还记得，先在这里写一写我写的两道水题D&I的解题报告吧^_^。D题的意思呢是说星云内有一堆排成一条直线的小行星们，给出每个小行星所处在的距离我们需要让小行星距离重心距离的平方和最小 （Σdi^2）（啊细节记忆不太清楚就帮大家简化题意了哦^_^）我们最多可以移动k个小行星，问最优状态下上述平方和最小为多少首先我们知道，k肯定是需要用满的，反证非k次移动一定不优于k次即可。然后就是如何移动的问题，我们将输入数据按升序排列后，j从0到k枚举，即从左边拿出j个，从右边拿出k-j个，然后把这些都放在剩余的星星们的重心上（即可以无视），只要计算此时的平方和然后找最小值即可但是——TLE了……然后立马想到了一个剪枝，就是如果加到某一个值的时候已经比当前minv大了，就可以不继续加来检查下一种情况了队友们不相信这也能过……于是等到队友们闲下来……交了一下……就AC了……（后记：哎呀我去……HDU模拟赛出来之后交了一发TLE了……所以下面这个算法是错的……还是说现场赛的机子算得快？）Code：#include <string>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;int n,k,d[50055];ll sumd[50055];ll getsum(int i,int j) //[i,j){if(i)return sumd[j-1]-sumd[i-1];else return sumd[j-1]; }int main(){int T;cin>>T;while(T--){memset(d,0,sizeof d);memset(sumd,0,sizeof sumd);scanf("%d%d",&n,&k);for(int i=0;i<n;i++)scanf("%d",&d[i]);sort(d,d+n);for(int i=0;i<n;i++)if(i) sumd[i]=sumd[i-1]+(ll)d[i];else sumd[i]=(ll)d[i];double messc=0.0,minv=0.0,now=0.0;for(int j=0;j<=k;j++){ll nows=getsum(j,n-(k-j));//now sum of j ~ (n-k+j)messc=(double)nows/(double)(n-k);now=0.0;for(int i=j;i<=(n-1)-(k-j);i++)// it means move i item at front and (n-(k-j)) items at end{double dis=(double)d[i]-messc;now+=(dis*dis);if(j && now>=minv) break; //IMPORTANT! TLE if miss it}if(!j)minv=now;else if(now<minv) minv=now;}printf("%.10f\n",minv);}}楼上的算法现场赛过了但是HDU过不了了…… 好在现在ACM官网上发出了kuangbin大大的解法，也拿来学习一下：转载地址：http://www.kuangbin.net/archives/hdu5073/* ***********************************************Author        :kuangbinCreated Time  :2014/10/22 23:20:07File Name     :E:\2014ACM\2014现场赛\鞍山\D.cpp************************************************ */#include <stdio.h>#include <string.h>#include <iostream>#include <algorithm>#include <vector>#include <queue>#include <set>#include <map>#include <string>#include <math.h>#include <stdlib.h>#include <time.h>using namespace std;double x[50010];int main(){    //freopen("in.txt","r",stdin);    //freopen("out.txt","w",stdout);    int T;int n,k;scanf("%d",&T);while(T--){scanf("%d%d",&n,&k);for(int i = 0;i < n;i++)scanf("%lf",&x[i]);sort(x,x+n);if(n == k){printf("0\n");continue;}int cnt = n-k;double sum = 0;double sum2 = 0;for(int i = 0;i < cnt;i++){sum += x[i];sum2 += x[i]*x[i];}double ans = sum2 - 2*sum*(sum/cnt) + cnt*(sum/cnt)*(sum/cnt);for(int i = cnt;i < n;i++){sum += x[i];sum2 += x[i]*x[i];sum -= x[i-cnt];sum2 -= x[i-cnt]*x[i-cnt];ans = min(ans,sum2-2*sum*(sum/cnt)+cnt*(sum/cnt)*(sum/cnt));}printf("%.10lf\n",ans);}    return 0;}接着是神水题I，就是大家都作为签到题的那个题意转述的话：OSU里有好多个按顺序出现的点，每两个点都有个距离，距离除以时间称作难度，求难度的最大值。既然都说了时间肯定是升序了……那每次都计算当前dist，然后更新max咯~#include <cmath>#include <cstdio>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;ll t,x,y,tt,xx,yy; //present, last double dist(){ll asqr=(ll)(x-xx)*(x-xx)+(ll)(y-yy)*(y-yy);double ret=sqrt((double)asqr);return ret/(double)(t-tt);}int main(){int T;cin>>T;while(T--){int N;cin>>N;double maxd=-1.0;for(int Ncnt=0;Ncnt<N;Ncnt++){cin>>t>>x>>y;if(Ncnt && dist()>maxd){double now=dist();if(now>maxd)maxd=now;}tt=t,xx=x,yy=y;}printf("%.10f\n",maxd);} return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/40213577	4353重庆大学 Screen/421311/--/--/-1/311/2白气球一枚入手，吾辈是第30个写出White的~ 在队友们读完赛题之前1A掉了D题拿到White 不过好可惜……我们未能攻破第二题的装甲……D虽然全场到场的基本没有做不出来的，不过想了想还是拿来说一说吧，毕竟能水一篇博文嘛~题意有点简单就不多说啦……好吧你们都猜到我还是会说的……【吐槽】看呐看呐！！！！Asia拼写错了有木有！写成Aisa了呢~~~^_^咳咳……就是说给你一个n，就是两个数的和啦，问分成两个数，他们的最小公倍数最大是多少，输出那个最大的最小公倍数。那么我们都知道(x+i)(x-i)=x*x-i*i所以越靠近越好咯~·奇数的话不用说，分成一奇数和一偶数，肯定互质不解释~·偶数咋办呢，咱可千万别除以二然后一个加一一个减一哦，有可能是俩偶数啊！···那么除以二之后如果是偶数，那就一个加一一个减一，肯定互质（啥，又问为什么……那个辗转相除知道不？大的减去小的等于2，小的是奇数，互质）···如果是奇数，那么……好吧我们继续加二减二……加三减三……直到互质为止……哎你等会别去敲代码啊！ 不是互质了就行了的，这期间如果有谁的最小公倍数比你大咋办呢！弄个maxv存着？哎对~~~^_^那么代码就是这样：#include <cstdio>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;ll gcd(ll a,ll b)   //a>=b{    if(a%b==0 || b==1) return b;    ll x=a-(a/b)*b,y=b;    if(x<y)    {        ll tmp=x;        x=y;y=tmp;    }    return gcd(x,y);}ll lcm(ll a,ll b){    ll x=a,y=b;    return x/gcd(x,y)*y;}bool judge(ll n,ll x){    if(gcd(n,x)==1)return true;    else return false;}int main(){    ll T;    cin>>T;    while(T--)    {        ll n,maxv=0;   cin>>n;        if(n==2) cout<<1<<endl;        else if(n%2) cout<<(n/2)*(n/2+1)<<endl;        else if(n%4==0) cout<<(n/2+1)*(n/2-1)<<endl;        else for(ll i=n/2;i>=1;)        {            if(judge(n-i,i))            {                cout<<max(i*(n-i),maxv)<<endl;                break;            }            else            {                ll vnow=lcm(n-i,i);                if(maxv< vnow) maxv=vnow;            }            i--;        }    }    return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/40187549	这一场……我终于进入紫名了~这一场……ABD写的挺快的……然后就有点自负了想要去写写E题……结果把C给放弃了……真是可惜……Problems  #Name  ADreamoon and Stairsstandard input/output1 s, 256 MB  x3245BDreamoon and WiFistandard input/output1 s, 256 MB  x2467CDreamoon and Sumsstandard input/output1.5 s, 256 MB  x1067DDreamoon and Setsstandard input/output1 s, 256 MB  x569EDreamoon and Stringsstandard input/output1 s, 256 MB  x140A. Dreamoon and Stairstime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputDreamoon wants to climb up a stair of n steps. He can climb 1 or 2 steps at each move. Dreamoon wants the number of moves to be a multiple of an integer m.What is the minimal number of moves making him climb to the top of the stairs that satisfies his condition?InputThe single line contains two space separated integers n, m (0 < n ≤ 10000, 1 < m ≤ 10).OutputPrint a single integer — the minimal number of moves being a multiple of m. If there is no way he can climb satisfying condition print - 1 instead.Sample test(s)input10 2output6input3 5output-1NoteFor the first sample, Dreamoon could climb in 6 moves with following sequence of steps: {2, 2, 2, 2, 1, 1}.For the second sample, there are only three valid sequence of steps {2, 1}, {1, 2}, {1, 1, 1} with 2, 2, and 3 steps respectively. All these numbers are not multiples of 5.有n个台阶，每次可以上一级或者两级，问最少走几步可以走完这些台阶，并且步数为m的整数倍。那么，我们先用2步走完，然后一点点用一步换掉两步，直到步数为m倍为止。当换完成1步都不行，那就真的是不行了。Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int main(){int n,m;cin>>n>>m;int steps=n%2+n/2;if(n==0){cout<<"0"; return 0;}if(steps%m!=0) steps+=(m-steps%m);if(steps>n) steps=-1;cout<<steps;return 0;}B. Dreamoon and WiFitime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputDreamoon is standing at the position 0 on a number line. Drazil is sending a list of commands through Wi-Fi to Dreamoon's smartphone and Dreamoon follows them.Each command is one of the following two types:Go 1 unit towards the positive direction, denoted as '+'Go 1 unit towards the negative direction, denoted as '-'But the Wi-Fi condition is so poor that Dreamoon's smartphone reports some of the commands can't be recognized and Dreamoon knows that some of them might even be wrong though successfully recognized. Dreamoon decides to follow every recognized command and toss a fair coin to decide those unrecognized ones (that means, he moves to the 1 unit to the negative or positive direction with the same probability 0.5).You are given an original list of commands sent by Drazil and list received by Dreamoon. What is the probability that Dreamoon ends in the position originally supposed to be final by Drazil's commands?InputThe first line contains a string s1 — the commands Drazil sends to Dreamoon, this string consists of only the characters in the set {'+', '-'}.The second line contains a string s2 — the commands Dreamoon's smartphone recognizes, this string consists of only the characters in the set {'+', '-', '?'}. '?' denotes an unrecognized command.Lengths of two strings are equal and do not exceed 10.OutputOutput a single real number corresponding to the probability. The answer will be considered correct if its relative or absolute error doesn't exceed 10 - 9.Sample test(s)input++-+-+-+-+output1.000000000000input+-+-+-??output0.500000000000input+++??-output0.000000000000NoteFor the first sample, both s1 and s2 will lead Dreamoon to finish at the same position  + 1.For the second sample, s1 will lead Dreamoon to finish at position 0, while there are four possibilites for s2: {"+-++", "+-+-", "+--+", "+---"} with ending position {+2, 0, 0, -2} respectively. So there are 2 correct cases out of 4, so the probability of finishing at the correct position is 0.5.For the third sample, s2 could only lead us to finish at positions {+1, -1, -3}, so the probability to finish at the correct position  + 3 is 0.这道题是说，先给一个左右移动的字符串，+是右移，-是左移，然后第二个字符串（其中可能有问号代表不知道这里是+还是-），问这个字符串到达第一个字符串移动的终点的概率是多少。那么很显然，如果第二个字符串没有问号，那就是直接判断位置，概率那就是1或0，每出现一个问号就多一个不确定项。我们先把可以确认的移动方向去定下来，看还距离多少，看剩下的问号数有没有可能完成剩下的任务（问号比剩余距离短或者达成目标之后剩余的问号数不是偶数），顺便说一下，为啥达成目标之后剩余需要是偶数呢，因为可以一个加号一个减号抵消掉呀~so，那就是个简单概率题咯~，通过计算，问号们应该是几个+几个-才可以完成，那么就直接C(all,need)*1/(2^all)即可^_^Code:#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;int Jc[12];#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}void Jc_init(){Jc[1]=Jc[0]=1;for(int i=2;i<12;i++)Jc[i]=Jc[i-1]*i;}double C(int n,int m){double ret=1.0;for(int i=1;i<=n;i++)ret/=2.0;ret= ret*(double)Jc[n]/(double)Jc[m]/(double)Jc[n-m];return ret;}int main(){string s1,s2;cin>>s1>>s2;double rate=0.0;int pos1=0,pos2=0,unc=0;Jc_init();for(int i=0;i<s1.length();i++){if(s1[i]=='+')pos1++;else pos1--;if(s2[i]=='+')pos2++;else if(s2[i]=='-') pos2--;else unc++;}int pos=abs(pos2-pos1);if(pos<=unc){int res=unc-pos;if(res%2==0){int need=res/2+pos;rate=C(unc,need);}}printf("%.12f",rate);return 0;}C. Dreamoon and Sumstime limit per test1.5 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputDreamoon loves summing up something for no reason. One day he obtains two integers a and b occasionally. He wants to calculate the sum of all nice integers. Positive integer x is called nice if  and , where k is some integer number in range [1, a].By  we denote the quotient of integer division of x and y. By  we denote the remainder of integer division of x andy. You can read more about these operations here: http://goo.gl/AcsXhT.The answer may be large, so please print its remainder modulo 1 000 000 007 (109 + 7). Can you compute it faster than Dreamoon?InputThe single line of the input contains two integers a, b (1 ≤ a, b ≤ 107).OutputPrint a single integer representing the answer modulo 1 000 000 007 (109 + 7).Sample test(s)input1 1output0input2 2output8NoteFor the first sample, there are no nice integers because  is always zero.For the second sample, the set of nice integers is {3, 5}.===》 范围内满足这些各项范围条件内的，满足条件的x的和是多少这道题是当时没能写出来的题……数学要学好哇，推公式挺重要……Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;const ll lim=(ll)1e9+7;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))int main(){    ll n,a,b;    const ll mod=1000000007;    scanf("%I64d%I64d",&a,&b);    if(b==1){printf("0\n");return 0;}    ll fa,fb,an=(b+1+b*a+1)*a/2;    ll ans=((a*(a+1)/2)%mod*b+a)%mod;    ans=ans*((b*(b-1)/2)%mod)%mod;    printf("%I64d\n",ans);    return 0;}Python_Code：a, b = tuple(map(int, input().split()))print((b*(b-1)*a*(a+1)*b//4 + a*b*(b-1) // 2) % 1000000007)D. Dreamoon and Setstime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputDreamoon likes to play with sets, integers and .  is defined as the largest positive integer that divides both a and b.Let S be a set of exactly four distinct integers greater than 0. Define S to be of rank k if and only if for all pairs of distinct elements si,sj from S, .Given k and n, Dreamoon wants to make up n sets of rank k using integers from 1 to m such that no integer is used in two different sets (of course you can leave some integers without use). Calculate the minimum m that makes it possible and print one possible solution.InputThe single line of the input contains two space separated integers n, k (1 ≤ n ≤ 10 000, 1 ≤ k ≤ 100).OutputOn the first line print a single integer — the minimal possible m.On each of the next n lines print four space separated integers representing the i-th set.Neither the order of the sets nor the order of integers within a set is important. If there are multiple possible solutions with minimal m, print any one of them.Sample test(s)input1 1output51 2 3 5input2 2output222 4 6 2214 18 10 16NoteFor the first example it's easy to see that set {1, 2, 3, 4} isn't a valid set of rank 1 since .这道题的意思是请找出n组数，每组4个数，要求每组的4个数字两两之间的公约数都是k……那我们就弄成每组数字都互质，然后全体乘以k不就行了么……然后看了看样例……这个该怎么说……我是觉得额这道题的output暴露了数据规律怎么破……我算是看出规律再证明的方式A的这道题当时我看到22那个样例的时候……在想他干嘛要把22放这里……然后发现 2/4/6/10 14/16/18/22也是行的哇……化成乘以k之前的数据…… 1/2/3/5和7/8/9/11……我就试了试——每组公差都是6？……然后就A了……Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int main(){int n,k;cin>>n>>k;int v[4]={1,2,3,5};printf("%d\n",(n*6-1)*k);for(int i=1;i<=n;i++){for(int j=0;j<4;j++){if(j==0) printf("%d",v[j]*k);else printf(" %d",v[j]*k);v[j]+=6;}printf("\n");}return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/40185381	这一场居然是七道题，当时还吓了一跳，只做了3道题怎么破之类的……但是，嘛，稳定三道题是很重要的啦~不要在意这些细节~~~A. Design Tutorial: Learn from Mathtime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputOne way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.For example, there is a statement called the "Goldbach's conjecture". It says: "each even number no less than four can be expressed as the sum of two primes". Let's modify it. How about a statement like that: "each integer no less than 12 can be expressed as the sum of two composite numbers." Not like the Goldbach's conjecture, I can prove this theorem.You are given an integer n no less than 12, express it as a sum of two composite numbers.InputThe only line contains an integer n (12 ≤ n ≤ 106).OutputOutput two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.Sample test(s)input12output4 8input15output6 9input23output8 15input1000000output500000 500000NoteIn the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output "6 6" or "8 4" as well.In the second example, 15 = 6 + 9. Note that you can't output "1 14" because 1 is not a composite number.我被这道题弄得简直哭了要…… 当时被坑得半死……其实想多了啦大家~ 因为2以外的偶数都是合数对不对^_^，所以，奇数的话就是9 + （N-9），偶数的话是4 + （N-4）~~~8018751Sep/29/2014 03:38Accepted8018742Sep/29/2014 03:36Compilation error8011448Sep/28/2014 21:25Wrong answer on test 327999693Sep/28/2014 19:48HackedCode（先给大家看看当时我的水代码）：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;const int N = (int)1e6;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))int n,prime[N]={0},nump=0;int isNotPrime[N]={1,1};bool cmp(const int a, const int b){return a > b;}void getpri(){for(int i=2;i<=N/2;i++){if(!isNotPrime[i]) prime[nump++]=i;//cout<<i<<' ';for(int j=0;j<nump && i*prime[j]<N;j++){isNotPrime[i*prime[j]]=1;if(!(i%prime[j]))break;}}}int main(){cin>>n;int pos=1;getpri();for(int i=4;i<=n/2;i++){if(i> prime[pos])pos++;if(i==prime[pos])continue;if(count(prime,prime+55555,n-i)==1)continue;else{cout<<i<<" "<<n-i<<endl;return 0;}}return 0;}嘛，实际上~Code：bool f=(n%2==1);cout<<f?9:4<<" "<<f?n-9:n-4<<endl;#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))int main(){int n;cin>>n;if(n%2==0)cout<<4<<" "<<n-4<<endl;else cout<<9<<" "<<n-9<<endl;return 0;}B. Design Tutorial: Learn from Lifetime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputOne way to create a task is to learn from life. You can choose some experience in real life, formalize it and then you will get a new task.Let's think about a scene in real life: there are lots of people waiting in front of the elevator, each person wants to go to a certain floor. We can formalize it in the following way. We have n people standing on the first floor, the i-th person wants to go to the fi-th floor. Unfortunately, there is only one elevator and its capacity equal to k (that is at most k people can use it simultaneously). Initially the elevator is located on the first floor. The elevator needs |a - b| seconds to move from the a-th floor to the b-th floor (we don't count the time the people need to get on and off the elevator).What is the minimal number of seconds that is needed to transport all the people to the corresponding floors and then return the elevator to the first floor?InputThe first line contains two integers n and k (1 ≤ n, k ≤ 2000) — the number of people and the maximal capacity of the elevator.The next line contains n integers: f1, f2, ..., fn (2 ≤ fi ≤ 2000), where fi denotes the target floor of the i-th person.OutputOutput a single integer — the minimal time needed to achieve the goal.Sample test(s)input3 22 3 4output8input4 250 100 50 100output296input10 32 2 2 2 2 2 2 2 2 2output8NoteIn first sample, an optimal solution is:The elevator takes up person #1 and person #2.It goes to the 2nd floor.Both people go out of the elevator.The elevator goes back to the 1st floor.Then the elevator takes up person #3.And it goes to the 2nd floor.It picks up person #2.Then it goes to the 3rd floor.Person #2 goes out.Then it goes to the 4th floor, where person #3 goes out.The elevator goes back to the 1st floor.有一帮人想坐电梯上楼，如何安排可以让电梯经历的楼层数最少呢~这道题正着想略烦……但是倒着来~~^_^我们采取倒放的方式，先把楼层最高的几个送上去，下来的路上送第二第三……顺次的，到底层再送现在最高的几个（当然是装满）这样一来就可以保证总楼层经历最少~Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int des[2048];int main(){int n,k;cin>>n>>k;memset(des,0,sizeof des);for(int i=0;i<n;i++){scanf("%d",&des[i]);}sort(des,des+n,cmp);int rest=k,t=0;for(int i=0;i<n;i++){if(rest>0){if(rest==k) t+=2*(des[i]-1);rest--;}if(rest==0) rest=k;//cout<<i<<":"<<rest<<":"<<t<<endl;}cout<<t<<endl;return 0;}C. Design Tutorial: Make It Nondeterministictime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputA way to make a new task is to make it nondeterministic or probabilistic. For example, the hard task of Topcoder SRM 595, Constellation, is the probabilistic version of a convex hull.Let's try to make a new task. Firstly we will use the following task. There are n people, sort them by their name. It is just an ordinary sorting problem, but we can make it more interesting by adding nondeterministic element. There are n people, each person will use either his/her first name or last name as a handle. Can the lexicographical order of the handles be exactly equal to the given permutation p?More formally, if we denote the handle of the i-th person as hi, then the following condition must hold: .InputThe first line contains an integer n (1 ≤ n ≤ 105) — the number of people.The next n lines each contains two strings. The i-th line contains strings fi and si (1 ≤ |fi|, |si| ≤ 50) — the first name and last name of the i-th person. Each string consists only of lowercase English letters. All of the given 2n strings will be distinct.The next line contains n distinct integers: p1, p2, ..., pn (1 ≤ pi ≤ n).OutputIf it is possible, output "YES", otherwise output "NO".Sample test(s)input3gennady korotkevichpetr mitrichevgaoyuan chen1 2 3outputNOinput3gennady korotkevichpetr mitrichevgaoyuan chen3 1 2outputYESinput2galileo galileinicolaus copernicus2 1outputYESinput10rean schwarzerfei claussellalisa reinfordeliot craiglaura arseidjusis albareamachias regnitzsara valestinemma millsteingaius worzel1 2 3 4 5 6 7 8 9 10outputNOinput10rean schwarzerfei claussellalisa reinfordeliot craiglaura arseidjusis albareamachias regnitzsara valestinemma millsteingaius worzel2 4 9 6 5 7 1 3 8 10outputYESNoteIn example 1 and 2, we have 3 people: tourist, Petr and me (cgy4ever). You can see that whatever handle is chosen, I must be the first, then tourist and Petr must be the last.In example 3, if Copernicus uses "copernicus" as his handle, everything will be alright.这道题的意思是说每个人都有两个名字，可以任选其中一种来作为排序用，是否存在一种选择，令他们的名字可以按照给出的顺序字典序排序。那么，我们就按照字典序把这所有的名字都排好序标记上是属于谁的名字，然后看是否存在满足这种条件的子序列即可~Code：#include <cmath> #include <queue>#include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef pair<string,int> psi;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))struct cmp{      bool operator()(psi a,psi b)     {          if(a.first!=b.first)            return a.first>b.first;      }  };  priority_queue <psi,vector<psi>,cmp> p_q;int main(){int n;cin>>n;for(int i=1;i<=n;i++){string s1,s2;cin>>s1>>s2;p_q.push(psi(s1,i));p_q.push(psi(s2,i));}//cout<<p_q.top().first<<"\t"<< p_q.top().second<<endl;for(int i=1;i<=n;i++){int pos;cin>>pos;while(!p_q.empty() && p_q.top().second!=pos) p_q.pop();if(p_q.empty()){cout<<"NO"<<endl;return 0;}p_q.pop();}cout<<"YES"<<endl;return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/40100947	简单三部曲^_^类中的声明部分需要事先声明好： 记得import哦SoundPool soundPool= new SoundPool(10, AudioManager.STREAM_SYSTEM, 5);     HashMap<Integer, Integer> soundMap = new HashMap<Integer, Integer>();在OnCreate中添加一些声效soundMap.put(1, soundPool.load(this, R.raw.m_023, 1));         soundMap.put(2, soundPool.load(this, R.raw.m_019, 1));最后，在需要的地方调用即可if(list.size()==1) soundPool.play(soundMap.get(1), 1, 1, 0, 0, 1);else soundPool.play(soundMap.get(2), 1, 1, 0, 0, 1);版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/39965373	A. The Elder Trolls IV: Oblivontime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputVasya plays The Elder Trolls IV: Oblivon. Oh, those creators of computer games! What they do not come up with! Absolutely unique monsters have been added to the The Elder Trolls IV: Oblivon. One of these monsters is Unkillable Slug. Why it is "Unkillable"? Firstly, because it can be killed with cutting weapon only, so lovers of two-handed amber hammers should find suitable knife themselves. Secondly, it is necessary to make so many cutting strokes to Unkillable Slug. Extremely many. Too many!Vasya has already promoted his character to 80-th level and in order to gain level 81 he was asked to kill Unkillable Slug. The monster has a very interesting shape. It looks like a rectangular parallelepiped with size x × y × z, consisting of undestructable cells 1 × 1 × 1. At one stroke Vasya can cut the Slug along an imaginary grid, i.e. cut with a plane parallel to one of the parallelepiped side. Monster dies when amount of parts it is divided reaches some critical value.All parts of monster do not fall after each cut, they remains exactly on its places. I. e. Vasya can cut several parts with one cut.Vasya wants to know what the maximum number of pieces he can cut the Unkillable Slug into striking him at most k times.Vasya's character uses absolutely thin sword with infinite length.InputThe first line of input contains four integer numbers x, y, z, k (1 ≤ x, y, z ≤ 106, 0 ≤ k ≤ 109).OutputOutput the only number — the answer for the problem.Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cout (also you may use%I64d).Sample test(s)input2 2 2 3output8input2 2 2 1output2NoteIn the first sample Vasya make 3 pairwise perpendicular cuts. He cuts monster on two parts with the first cut, then he divides each part on two with the second cut, and finally he divides each of the 4 parts on two.有这么一个大方块，是一个X x Y x Z的方块，由这么多个1 x 1 x 1的方块组成，你可以切k刀，问最多可以切成多少块。我们知道平方差公式 (x+y)(x-y)=x*x-y*y ，即两个数的和一定，差越小他们俩的乘积越大。同理我们可以知道三个数字也是这样。所以我们要尽可能的让长宽高被切的刀数尽可能相近。 可以的话最好三个都相同，无法被3整除的时候余数也应该尽可能的平分。为了分隔的尽量最优，我们应该从边长最小的开始切，看是否满足k/3，不够的话切满剩下的分给另外两边，以此类推。代码也比较简单易懂，看代码也会比较容易帮助理解一些#include <cstdio>#include <string>#include <cstring> #include <iostream>#include <algorithm>using namespace std;typedef long long ll;ll c[3];int main(){ll x,y,z,k;cin>>x>>y>>z>>k;c[0]=x-1,c[1]=y-1,c[2]=z-1;sort(c,c+3);if(c[0]>=k/3) c[0]=k/3,c[1]=(k-c[0])/2,c[2]=min(c[2],k-c[0]-c[1]);else{if(c[1]>=(k-c[0])/2) c[1]=(k-c[0])/2,c[2]=min(c[2],k-c[0]-c[1]);else c[2]=min(c[2],k-c[1]-c[0]);}//cout<<(c[0]+1)<<" "<<(c[1]+1)<<" "<<(c[2]+1)<<endl;cout<<(c[0]+1)*(c[1]+1)*(c[2]+1);return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/39959593	A. Goshtasp, Vishtasp and Eiditime limit per test5 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputGoshtasp was known to be a good programmer in his school. One day Vishtasp, Goshtasp's friend, asked him to solve this task:Given a positive integer n, you should determine whether n is rich.The positive integer x is rich, if there exists some set of distinct numbers a1, a2, ..., am such that . In addition: every ai should be either a prime number, or equal to 1.Vishtasp said that he would share his Eidi 50 / 50 with Goshtasp, if he could solve the task. Eidi is money given to children for Noruz by their parents and/or relatives.Goshtasp needs to solve this problem to get money, you need to solve it to get score!InputInput contains a single positive integer n (1 ≤ n ≤ 10000).OutputIf the number is not rich print 0. Otherwise print the numbers a1, ..., am. If several solutions exist print the lexicographically latestsolution. Answers are compared as sequences of numbers, not as strings.For comparing two sequences a1, ..., am and b1, ..., bn we first find the first index i such that ai ≠ bi, if ai < bi then a is lexicographically earlier and if bi < ai then b is lexicographically earlier. If m ≠ n we add zeroes at the end of the smaller sequence (only for the moment of comparison) and then perform the comparison.You do not need to minimize the number of elements in sequence (i.e. m). You just need to print the lexicographically latestsolution.See samples to find out how to print the sequence.Sample test(s)input11output11=11input545output541+3+1=545又是一场Unknown Language Round……没办法 A题终结者的No.是按照Round编号来的（啊那个加入专栏的不是按Round号而是按照#号顺序的哦~）强迫症表示，没什么学习意义，不过是也贴一下完成强迫症的心情：n :=File standardInput readLine asNumberp :=0m :=nwhile(n>0,for(x,n,1,-1,q :=0for(i,2,x-1,if(x%i==0,q :=1;break;))if(q==0,if(p==1,"+" print)p :=1n :=n-xx printbreak)))"=" printm println版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/39958647	A. Way Too Long Wordstime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputSometimes some words like "localization" or "internationalization" are so long that writing them many times in one text is quite tiresome.Let's consider a word too long, if its length is strictly more than 10 characters. All too long words should be replaced with a special abbreviation.This abbreviation is made like this: we write down the first and the last letter of a word and between them we write the number of letters between the first and the last letters. That number is in decimal system and doesn't contain any leading zeroes.Thus, "localization" will be spelt as "l10n", and "internationalization» will be spelt as "i18n".You are suggested to automatize the process of changing the words with abbreviations. At that all too long words should be replaced by the abbreviation and the words that are not too long should not undergo any changes.InputThe first line contains an integer n (1 ≤ n ≤ 100). Each of the following n lines contains one word. All the words consist of lowercase Latin letters and possess the lengths of from 1 to 100 characters.OutputPrint n lines. The i-th line should contain the result of replacing of the i-th word from the input data.Sample test(s)input4wordlocalizationinternationalizationpneumonoultramicroscopicsilicovolcanoconiosisoutputwordl10ni18np43s这题我曾经做过一次，当时似乎写了还是有20几行的，现在会用string之后觉得真的相当容易呢。string是有着 str.length()这样的函数可以调用的，所以我们可以很方便的获取字符串的长度，以及str[0]和str[str.length()-1]是头尾两个字符，那么这道题不就迎刃而解了吗~需要注意的是，string是C++的库文件，cstring是C语言的哦，他们里面包含的函数是不同的呢~#include <cstdio>#include <string>#include <cstring> #include <iostream>using namespace std;int main(){int n;cin>>n;for(int i=0;i<n;i++){string s;cin>>s;if(s.length()>10)cout<<s[0]<<s.length()-2<<s[s.length()-1]<<endl;else cout<<s<<endl;}return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/39958479	A. Cookiestime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputFangy collects cookies. Once he decided to take a box and put cookies into it in some way. If we take a square k × k in size, divided into blocks 1 × 1 in size and paint there the main diagonal together with cells, which lie above it, then the painted area will be equal to the area occupied by one cookie k in size. Fangy also has a box with a square base 2n × 2n, divided into blocks 1 × 1in size. In a box the cookies should not overlap, and they should not be turned over or rotated. See cookies of sizes 2 and 4respectively on the figure:To stack the cookies the little walrus uses the following algorithm. He takes out of the repository the largest cookie which can fit in some place in the box and puts it there. Everything could be perfect but alas, in the repository the little walrus has infinitely many cookies of size 2 and larger, and there are no cookies of size 1, therefore, empty cells will remain in the box. Fangy wants to know how many empty cells will be left in the end.InputThe first line contains a single integer n (0 ≤ n ≤ 1000).OutputPrint the single number, equal to the number of empty cells in the box. The answer should be printed modulo 106 + 3.Sample test(s)input3output9NoteIf the box possesses the base of 23 × 23 (as in the example), then the cookies will be put there in the following manner:细心的大家应该可以发现，这是个从2开始公比为3的等比数列。看不出来的话注意看图，把每张图分成四个象限，每一个n都是n+1的图的第三象限的部分~既然知道了规律，取模的时候注意一下 a%b要写成 (a+b)%b 的形式即可~#include <cstdio>#include <string>#include <cstring> #include <iostream>using namespace std;int main(){int n,ans=1;cin>>n;const int mod=(int)1e6+3;for(int i=2;i<=n;i++) {ans*=3;ans=(ans+mod)%mod;}cout<<ans; return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/39958199	A. Young Physicisttime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputA guy named Vasya attends the final grade of a high school. One day Vasya decided to watch a match of his favorite hockey team. And, as the boy loves hockey very much, even more than physics, he forgot to do the homework. Specifically, he forgot to complete his physics tasks. Next day the teacher got very angry at Vasya and decided to teach him a lesson. He gave the lazy student a seemingly easy task: You are given an idle body in space and the forces that affect it. The body can be considered as a material point with coordinates (0; 0; 0). Vasya had only to answer whether it is in equilibrium. "Piece of cake" — thought Vasya, we need only to check if the sum of all vectors is equal to 0. So, Vasya began to solve the problem. But later it turned out that there can be lots and lots of these forces, and Vasya can not cope without your help. Help him. Write a program that determines whether a body is idle or is moving by the given vectors of forces.InputThe first line contains a positive integer n (1 ≤ n ≤ 100), then follow n lines containing three integers each: the xi coordinate, theyi coordinate and the zi coordinate of the force vector, applied to the body ( - 100 ≤ xi, yi, zi ≤ 100).OutputPrint the word "YES" if the body is in equilibrium, or the word "NO" if it is not.Sample test(s)input34 1 7-2 4 -11 -5 -3outputNOinput33 -1 7-5 2 -42 -1 -3outputYES这道题并没有什么可以说的呢，那么就当给大家讲讲题意吧^_^有n个向量，每行的三个数字构成了向量(a,b,c)，问这么多向量和是否为0向量，那么不就是三维分别求和都为0即可吗？x、y、z向量上的分别加一加，都为0就是yes啦~#include <cstdio>#include <iostream>using namespace std;int main(){int n;cin>>n;int x=0,y=0,z=0;for(int i=0;i<n;i++){int xx,yy,zz;scanf("%d%d%d",&xx,&yy,&zz);x+=xx,y+=yy,z+=zz;} cout<<(x==0&&y==0&&z==0?"YES":"NO");return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/39908555	A. Irrational problemtime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputLittle Petya was given this problem for homework:You are given function  (here  represents the operation of taking the remainder). His task is to count the number of integers x in range [a;b] with property f(x) = x.It is a pity that Petya forgot the order in which the remainders should be taken and wrote down only 4 numbers. Each of 24 possible orders of taking the remainder has equal probability of being chosen. For example, if Petya has numbers 1, 2, 3, 4 then he can take remainders in that order or first take remainder modulo 4, then modulo 2, 3, 1. There also are 22 other permutations of these numbers that represent orders in which remainder can be taken. In this problem 4 numbers wrote down by Petya will be pairwise distinct.Now it is impossible for Petya to complete the task given by teacher but just for fun he decided to find the number of integers  with property that probability that f(x) = x is not less than 31.4159265352718281828459045%. In other words, Petya will pick up the number xif there exist at least 7 permutations of numbers p1, p2, p3, p4, for which f(x) = x.InputFirst line of the input will contain 6 integers, separated by spaces: p1, p2, p3, p4, a, b (1 ≤ p1, p2, p3, p4 ≤ 1000, 0 ≤ a ≤ b ≤ 31415).It is guaranteed that numbers p1, p2, p3, p4 will be pairwise distinct.OutputOutput the number of integers in the given range that have the given property.Sample test(s)input2 7 1 8 2 8output0input20 30 40 50 0 100output20input31 41 59 26 17 43output9被这道题笑哭……我还想了一会儿有没有数论上的问题呢，tag还是数论呢……一看数据范围，笑哭……模拟暴力……#include <iostream>#include <algorithm>using namespace std;int main(){int p1,p2,p3,p4,a,b;cin>>p1>>p2>>p3>>p4>>a>>b;int cnt;for(int i=a;i<=b;i++){if(i%p1%p2%p3%p4==i)cnt++;}cout<<cnt;    return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/39908695	A. Petya and Javatime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputLittle Petya has recently started attending a programming club. Naturally he is facing the problem of choosing a programming language. After long considerations he realized that Java is the best choice. The main argument in favor of choosing Java was that it has a very large integer data type, called BigInteger.But having attended several classes of the club, Petya realized that not all tasks require using the BigInteger type. It turned out that in some tasks it is much easier to use small data types. That's why a question arises: "Which integer type to use if one wants to store a positive integern?"Petya knows only 5 integer types:1) byte occupies 1 byte and allows you to store numbers from  - 128 to 1272) short occupies 2 bytes and allows you to store numbers from  - 32768 to 327673) int occupies 4 bytes and allows you to store numbers from  - 2147483648 to 21474836474) long occupies 8 bytes and allows you to store numbers from  - 9223372036854775808 to92233720368547758075) BigInteger can store any integer number, but at that it is not a primitive type, and operations with it are much slower.For all the types given above the boundary values are included in the value range.From this list, Petya wants to choose the smallest type that can store a positive integer n. Since BigInteger works much slower, Peter regards it last. Help him.InputThe first line contains a positive number n. It consists of no more than 100 digits and doesn't contain any leading zeros. The number n can't be represented as an empty string.Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cout (also you may use %I64d).OutputPrint the first type from the list "byte, short, int, long, BigInteger", that can store the natural number n, in accordance with the data given above.Sample test(s)input127outputbyteinput130outputshortinput123456789101112131415161718192021222324outputBigInteger很明显没有一个数据类型能存这么大的数字，但是我们可以存这么长的字符串string读入，然后预设置好每两种的界限，string类的大小于符号判断是字典序，所以正好可以判断，那么，直接if/else看就可以了#include <cstdio>#include <string>#include <cstring> #include <iostream>using namespace std;int main(){char now;string s;string _byte="127";string _short="32767";string _int="2147483647";string _long="9223372036854775807";long long n=0;cin>>s;int len=s.length(); if(len<3||(len==3 && s<=_byte))cout<<"byte";else if(len<5||(len==5 && s<=_short))cout<<"short";else if(len<10||(len==10 && s<=_int))cout<<"int";else if(len<19||(len==19 && s<=_long))cout<<"long";else cout<<"BigInteger";return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/39123203	A. Partial Teachertime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputA teacher decides to give toffees to his students. He asks n students to stand in a queue. Since the teacher is very partial, he follows the following rule to distribute toffees.He looks at the first two students and gives more toffees to the student having higher marks than the other one. If they have the same marks they get the same number of toffees. The same procedure is followed for each pair of adjacent students starting from the first one to the last one.It is given that each student receives at least one toffee. You have to find the number of toffees given to each student by the teacher such that the total number of toffees is minimum.InputThe first line of input contains the number of students n (2 ≤ n ≤ 1000). The second line gives (n - 1) characters consisting of "L", "R" and "=". For each pair of adjacent students "L" means that the left student has higher marks, "R" means that the right student has higher marks and "=" means that both have equal marks.OutputOutput consists of n integers separated by a space representing the number of toffees each student receives in the queue starting from the first one to the last one.Sample test(s)input5LRLRoutput2 1 2 1 2input5=RRRoutput1 1 2 3 4偏心的老师:每个LR=分别代表了这个同学比左边那只同学考的低/比右边那只同学考的低/和左边那只相等，考得好的糖多，考的不好的糖少，问最少给糖方案我之前一直理解错题意了Q^Q，我以为是L就减一就好，R加一就好，然后最后一起变成正数，（刚刚去查题意还看到一个歧义的解释是 “L代表左边的人比自己高，R表示右边的高，=表示左右相等”，这个解释的话如果改成“与左边的孩纸相比，。。。”就对了）错误代码如下：#include <cstdio>#include <string>#include <cstring> #include <iostream>#define MP(c,g) make_pair(c,g) using namespace std;int dp[1005]={0};int main(){int n, min=1;scanf("%d",&n);char c;scanf("%c",&c);memset(dp,0,sizeof dp);dp[0]=1;for(int i=1;i<n;i++){scanf("%c",&c);if(c=='=') dp[i]=dp[i-1];else if(c=='L') dp[i]=dp[i-1]-1;else if(c=='R') dp[i]=dp[i-1]+1;if(dp[i]<min) min=dp[i];}for(int i=0;i<n;i++){printf("%d",dp[i]-min+1);if(i<n-1)printf(" ");}return 0;}实际上是怎么个意思呢，这么跟你们讲应该就懂了^_^9RRRRRRLL我们是不是会以为是123456765呀？不不不，最少应该是123456721，这样分糖最少~ 是否大概理解了呢^_^，分糖什么的【要最少】Code:#include <queue>#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;queue <int> q;int main(){    while(!q.empty()) q.pop();    int n;    string s;    cin>>n;    cin>>s;    for(int c=0;c<n;c++)    {        int i=c-1,j=c;        int l=1,r=1;        while(s[i]!='L'&&i>=0)if(s[i]=='R') l++,i--;else i--;        while(s[j]!='R'&&j<n)   if(s[j]=='L') r++,j++;            else j++;        q.push(max(r,l));    }    while(q.size()!=1)    {        printf("%d ",q.front());        q.pop();    }    printf("%d\n",q.front());    return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/39756049	一直特别蠢的在寻找如何确定此时获得的ｍａｃ地址是否和事先预定的相同的方法……原来是不可以用＂＝＝＂，应该用 equals……==是地址相同…… equals是值相同……哭……/* 显示列表 */protected void showDevices(){List<String> list = new ArrayList<String>();int flag=0;for (int i = 0, size = _devices.size(); i < size; ++i){StringBuilder a = new StringBuilder();StringBuilder b = new StringBuilder();BluetoothDevice d = _devices.get(i);a.append(d.getName());String s = a.toString();b.append(d.getAddress());String mactmp=b.toString();//b.append('\n');//b.append(d.getName());String cat01mac = "40:98:4E:20:4B:E3";String basemac="00:18:31:3E:35:3C";if(mactmp.equals(cat01mac)){s = s + " is INEYE now"; list.add(s);flag=1;}else if(mactmp.equals(basemac)){s = s + " is INEYE now";  list.add(s);flag=1;}}if(flag==0)list.add("No cats in eye now");final ArrayAdapter<String> adapter = new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, list);_handler.post(new Runnable() {public void run(){setListAdapter(adapter);}});}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/39754779	Call requires API level 9 (current min is 8):安卓开发中，经常用了一个函数就立马出现这个问题，调半天调不出，实际上是权限不够的问题在AndroidManifest.xml中的 package="com.xxx.bt" android:versionCode="1" android:versionName="1.0"> 这一行下面添加上（如果有的话直接修改即可）<uses-sdk android:minSdkVersion="9" /> （此处的数字是所需要的level，按情况而定）注：bin\和 res\layout\ 下都有，都要改哦版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/39672205	学校算法老师给布置了个归并排序的实现作为作业……实在闲着无事……请允许吾辈卖个萌做个简单的命令行界面程序，以下为源码。过程中会有简单的解释语句的输出，所以过程看的还算清楚，用以对(int)1e9以下的正整数的归并排序实现源代码。废话不多说，贴代码:#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <windows.h>#include <algorithm>using namespace std;typedef long long ll;//******************************////*Author: okcd00 at 2014/09/24*////*StuNo.: 20125209   *////*Name: 陈点 物联网一班   *////* 个人作品，请勿随意盗版哦 ~ *// //******************************//#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))ll arr[1024],al[512],ar[512];string pause;bool cmp(const int a, const int b){return a > b;}void welcome(){cout<<"┏══════════════┓"<<endl;cout<<"┃Author: okcd00              ┃"<<endl;cout<<"┃StuNo.: 20125209            ┃"<<endl;cout<<"┃Time  : 2014/09/24          ┃"<<endl;cout<<"┃From  : 陈点 物联网一班     ┃"<<endl;cout<<"┣──────────────┨"<<endl;cout<<"┃ ★个人作品，请勿随意盗版★ ┃"<<endl;cout<<"┗══════════════┛"<<endl;}void menu(){system("cls");cout<<"┏══════════════┓"<<endl     <<"┃Author:  okcd00             ┃"<<endl     <<"┃StuNo.:  20125209           ┃"<<endl     <<"┃Time  :  2014/09/24         ┃"<<endl     <<"┃From  :  陈点 物联网一班    ┃"<<endl     <<"┣──────────────┨"<<endl     <<"┃ 请输入指令，以回车键结束   ┃"<<endl     <<"┃★(s)start: 开始 MergeSort★┃"<<endl     <<"┃★(q)quit : 结束程序并退出★┃"<<endl     <<"┃★%others%: 请重新输入    ★┃"<<endl     <<"┃★个人作品★★请勿随意盗版★┃"<<endl     <<"┗══════════════┛"<<endl;}void end(){system("cls");cout<<"┏══════════════┓"<<endl    <<"┃Author:  okcd00             ┃"<<endl    <<"┃StuNo.:  20125209           ┃"<<endl    <<"┃Time  :  2014/09/24         ┃"<<endl    <<"┃From  :  陈点 物联网一班    ┃"<<endl    <<"┣──────────────┨"<<endl    <<"┃ ★  程序结束，即将退出  ★ ┃"<<endl    <<"┗══════════════┛"<<endl;}int mergetime=1;void get_merge(int l,int r){if(l+1>=r) return;int pos1=0,pos2=0;for(int i=l;i<(l+r)/2;i++) al[i-l]=arr[i];for(int i=(l+r)/2;i<r;i++) ar[i-(l+r)/2]=arr[i];for(int i=l;i<r;i++){if(pos2==r-(l+r)/2) arr[i]=al[pos1],pos1++;else if(pos1==(l+r)/2-l) arr[i]=ar[pos2],pos2++;else if(al[pos1]<=ar[pos2]) arr[i]=al[pos1],pos1++;else arr[i]=ar[pos2],pos2++;}cout<<"[第"<<mergetime++<<"次] getMerge: "<<"lef="<<l<<", rig="<<r<<endl;for(int i=l;i<r;i++)cout<<arr[i]<<"\t";cout<<endl<<endl;}void do_merge(int l,int r){int lef=l,rig=r;if(lef+1>=rig) return ;else {do_merge(lef,(lef+rig)/2);do_merge((lef+rig)/2,rig);get_merge(lef,rig);}}void merge_sort(){cout<<"—— 请输入你想要排序的数字  ——" <<endl; cout<<"——（以空格分隔，以-1结束） ——" <<endl;cout<<"我的数组为(数字个数不超过1K)："; int pos=0;ll now=0;while(1){scanf("%I64d",&now);if(now!=-1)arr[pos++]=now;else break;}system("cls");cout<<"★以下为我的数组★"<<endl;for(int i=0;i<pos;i++){if(i!=0 && i%5==0) printf("┃\n");printf("┃ %010I64d ",arr[i]);//if(arr[i]<(int)1e5) cout<<"\t";}cout<<endl<<endl<<"——接下来开始进行归并排序——"<<endl<<endl;system("pause"); do_merge(0,pos);cout<<"——归并排序完毕，输出结果——"<<endl;for(int i=0;i<pos;i++){if(i!=0 && i%5==0) printf("┃\n");printf("┃ %010I64d ",arr[i]);//if(arr[i]<(int)1e5) cout<<"\t";}cout<<endl;system("pause"); }int main(){string s;welcome();system("pause"); while(1){menu();cin>>s;if(s=="quit"|| s=="q"|| s=="Q") break;else if(s=="s" || s=="S" ||s=="start") {merge_sort();break;}}end();system("pause"); return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/39668785	这一场心不够静……寝室内有杂音而且有持续不停的对话的话就无法集中精神……连续80分钟都没有滤清思路，等到寝室内安静下来，15分钟就完成了BC……不过，时间还是浪费的太多……A. MUH and Stickstime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputTwo polar bears Menshykov and Uslada from the St.Petersburg zoo and elephant Horace from the Kiev zoo got six sticks to play with and assess the animals' creativity. Menshykov, Uslada and Horace decided to make either an elephant or a bear from those sticks. They can make an animal from sticks in the following way:Four sticks represent the animal's legs, these sticks should have the same length.Two remaining sticks represent the animal's head and body. The bear's head stick must be shorter than the body stick. The elephant, however, has a long trunk, so his head stick must be as long as the body stick. Note that there are no limits on the relations between the leg sticks and the head and body sticks.Your task is to find out which animal can be made from the given stick set. The zoo keeper wants the sticks back after the game, so they must never be broken, even bears understand it.InputThe single line contains six space-separated integers li (1 ≤ li ≤ 9) — the lengths of the six sticks. It is guaranteed that the input is such that you cannot make both animals from the sticks.OutputIf you can make a bear from the given set, print string "Bear" (without the quotes). If you can make an elephant, print string "Elephant" (wıthout the quotes). If you can make neither a bear nor an elephant, print string "Alien" (without the quotes).Sample test(s)input4 2 5 4 4 4outputBearinput4 4 5 4 4 5outputElephantinput1 2 3 4 5 6outputAlienNoteIf you're out of creative ideas, see instructions below which show how to make a bear and an elephant in the first two samples. The stick of length 2 is in red, the sticks of length 4 are in green, the sticks of length 5 are in blue.这道题问的是六根棍子是否可以拼成熊或者象，不能的话输出Alien首先，为了证明它不是外星人，首先需要知道有没有4个（或以上，这个很重要，因为5、6也是可以拼的~）一样长度的棍子，然后判断剩下两根的长短即可。我用的是排序后枚举三种情况的形式，为了方便确认4根腿以外的两根位置具体在哪里Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <vector>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int main(){int l[6]; for(int i=0;i<6;i++){scanf("%d",&l[i]);}sort(l,l+6);if(count(l,l+6,l[0])>=4){if(l[4]==l[5]) cout<<"Elephant"<<endl;if(l[4]< l[5]) cout<<"Bear"<<endl;}else if(count(l,l+6,l[1])>=4){cout<<"Bear"<<endl;}else if(count(l,l+6,l[2])>=4){if(l[0]==l[1]) cout<<"Elephant"<<endl;if(l[0]< l[1]) cout<<"Bear"<<endl;}else cout<<"Alien"<<endl;return 0;}B. MUH and Important Thingstime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputIt's time polar bears Menshykov and Uslada from the zoo of St. Petersburg and elephant Horace from the zoo of Kiev got down to business. In total, there are n tasks for the day and each animal should do each of these tasks. For each task, they have evaluated its difficulty. Also animals decided to do the tasks in order of their difficulty. Unfortunately, some tasks can have the same difficulty, so the order in which one can perform the tasks may vary.Menshykov, Uslada and Horace ask you to deal with this nuisance and come up with individual plans for each of them. The plan is a sequence describing the order in which an animal should do all the n tasks. Besides, each of them wants to have its own unique plan. Therefore three plans must form three different sequences. You are to find the required plans, or otherwise deliver the sad news to them by stating that it is impossible to come up with three distinct plans for the given tasks.InputThe first line contains integer n (1 ≤ n ≤ 2000) — the number of tasks. The second line contains n integers h1, h2, ..., hn(1 ≤ hi ≤ 2000), where hi is the difficulty of the i-th task. The larger number hi is, the more difficult the i-th task is.OutputIn the first line print "YES" (without the quotes), if it is possible to come up with three distinct plans of doing the tasks. Otherwise print in the first line "NO" (without the quotes). If three desired plans do exist, print in the second line n distinct integers that represent the numbers of the tasks in the order they are done according to the first plan. In the third and fourth line print two remaining plans in the same form.If there are multiple possible answers, you can print any of them.Sample test(s)input41 3 3 1outputYES1 4 2 3 4 1 2 3 4 1 3 2 input52 4 1 4 8outputNONoteIn the first sample the difficulty of the tasks sets one limit: tasks 1 and 4 must be done before tasks 2 and 3. That gives the total of four possible sequences of doing tasks : [1, 4, 2, 3], [4, 1, 2, 3], [1, 4, 3, 2], [4, 1, 3, 2]. You can print any three of them in the answer.In the second sample there are only two sequences of tasks that meet the conditions — [3, 1, 2, 4, 5] and [3, 1, 4, 2, 5]. Consequently, it is impossible to make three distinct sequences of tasks.有这么多件事情要做，他们的难度已经给出，大家都是从简单的开始做到难的，问是否有三种不同的完成顺序。这不是很明显嘛~ 如果有2组【难度一致的两件事】或1组【难度一致的三件事】就可以啦~前者的话是第一组换位置即为第二种，第二组换位置即为第三种；后者的话是012/120/201的顺序咯~额，理念知道了大家自己写起来就快了，我下面这个是当时脑袋昏昏的写的，可乱了还有好多注释，这个理解了还是自己写的好哦^_^Code：#include <cmath> #include <queue>#include <cctype>#include <cstdio>#include <string>#include <vector>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef pair<int,int> pii;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int har[2048];int ans[2048][3];int tri[3]={0};int dou[3][3]={0};priority_queue<pii> p_q;/*void swap2(int a,int b,int mrk){ans[a-1][mrk]=ans[b-1][0];ans[b-1][mrk]=ans[a-1][0];}void swap3(int a,int b,int c){int t1=ans[a][0],t2=ans[b][0],t3=ans[c][0];ans[a-1][1]=t1;ans[a-1][2]=t2;ans[a-1][0]=t3;ans[a-1][2]=t1;ans[a-1][0]=t2;ans[a-1][1]=t3;}*/int main(){int n,flag=1,pos=0;scanf("%d",&n);memset(har,0,sizeof har);int cnt=0;for(int i=1;i<=n;i++){int hard;scanf("%d",&hard);if(flag>=0){if(har[hard]==0) {har[hard]=i;//cout<<"har["<<hard<<"]="<<i<<endl;}else if(har[hard]>0){dou[pos][0]=har[hard];dou[pos][1]=i;har[hard]=-1;//cout<<dou[pos][0]<<":"<<dou[pos][1]<<endl;pos++;//cout<<"har["<<hard<<"]="<<-1<<endl;//cout<<"pos:"<<pos<<endl;if(pos>=2) flag=-2;}else if(har[hard]==-1){tri[0]=dou[0][0];tri[1]=dou[0][1];tri[2]=i;flag=-3;}}p_q.push(pii(0-hard,i));//cout<<"input:"<<hard<<": "<<i<<" flag:"<<flag<<" pos:"<<pos<<endl;}if(flag>=0)cout<<"NO"<<endl;else {int posi=0;while(!p_q.empty()){pii tt=p_q.top();ans[posi][0]=ans[posi][1]=ans[posi][2]=tt.second;p_q.pop();//cout<<ans[posi][0]<<endl;posi++;}/*if(flag==-2){swap2(dou[0][0],dou[0][1],1);swap2(dou[1][0],dou[1][1],2);}else if(flag==-3){swap3(tri[0],tri[1],tri[2]);}*/cout<<"YES"<<endl;//1stfor(int j=0;j<n-1;j++)printf("%d ",ans[j][0]);printf("%d\n",ans[n-1][0]);//2ndif(flag==-2){for(int j=0;j<n-1;j++){ if(ans[j][1]==dou[0][0])printf("%d ",dou[0][1]);else if(ans[j][1]==dou[0][1])printf("%d ",dou[0][0]);else printf("%d ",ans[j][1]);}if(ans[n-1][1]==dou[0][0])printf("%d\n",dou[0][1]);else if(ans[n-1][1]==dou[0][1])printf("%d\n",dou[0][0]);else printf("%d\n",ans[n-1][1]);}else if(flag==-3){for(int j=0;j<n-1;j++){ if(ans[j][1]==tri[0])printf("%d ",tri[1]);else if(ans[j][1]==tri[1])printf("%d ",tri[2]);else if(ans[j][1]==tri[2])printf("%d ",tri[0]);else printf("%d ",ans[j][1]);}if(ans[n-1][1]==tri[0])printf("%d\n",tri[1]);else if(ans[n-1][1]==tri[1])printf("%d\n",tri[2]);else if(ans[n-1][1]==tri[2])printf("%d\n",tri[0]);else printf("%d\n",ans[n-1][1]);}//3rdif(flag==-2){for(int j=0;j<n-1;j++){ if(ans[j][1]==dou[1][0])printf("%d ",dou[1][1]);else if(ans[j][1]==dou[1][1])printf("%d ",dou[1][0]);else printf("%d ",ans[j][1]);}if(ans[n-1][1]==dou[1][0])printf("%d\n",dou[1][1]);else if(ans[n-1][1]==dou[1][1])printf("%d\n",dou[1][0]);else printf("%d\n",ans[n-1][1]);}else if(flag==-3){for(int j=0;j<n-1;j++){ if(ans[j][1]==tri[0])printf("%d ",tri[2]);else if(ans[j][1]==tri[1])printf("%d ",tri[0]);else if(ans[j][1]==tri[2])printf("%d ",tri[1]);else printf("%d ",ans[j][1]);}if(ans[n-1][1]==tri[0])printf("%d\n",tri[2]);else if(ans[n-1][1]==tri[1])printf("%d\n",tri[0]);else if(ans[n-1][1]==tri[2])printf("%d\n",tri[1]);else printf("%d\n",ans[n-1][1]);}}return 0;}C. MUH and House of Cardstime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputPolar bears Menshykov and Uslada from the zoo of St. Petersburg and elephant Horace from the zoo of Kiev decided to build a house of cards. For that they've already found a hefty deck of n playing cards. Let's describe the house they want to make:The house consists of some non-zero number of floors.Each floor consists of a non-zero number of rooms and the ceiling. A room is two cards that are leaned towards each other. The rooms are made in a row, each two adjoining rooms share a ceiling made by another card.Each floor besides for the lowest one should contain less rooms than the floor below.Please note that the house may end by the floor with more than one room, and in this case they also must be covered by the ceiling. Also, the number of rooms on the adjoining floors doesn't have to differ by one, the difference may be more.While bears are practicing to put cards, Horace tries to figure out how many floors their house should consist of. The height of the house is the number of floors in it. It is possible that you can make a lot of different houses of different heights out ofn cards. It seems that the elephant cannot solve this problem and he asks you to count the number of the distinct heights of the houses that they can make using exactly n cards.InputThe single line contains integer n (1 ≤ n ≤ 1012) — the number of cards.OutputPrint the number of distinct heights that the houses made of exactly n cards can have.Sample test(s)input13output1input6output0NoteIn the first sample you can build only these two houses (remember, you must use all the cards):Thus, 13 cards are enough only for two floor houses, so the answer is 1.The six cards in the second sample are not enough to build any house.问现在手头的卡牌能搭出多少种不同的层高。我们先发掘一下隐藏条件：1）每层的卡牌数应该是2+3*n2）对于那个n，每层的n应该比它脑袋上那层的n大，比脚底下的那个要少3）一个n层的塔所需要最少的卡牌数为2*n*(0+n-1)*n/2只要把每层的两张搭着，剩下的除以三没有余数且可以从0-层数-1用完那就是可以了Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int main(){ll c=1;ll n;cin>>n;ll var=0;while(1){ll rest=n-c*2,md=(n-c*2)%3;if( rest<0 || rest/3<(c-1)*c/2 )break;else if( rest/3==(n-1)*n/2) {var++;break;}else if( md!=0 ) c++;else var++,c++;//cout<<c<<endl;}cout<<var<<endl;return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/39668271	267这场打得不怎么样……个人感觉就是……阶梯性好强……题和题之间跳跃性真的需要这么大么……A. George and Accommodationtime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputGeorge has recently entered the BSUCP (Berland State University for Cool Programmers). George has a friend Alex who has also entered the university. Now they are moving into a dormitory.George and Alex want to live in the same room. The dormitory has n rooms in total. At the moment the i-th room has pi people living in it and the room can accommodate qi people in total (pi ≤ qi). Your task is to count how many rooms has free place for both George and Alex.InputThe first line contains a single integer n (1 ≤ n ≤ 100) — the number of rooms.The i-th of the next n lines contains two integers pi and qi (0 ≤ pi ≤ qi ≤ 100) — the number of people who already live in the i-th room and the room's capacity.OutputPrint a single integer — the number of rooms where George and Alex can move in.Sample test(s)input31 12 23 3output0input31 100 1010 10output2好萌好萌好萌的题哇~ 用来刚学会a+b problem的孩子们做最适合不过了~有n个房间，每行是这个房间现在有几个人，总共能住几个人，问：有几个房间里有2个空位……23333 代码如下Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int main(){int n=0;cin>>n;int cnt=0;for(int i=1;i<=n;i++){int a,b;scanf("%d%d",&a,&b);if(b-a>=2)cnt++;}cout<<cnt;return 0;}B. Fedor and New Gametime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputAfter you had helped George and Alex to move in the dorm, they went to help their friend Fedor play a new computer game «Call of Soldiers 3».The game has (m + 1) players and n types of soldiers in total. Players «Call of Soldiers 3» are numbered form 1 to (m + 1). Types of soldiers are numbered from 0 to n - 1. Each player has an army. Army of the i-th player can be described by non-negative integer xi. Consider binary representation of xi: if the j-th bit of number xi equal to one, then the army of the i-th player has soldiers of the j-th type.Fedor is the (m + 1)-th player of the game. He assume that two players can become friends if their armies differ in at most k types of soldiers (in other words, binary representations of the corresponding numbers differ in at most k bits). Help Fedor and count how many players can become his friends.InputThe first line contains three integers n, m, k (1 ≤ k ≤ n ≤ 20; 1 ≤ m ≤ 1000).The i-th of the next (m + 1) lines contains a single integer xi (1 ≤ xi ≤ 2n - 1), that describes the i-th player's army. We remind you that Fedor is the (m + 1)-th player.OutputPrint a single integer — the number of Fedor's potential friends.Sample test(s)input7 3 18511117output0input3 3 31234output3不知道孩纸们知不知道这个运算符 :' ^ '按位异或，如果这一位上的二进制位相同则为0，不同则为1.这题的意思是有这么多个玩家，他们用二进制表示他们有哪些种类的兵力，最后一行是菲德尔，问有多少个人和他的兵种差距不大于k种。那么……就直接用菲德尔（人）的兵种那个数字和别人异或一下看看有几个1咯~代码如下：Code#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int army[1024];int cnt_s(int a){int cnt=0,tmp=a;while(tmp!=0){cnt+=tmp%2;tmp/=2;} return cnt;}int main(){int n,m,k;cin>>n>>m>>k;memset(army,0,sizeof army); for(int i=1;i<=m+1;i++)scanf("%d",&army[i]);int cnt=0;for(int i=1;i<=m;i++)if(cnt_s(army[i]^army[m+1])<=k)cnt++;cout<<cnt;return 0;}C. George and Jobtime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputThe new ITone 6 has been released recently and George got really keen to buy it. Unfortunately, he didn't have enough money, so George was going to work as a programmer. Now he faced the following problem at the work.Given a sequence of n integers p1, p2, ..., pn. You are to choose k pairs of integers:[l1, r1], [l2, r2], ..., [lk, rk] (1 ≤ l1 ≤ r1 < l2 ≤ r2 < ... < lk ≤ rk ≤ n; ri - li + 1 = m), in such a way that the value of sum  is maximal possible. Help George to cope with the task.InputThe first line contains three integers n, m and k (1 ≤ (m × k) ≤ n ≤ 5000). The second line contains n integers p1, p2, ..., pn (0 ≤ pi ≤ 109).OutputPrint an integer in a single line — the maximum possible value of sum.Sample test(s)input5 2 11 2 3 4 5output9input7 1 32 10 7 18 5 33 0output61题意是，有这么多数字，每次挑取连续的m个数，挑k次，这么多数字的和要求最大，每个数最多只允许被挑到一次先获得每一个数的sum数组（它及它之前的所有数字之和）然后通过sum[i]-sum[i-m]获得每一个m连数组的和dp获得结果代码如下：Code：#include<stdio.h>#include<string.h>typedef __int64 ll;ll pre[5005],cur[5005],sum[5005],a[5005];int n,m,k;int main(void){int i,j;while(~scanf("%d%d%d",&n,&m,&k)){sum[0]=0;for(i=1;i<=n;i++){scanf("%I64d",&a[i]);sum[i]=sum[i-1]+a[i];}memset(pre,-1,sizeof(pre));for(i=m;i<=n;i++)pre[i]=cur[i]=sum[i]-sum[i-m];for(i=2;i<=k;i++){memset(cur,0,sizeof(cur));ll temp=0;for(j=m;j+m<=n;j++){if(pre[j]==-1) continue;if(pre[j]>temp) temp=pre[j];cur[j+m]=temp+sum[j+m]-sum[j];}memcpy(pre,cur,sizeof(pre));}ll ans=0;for(i=1;i<=n;i++) if(cur[i]>ans) ans=cur[i];printf("%I64d\n",ans);}return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/39316295	完败…… 掉了101Rank……前一天是网赛，下午有网赛，当晚比赛的时候实在是僵尸一般的困死了……哭……C还fst了……只剩一个A让我怎么活……自然还是献上3题的解题报告——A. Cheap Traveltime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputAnn has recently started commuting by subway. We know that a one ride subway ticket costs a rubles. Besides, Ann found out that she can buy a special ticket for m rides (she can buy it several times). It costsb rubles. Ann did the math; she will need to use subway n times. Help Ann, tell her what is the minimum sum of money she will have to spend to make n rides?InputThe single line contains four space-separated integers n, m, a, b (1 ≤ n, m, a, b ≤ 1000) — the number of rides Ann has planned, the number of rides covered by the m ride ticket, the price of a one ride ticket and the price of an m ride ticket.OutputPrint a single integer — the minimum sum in rubles that Ann will need to spend.Sample test(s)input6 2 1 2output6input5 2 2 3output8NoteIn the first sample one of the optimal solutions is: each time buy a one ride ticket. There are other optimal solutions. For example, buy three m ride tickets.这题呢是说有个人想要去n个地方旅游，有单次票一次去一个地方要花a元，也有联票一次去m个地方，花b元，问去n个地方都旅游完最少花多少钱。之前我想的是可能要刚好去n个地方吧，然后给想复杂了，这题的题意是说旅游到了n个就行了，就是多了也成，那么——对于m个地方，是单程还是联票划算，讨论一下，然后m的整数倍都这么来，最后剩下的几个地方再讨论下就可以了Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))int main(){int n,m,a,b;cin>>n>>m>>a>>b;cout<<min(a*n,min((n/m+1)*b,((n+m)%m)*a+(n/m)*b))<<endl;return 0;}B. Wonder Roomtime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputThe start of the new academic year brought about the problem of accommodation students into dormitories. One of such dormitories has a a × b square meter wonder room. The caretaker wants to accommodate exactly n students there. But the law says that there must be at least 6 square meters per student in a room (that is, the room for n students must have the area of at least 6n square meters). The caretaker can enlarge any (possibly both) side of the room by an arbitrary positive integer of meters. Help him change the room so as alln students could live in it and the total area of the room was as small as possible.InputThe first line contains three space-separated integers n, a and b (1 ≤ n, a, b ≤ 109) — the number of students and the sizes of the room.OutputPrint three integers s, a1 and b1 (a ≤ a1; b ≤ b1) — the final area of the room and its sizes. If there are multiple optimal solutions, print any of them.Sample test(s)input3 3 5output183 6input2 4 4output164 4有一个aXb大小的房间，需要给n个人住（即需要至少6n的面积）问长宽各扩张成多长才行这道题实际上是找i*j>=6n,i>a,j>b的i*j最小整数解。遍历肯定是NodoNodie。先挑出两个长度之间较小的边记作a，另一个叫他b，先考虑a，很明显我们可以遍历a的范围是a~n/a(除不尽的话+1)，对于每个a我们来考虑对应这个a，b应该的值（当然如果刚好就是6n直接输出finish），每次刷新当前离6n最近的面积s记录下来。啊过不去的可以试试这个: 我当时就会有一组数据过不去 4 7 30,是怎么回事呢，细节问题~ 比如那个+1,代码如下Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))ll n, a, b, s, x, y, t;int main(){    cin>>n>>a>>b;    n*=6;  s = -1;    if(a*b>=n) {        s = a*b;        x = a; y = b;    }    else {    if(a<b) {for(ll i=a; i*i<=n; i++) {            t = max(n%i==0?n/i:n/i+1,b);            if(i*t<s||s<0) {x=i; y=t; s=x*y;}        }    }    else {        for(ll i=b; i*i<=n; i++) {            t = max(n%i==0?n/i:n/i+1,a);            if(t*i<s||s<0) {y=i; x=t; s=x*y;}        }      }    }    cout<<s<<endl<<x<<' '<<y<<endl;return 0;}C. Number of Waystime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputYou've got array a[1], a[2], ..., a[n], consisting of n integers. Count the number of ways to split all the elements of the array into three contiguous parts so that the sum of elements in each part is the same.More formally, you need to find the number of such pairs of indices i, j (2 ≤ i ≤ j ≤ n - 1), that .InputThe first line contains integer n (1 ≤ n ≤ 5·105), showing how many numbers are in the array. The second line contains n integers a[1],a[2], ..., a[n] (|a[i]| ≤  109) — the elements of array a.OutputPrint a single integer — the number of ways to split the array into three parts with the same sum.Sample test(s)input51 2 3 0 3output2input40 1 -1 0output1input24 1output0这题是问，有一串数字，我们把它分为三段，三段的和相等，有多少种分法。首先连3个数字都没有的串串自然是边儿呆着去了然后我们先算出个全和，然后1/3的点和2/3的点的值就知道了不是么~然后找出所有这些点，最后……1/3的点在2/3的点左边就行咯（千万注意有的时候和为0的时候别让其中某一段没有分配到数字）~然后为了加速用了下dp~代码如下Code：#include <cstdio>#include <vector>#include <cstring>#include <iostream>using namespace std;#define maxn 500010typedef long long ll;ll a[maxn], n, ls[maxn], rs[maxn], l[maxn], r[maxn], s;int main(){cin>>n; for(int i=1; i<=n; i++) cin>>a[i], s+=a[i];    if(s%3) {        cout<<0<<endl;        return 0;    }    s/=3;    for(int i=1; i<=n; i++) {        ls[i] = ls[i-1] + a[i];        if(ls[i]==s) l[i] = l[i-1] + 1;        else l[i] = l[i-1];    }    ll ans = 0;    for(int i=n; i>0; i--) {        rs[i] = rs[i+1] + a[i];        if(rs[i]==s&&i>2) ans += l[i-2];    }    cout<<ans<<endl;return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/39255627	以后比完赛就要趁早来写解题报告……等得久了之后一旦下一场没打好，写这一场的时候就也没心情了……这一场是打得较好的一场，Rank达到了1694，离DIv1最近的一次……但是#266 掉到1593了，因为精神状态太差……废话不多说先来写一些265的解题报告A. inc ARGtime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputSergey is testing a next-generation processor. Instead of bytes the processor works with memory cells consisting of n bits. These bits are numbered from 1 to n. An integer is stored in the cell in the following way: the least significant bit is stored in the first bit of the cell, the next significant bit is stored in the second bit, and so on; the most significant bit is stored in the n-th bit.Now Sergey wants to test the following instruction: "add 1 to the value of the cell". As a result of the instruction, the integer that is written in the cell must be increased by one; if some of the most significant bits of the resulting number do not fit into the cell, they must be discarded.Sergey wrote certain values ​​of the bits in the cell and is going to add one to its value. How many bits of the cell will change after the operation?InputThe first line contains a single integer n (1 ≤ n ≤ 100) — the number of bits in the cell.The second line contains a string consisting of n characters — the initial state of the cell. The first character denotes the state of the first bit of the cell. The second character denotes the second least significant bit and so on. The last character denotes the state of the most significant bit.OutputPrint a single integer — the number of bits in the cell which change their state after we add 1 to the cell.Sample test(s)input41100output3input41111output4NoteIn the first sample the cell ends up with value 0010, in the second sample — with 0000.这个题目是给你一个反着写的二进制数，问你加一之后有多少个数位变化了，题意不是很容易理解，但是理解了之后就简单的很呢Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int val[101],ans[101];int main(){int n;string s;cin>>n>>s;memset(val,0,sizeof val);memset(ans,0,sizeof ans);for(int i=0;i<n;i++)val[i]=s[i]-'0';int flag=0;for(int pos=0;pos<n;pos++){if(val[pos]==0 && flag==0){ans[pos]=1;flag=1;}else if(val[pos]==1 && flag==0){ans[pos]=0;flag=0;}else ans[pos]=val[pos];}int cnt=0;for(int i=0;i<n;i++){if(ans[i]!=val[i])cnt++;//cout<<ans[i]<<":"<<val[i]<<endl;}cout<<cnt<<endl;return 0;}B. Inbox (100500)time limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputOver time, Alexey's mail box got littered with too many letters. Some of them are read, while others are unread.Alexey's mail program can either show a list of all letters or show the content of a single letter. As soon as the program shows the content of an unread letter, it becomes read letter (if the program shows the content of a read letter nothing happens). In one click he can do any of the following operations:Move from the list of letters to the content of any single letter.Return to the list of letters from single letter viewing mode.In single letter viewing mode, move to the next or to the previous letter in the list. You cannot move from the first letter to the previous one or from the last letter to the next one.The program cannot delete the letters from the list or rearrange them.Alexey wants to read all the unread letters and go watch football. Now he is viewing the list of all letters and for each letter he can see if it is read or unread. What minimum number of operations does Alexey need to perform to read all unread letters?InputThe first line contains a single integer n (1 ≤ n ≤ 1000) — the number of letters in the mailbox.The second line contains n space-separated integers (zeros and ones) — the state of the letter list. The i-th number equals either 1, if the i-th number is unread, or 0, if the i-th letter is read.OutputPrint a single number — the minimum number of operations needed to make all the letters read.Sample test(s)input50 1 0 1 0output3input51 1 0 0 1output4input20 0output0NoteIn the first sample Alexey needs three operations to cope with the task: open the second letter, move to the third one, move to the fourth one.In the second sample the action plan: open the first letter, move to the second letter, return to the list, open the fifth letter.In the third sample all letters are already read.邮箱里有很多邮件，其中1代表还没看过，0代表看过了的，每次点进去一封邮件、点出来回到邮件列表、在邮件内点击查看下一封都是需要操作一次的。问你最少操作多少次才能把邮件看完（注意是看完哦，看完最后一封不需要点出来的哦）想想我平时看邮件的习惯（强迫症自信最优解）：点进第一封没读过的邮件，然后看看下一封读过没，读过了的话点出来再点进之后的第一封没读过的，要是没读过的话直接点击下一封去读。于是就可以直接边读入边操作了，嘛当时保险点还是中规中矩的写的每一个分四种情况（00、01、10、11，0-没读过，1-读过了）Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int sta[1024];int dp[1024];int main(){int n;cin>>n;memset(sta,0,sizeof sta);memset(dp,0,sizeof dp);for(int i=1;i<=n;i++){scanf("%d",&sta[i]);if(sta[i]==1 && sta[i-1]==1) dp[i]=dp[i-1]+1;else if(sta[i]==1 && sta[i-1]==0) dp[i]=dp[i-1]+1;else if(sta[i]==0 && sta[i-1]==1) dp[i]=dp[i-1]+1;else if(sta[i]==0 && sta[i-1]==0) dp[i]=dp[i-1];if(sta[n]==0 && dp[n]!=0)dp[n]--;//cout<<dp[i]<<" ";}cout<<dp[n]<<endl;return 0;}C. No to Palindromes!time limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputPaul hates palindromes. He assumes that string s is tolerable if each its character is one of the first p letters of the English alphabet and s doesn't contain any palindrome contiguous substring of length 2 or more.Paul has found a tolerable string s of length n. Help him find the lexicographically next tolerable string of the same length or else state that such string does not exist.InputThe first line contains two space-separated integers: n and p (1 ≤ n ≤ 1000; 1 ≤ p ≤ 26). The second line contains string s, consisting of n small English letters. It is guaranteed that the string is tolerable (according to the above definition).OutputIf the lexicographically next tolerable string of the same length exists, print it. Otherwise, print "NO" (without the quotes).Sample test(s)input3 3cbaoutputNOinput3 4cbaoutputcbdinput4 4abcdoutputabdaNoteString s is lexicographically larger (or simply larger) than string t with the same length, if there is number i, such that s1 = t1, ..., si = ti, si + 1 > ti + 1.The lexicographically next tolerable string is the lexicographically minimum tolerable string which is larger than the given one.A palindrome is a string that reads the same forward or reversed.说是有一个长度为n的字符串，字符只能在字母表的前p个选取，当前字符串内一定不存在回文序列（一个字符的不算哦），问你它的下一个不存在回文的"能忍的"字符串是什么，如果没有输出NO。这个就得讲讲咯，我们从末尾开始一次一次加一，遇到超过p限制了就变成a，前一位加一（n进制模拟嘛^_^），如果数字们都用完了就No了，这个其实很容易想到的哦，然后就是判定啦，咱们到底啥算能用啥算不能用呢？嘿嘿就是这里啦~ 我们进一位的时候你以为当前位变成1嘛？不不不，我们直接就去遍历前一位不要这一位啦，这样的话是不是只要【当前判定位】的前2位和前1位和自己不一样那么它前面都一定不回文呀？那么，我找到了之后怎么回头确定后头的字符以保证不回文还得最小呢？请看：012012012012012012012012..... 如果当前位和前一位有0或者1了咋办呢？ ^_^你说呢？砍掉一个向后找呗120120120120...\201201201201201201... ^_^那么就over咯~Code:#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))bool cmp(const int a, const int b){return a > b;}int val[1024];int main(){int n,p;cin>>n>>p;string s;cin>>s;if(n==1 && p==1){cout<<"NO"<<endl;return 0;}memset(val,0,sizeof val);for(int i=0;i<n;i++)val[i]=s[i]-'a';int pos=n-1;val[pos]++;while(1){if(pos==0){if(val[pos]>=p) {cout<<"NO"<<endl;return 0;}else {break;}}else if(val[pos]>=p){val[pos]=0;pos--;val[pos]++;}else{if((pos>1 && val[pos]==val[pos-2]) || val[pos]==val[pos-1])val[pos]++;else {break;}}}for(int i=pos+1;i<n;i++){for(int j=0;j<p;j++){if(i>0 && j==val[i-1])continue;else if(i>1 && j==val[i-2])continue;else {val[i]=j;break;}}}for(int i=0;i<n;i++){printf("%c",'a'+val[i]);}return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/39122251	这场打得比较顺畅，直接涨分到了1666三道题33分钟全1A……可能短期内都无法超越自己了……接下来写点题解A. Appleman and Easy Tasktime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputToastman came up with a very easy task. He gives it to Appleman, but Appleman doesn't know how to solve it. Can you help him?Given a n × n checkerboard. Each cell of the board has either character 'x', or character 'o'. Is it true that each cell of the board has even number of adjacent cells with 'o'? Two cells of the board are adjacent if they share a side.InputThe first line contains an integer n (1 ≤ n ≤ 100). Then n lines follow containing the description of the checkerboard. Each of them contains n characters (either 'x' or 'o') without spaces.OutputPrint "YES" or "NO" (without the quotes) depending on the answer to the problem.Sample test(s)input3xxoxoxoxxoutputYESinput4xxxoxoxooxoxxxxxoutputNO这道题的意思是，任何一个格子，与他相邻的格子中圆圈的个数都得是偶数，否则输出NO那么我们读入一边然后遍历每一个格子咯~ 边缘和读入时候的换行符都要注意呢~Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))int main(){int n,flag=0;cin>>n;char c,map[101][101];for(int i=0;i<n;i++){scanf("%c",&c);//huichefor(int j=0;j<n;j++){scanf("%c",&map[i][j]);}} for(int i=0;i<n;i++){for(int j=0;j<n;j++){int cnt=0;if(i>0 && map[i-1][j]=='o')cnt++;if(i<n-1 && map[i+1][j]=='o')cnt++;if(j>0 && map[i][j-1]=='o')cnt++;if(j<n-1 && map[i][j+1]=='o')cnt++;//cout<<i<<" "<<j<<": "<<cnt<<endl;if(cnt%2!=0)flag=1; }}if(flag)printf("NO");else printf("YES");return 0;} B. Appleman and Card Gametime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputAppleman has n cards. Each card has an uppercase letter written on it. Toastman must choose k cards from Appleman's cards. Then Appleman should give Toastman some coins depending on the chosen cards. Formally, for each Toastman's card i you should calculate how much Toastman's cards have the letter equal to letter on ith, then sum up all these quantities, such a number of coins Appleman should give to Toastman.Given the description of Appleman's cards. What is the maximum number of coins Toastman can get?InputThe first line contains two integers n and k (1 ≤ k ≤ n ≤ 105). The next line contains n uppercase letters without spaces — the i-th letter describes the i-th card of the Appleman.OutputPrint a single integer – the answer to the problem.Sample test(s)input15 10DZFDFZDFDDDDDDFoutput82input6 4YJSNPIoutput4NoteIn the first test example Toastman can choose nine cards with letter D and one additional card with any letter. For each card with D he will get 9 coins and for the additional card he will get 1 coin.这道题的意思是，我有n张牌，需要从里面选取k张，每张牌的点数是我选的这种牌的张数，如ABBCCC=1*1+2*2+3*3，我们知道，当和一定时，最大的那个数越大，则平方和越大，所以我们先排序，然后从多的往少的拿就好Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))using namespace std;typedef long long ll;int amt[27];bool cmp(const int a, const int b){return a > b;}int main(){char c;int n,k;cin>>n>>k;scanf("%c",&c);//huichememset(amt,0,sizeof amt);for(int i=1;i<=n;i++){scanf("%c",&c);amt[(c-'A')]++;}sort(amt,amt+26,cmp);//for(int i=0;i<26;i++)cout<<amt[i]<<endl;ll ans=0;for(int i=0;i<26;i++){if(k>=amt[i]) {ans+=(ll)amt[i]*(ll)amt[i];k-=amt[i];}else{ans+=(ll)k*(ll)k;k=0;}if(k==0){printf("%I64d",ans);return 0;}}return 0;} C. Appleman and Toastmantime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputAppleman and Toastman play a game. Initially Appleman gives one group of n numbers to the Toastman, then they start to complete the following tasks:Each time Toastman gets a group of numbers, he sums up all the numbers and adds this sum to the score. Then he gives the group to the Appleman.Each time Appleman gets a group consisting of a single number, he throws this group out. Each time Appleman gets a group consisting of more than one number, he splits the group into two non-empty groups (he can do it in any way) and gives each of them to Toastman.After guys complete all the tasks they look at the score value. What is the maximum possible value of score they can get?InputThe first line contains a single integer n (1 ≤ n ≤ 3·105). The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 106) — the initial group that is given to Toastman.OutputPrint a single integer — the largest possible score.Sample test(s)input33 1 5output26input110output10NoteConsider the following situation in the first example. Initially Toastman gets group [3, 1, 5] and adds 9 to the score, then he give the group to Appleman. Appleman splits group [3, 1, 5] into two groups: [3, 5] and [1]. Both of them should be given to Toastman. When Toastman receives group [1], he adds 1 to score and gives the group to Appleman (he will throw it out). When Toastman receives group [3, 5], he adds 8 to the score and gives the group to Appleman. Appleman splits [3, 5] in the only possible way: [5] and [3]. Then he gives both groups to Toastman. When Toastman receives [5], he adds 5 to the score and gives the group to Appleman (he will throws it out). When Toastman receives [3], he adds 3 to the score and gives the group to Appleman (he will throws it out). Finally Toastman have added 9 + 1 + 8 + 5 + 3 = 26 to the score. This is the optimal sequence of actions.这道题和刚才的B题有着异曲同工之妙这道题的意思是，有两个人AB，A负责把所有只有一个数字的集合扔掉，同时把多于一个数字的集合分成两个集合扔给B，B负责把获得的集合里的数字们都加起来然后还给A。问获得的数字和最大是多少。我们可以模拟一下，有n个数字的话，我们不管怎么分，数字们被重复计算的次数是和n有关的一个式子：从大到小分别是n,n,n-1,n-2......3,2次，所以，自然是把大的数字放在前面啦~Code:#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))using namespace std;typedef long long ll;ll ans=0;int num[300033];bool cmp(const int a, const int b){return a > b;}int main(){int n;scanf("%d",&n);for(int i=0;i<n;i++){scanf("%d",&num[i]);ans+=num[i];}sort(num,num+n,cmp);ans-=num[0];for(int i=0;i<n;i++){ans+=(ll)num[i]*(ll)(n-i);}printf("%I64d",ans);return 0;} 版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/39122145	似乎就是这场没打好，然后262-263都没更新……抱歉…… 262当场只出了2题……趁着现在#265赛前来写一下题解^_^A. Vasya and Sockstime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputVasya has n pairs of socks. In the morning of each day Vasya has to put on a pair of socks before he goes to school. When he comes home in the evening, Vasya takes off the used socks and throws them away. Every m-th day (at days with numbers m, 2m, 3m, ...) mom buys a pair of socks to Vasya. She does it late in the evening, so that Vasya cannot put on a new pair of socks before the next day. How many consecutive days pass until Vasya runs out of socks?InputThe single line contains two integers n and m (1 ≤ n ≤ 100; 2 ≤ m ≤ 100), separated by a space.OutputPrint a single integer — the answer to the problem.Sample test(s)input2 2output3input9 3output13NoteIn the first sample Vasya spends the first two days wearing the socks that he had initially. Then on day three he puts on the socks that were bought on day two.In the second sample Vasya spends the first nine days wearing the socks that he had initially. Then he spends three days wearing the socks that were bought on the third, sixth and ninth days. Than he spends another day wearing the socks that were bought on the twelfth day.这熊孩子原先有n双袜子，每天消耗一双，每m天他的麻麻给他买一双，问——他能坚持多少天……数据才100，当然是模拟啦^_^Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))int main(){int n,m;cin>>n>>m;int day=0;while(n){day++, n--;if(day!=0 && day%m==0) n++;}cout<< day <<endl;return 0;}B. Little Dima and Equationtime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputLittle Dima misbehaved during a math lesson a lot and the nasty teacher Mr. Pickles gave him the following problem as a punishment.Find all integer solutions x (0 < x < 109) of the equation:x = b·s(x)a + c, where a, b, c are some predetermined constant values and function s(x) determines the sum of all digits in the decimal representation of number x.The teacher gives this problem to Dima for each lesson. He changes only the parameters of the equation: a, b, c. Dima got sick of getting bad marks and he asks you to help him solve this challenging problem.InputThe first line contains three space-separated integers: a, b, c (1 ≤ a ≤ 5; 1 ≤ b ≤ 10000;  - 10000 ≤ c ≤ 10000).OutputPrint integer n — the number of the solutions that you've found. Next print n integers in the increasing order — the solutions of the given equation. Print only integer solutions that are larger than zero and strictly less than 109.Sample test(s)input3 2 8output310 2008 13726 input1 2 -18output0input2 2 -1output41 31 337 967 x = b·s(x)a + c, 有这么一个式子，问你给你a,b,c了之后，有多少满足条件的x存在这个很巧妙的哦~千万别想着枚举x，再怎么简直都活不过去……1e9还得了。仔细想想哦~，s(x)是不是很少呀？这题阻碍大家AC的几个不能算坑的坑如下：（这题简直成为hacker涨分的利器了，各种B题Hack一片的）1. 1e9是九九八十一不是八九七十二哦~2. 大家好我叫longlong我又坑到人了3. 对0次方以及0的n次方的处理Code:#include <cmath> #include <queue>#include <vector>#include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))ll a,b,c;ll vpow[88][8];priority_queue< int,vector<int>,greater<int> > pq;int s(ll x){ll tmp=x;ll ret=0;while(tmp){ret+=tmp%10;tmp/=10;} return ret;}void init(){while(!pq.empty())pq.pop();for(int i=1;i<=81;i++){vpow[i][1]=i;for(int j=2;j<=5;j++)vpow[i][j]=vpow[i][j-1]*i;}}void solve(){ll temp;for(int i=1;i<=81;i++){temp=(ll)vpow[i][a]*(ll)b+(ll)c;if(s(temp)==i && temp>0 && temp<(int)1e9) {int tmp=vpow[i][a]*b+c;pq.push(tmp);}}if(pq.empty())printf("0\n");else{printf("%d\n",pq.size());while(!pq.empty()){int a=pq.top();printf("%d ",a);pq.pop(); }}}int main(){cin>>a>>b>>c; init();solve();return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/38704203	A. Harry Potter and Three Spellstime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputA long time ago (probably even in the first book), Nicholas Flamel, a great alchemist and the creator of the Philosopher's Stone, taught Harry Potter three useful spells. The first one allows you to convert agrams of sand into b grams of lead, the second one allows you to convert c grams of lead into d grams of gold and third one allows you to convert e grams of gold into f grams of sand. When Harry told his friends about these spells, Ron Weasley was amazed. After all, if they succeed in turning sand into lead, lead into gold, and then turning part of the gold into sand again and so on, then it will be possible to start with a small amount of sand and get huge amounts of gold! Even an infinite amount of gold! Hermione Granger, by contrast, was skeptical about that idea. She argues that according to the law of conservation of matter getting an infinite amount of matter, even using magic, is impossible. On the contrary, the amount of matter may even decrease during transformation, being converted to magical energy. Though Hermione's theory seems convincing, Ron won't believe her. As far as Ron is concerned, Hermione made up her law of conservation of matter to stop Harry and Ron wasting their time with this nonsense, and to make them go and do homework instead. That's why Ron has already collected a certain amount of sand for the experiments. A quarrel between the friends seems unavoidable...Help Harry to determine which one of his friends is right, and avoid the quarrel after all. To do this you have to figure out whether it is possible to get the amount of gold greater than any preassigned number from some finite amount of sand.InputThe first line contains 6 integers a, b, c, d, e, f (0 ≤ a, b, c, d, e, f ≤ 1000).OutputPrint "Ron", if it is possible to get an infinitely large amount of gold having a certain finite amount of sand (and not having any gold and lead at all), i.e., Ron is right. Otherwise, print "Hermione".Sample test(s)input100 200 250 150 200 250outputRoninput100 50 50 200 200 100outputHermioneinput100 10 200 20 300 30outputHermioneinput0 0 0 0 0 0outputHermioneinput1 1 0 1 1 1outputRoninput1 0 1 2 1 2outputHermioneinput100 1 100 1 0 1outputRonNoteConsider the first sample. Let's start with the 500 grams of sand. Apply the first spell 5 times and turn the sand into 1000 grams of lead. Then apply the second spell 4 times to get 600 grams of gold. Let’s take 400 grams from the resulting amount of gold turn them back into sand. We get 500 grams of sand and 200 grams of gold. If we apply the same operations to 500 grams of sand again, we can get extra 200 grams of gold every time. Thus, you can get 200, 400, 600 etc. grams of gold, i.e., starting with a finite amount of sand (500 grams), you can get the amount of gold which is greater than any preassigned number.In the forth sample it is impossible to get sand, or lead, or gold, applying the spells.In the fifth sample an infinitely large amount of gold can be obtained by using only the second spell, which allows you to receive 1 gram of gold out of nothing. Note that if such a second spell is available, then the first and the third one do not affect the answer at all.The seventh sample is more interesting. We can also start with a zero amount of sand there. With the aid of the third spell you can get sand out of nothing. We get 10000 grams of sand in this manner. Let's get 100 grams of lead using the first spell 100 times. Then make 1 gram of gold from them. We managed to receive 1 gram of gold, starting with a zero amount of sand! Clearly, in this manner you can get an infinitely large amount of gold.有三种物质，罗恩说我有三个法术可以让它们按顺序转化，所以可以获得无限金，赫敏说不可能法术1： a克沙->b克铅法术2： c克铅->d克金法术3： e克金->f克沙简单数论，但是神烦……很多东西都可能考虑不到1）大家肯定立马想到的就是绕一圈回来有没有多，变换率>1.0肯定就Ron了对不对？但是还有 2）如果0克铅可以换非0克金，也是无限以及必须需要 3）如果d为0，打死都得不到一点金然后我没想到的是4）ab都是0的时候无法获得铅，就算铅换金很划算也没有意义#include <cstdio>using namespace std;int main(){int a,b,c,d,e,f;while (scanf("%d%d%d%d%d%d",&a,&b,&c,&d,&e,&f)!=EOF) {if(d && (!c || !a&&b) || a*c*e < b*d*f)printf("Ron\n");        elseprintf("Hermione\n");}return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/38704187	这道题没有太大意义……主要是也在A题= =是考语言的……ActiveTCL限定……无视掉就好A. Factorialtime limit per test2 secondsmemory limit per test64 megabytesinputstandard inputoutputstandard outputPrint the factorial of the given integer number n. The factorial of n is equal to 1·2·...·n.InputThe only line contains n (1 ≤ n ≤ 10).OutputPrint the factorial of n.Sample test(s)input3output6input5output120set A [gets stdin]set fact 1for {set i 0} {$i < $A} {incr i} {    set fact [expr {$fact * ($i + 1)}]}puts $fact 版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/38704137	A. Sinking Shiptime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputThe ship crashed into a reef and is sinking. Now the entire crew must be evacuated. All n crew members have already lined up in a row (for convenience let's label them all from left to right with positive integers from 1 to n) and await further instructions. However, one should evacuate the crew properly, in a strict order. Specifically:The first crew members to leave the ship are rats. Then women and children (both groups have the same priority) leave the ship. After that all men are evacuated from the ship. The captain leaves the sinking ship last.If we cannot determine exactly who should leave the ship first for any two members of the crew by the rules from the previous paragraph, then the one who stands to the left in the line leaves the ship first (or in other words, the one whose number in the line is less).For each crew member we know his status as a crew member, and also his name. All crew members have different names. Determine the order in which to evacuate the crew.InputThe first line contains an integer n, which is the number of people in the crew (1 ≤ n ≤ 100). Then follow n lines. The i-th of those lines contains two words — the name of the crew member who is i-th in line, and his status on the ship. The words are separated by exactly one space. There are no other spaces in the line. The names consist of Latin letters, the first letter is uppercase, the rest are lowercase. The length of any name is from 1 to 10 characters. The status can have the following values: rat for a rat, woman for a woman, child for a child, man for a man, captain for the captain. The crew contains exactly one captain.OutputPrint n lines. The i-th of them should contain the name of the crew member who must be the i-th one to leave the ship.Sample test(s)input6Jack captainAlice womanCharlie manTeddy ratBob childJulia womanoutputTeddyAliceBobJuliaCharlieJack船要沉了，船上有n个人，要求他们按照rat<women&child<man<captain的顺序下船，所以我们要做的是把每个人按照身份拍成4队，然后按照这四队的顺序下船我在这里用的是queue，实际上，数组，vector，map，list都可以，选用最熟悉的存储结构就好为了标明这些都代表什么，用同样可以运行的另一种写法的代码注释在一边了^_^#include <queue>#include <cstdio>#include <memory>#include <string>#include <cstring>#include <iostream>#include <algorithm>using namespace std;//queue<string> rat,w_c,man,cap;queue<string> q[4];int main(){int n;cin>>n;string name, r;for(int ni=0;ni<n;ni++){cin>>name>>r;if(r=="rat")q[0].push(name);//rat.push(name);else if(r=="man")q[2].push(name);//man.push(name);else if(r=="captain")q[3].push(name);//cap.push(name);else if(r=="woman" || r=="child")q[1].push(name);//w_c.push(name);} for(int i=0;i<4;i++){while(!q[i].empty()){string s=q[i].front();cout<<s<<endl;q[i].pop();}} /* while(!rat.empty()){string s=rat.front();rat.pop(); cout<<s<<endl;}while(!w_c.empty()){string s=w_c.front();w_c.pop(); cout<<s<<endl;}while(!man.empty()){string s=man.front();man.pop(); cout<<s<<endl;}while(!cap.empty()){string s=cap.front();cap.pop(); cout<<s<<endl;}*/ return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/38704057	A. A Student's Dreamtime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputStatistics claims that students sleep no more than three hours a day. But even in the world of their dreams, while they are snoring peacefully, the sense of impending doom is still upon them.A poor student is dreaming that he is sitting the mathematical analysis exam. And he is examined by the most formidable professor of all times, a three times Soviet Union Hero, a Noble Prize laureate in student expulsion, venerable Petr Palych.The poor student couldn't answer a single question. Thus, instead of a large spacious office he is going to apply for a job to thorium mines. But wait a minute! Petr Palych decided to give the student the last chance! Yes, that is possible only in dreams.So the professor began: "Once a Venusian girl and a Marsian boy met on the Earth and decided to take a walk holding hands. But the problem is the girl has al fingers on her left hand and ar fingers on the right one. The boy correspondingly has bl and br fingers. They can only feel comfortable when holding hands, when no pair of the girl's fingers will touch each other. That is, they are comfortable when between any two girl's fingers there is a boy's finger. And in addition, no three fingers of the boy should touch each other. Determine if they can hold hands so that the both were comfortable."The boy any the girl don't care who goes to the left and who goes to the right. The difference is only that if the boy goes to the left of the girl, he will take her left hand with his right one, and if he goes to the right of the girl, then it is vice versa.InputThe first line contains two positive integers not exceeding 100. They are the number of fingers on the Venusian girl's left and right hand correspondingly. The second line contains two integers not exceeding 100. They are the number of fingers on the Marsian boy's left and right hands correspondingly.OutputPrint YES or NO, that is, the answer to Petr Palych's question.Sample test(s)input5 110 5outputYESinput4 53 3outputYESinput1 211 6outputNONoteThe boy and the girl don't really care who goes to the left.有一个（让我哭会儿）少年，他梦见了和自己心爱的女孩牵手……为了让两人牵手的时候都觉得舒服，每两个女生的手指间都必须有一个男生的手指，但是每两个女生的手指间不得超过两个男生的手指…… 男生女生的左右手指数告诉你（但是为什么会有100根手指的定义域？！！）问这次牵手能不能舒服……首先男左女右，男友女左都得考虑接着，女生的手指数减一是舒服时所需男生手指数最小的时候，最大的时候呢是(女生手指数+1)X2,因为最左和左右的手指外头还能放手指：所以值域是(x-1,2x+2)#include <cstdio>#include <memory>#include <string>#include <cstring>#include <iostream>#include <algorithm>using namespace std;int vl,vr,ml,mr;//girl L/R & boy L/R bool judge(int g, int b)//girl & boy{if(b<g-1)return false;else if(b>2*g+2) return false;else return true;}int main(){cin>>vl>>vr>>ml>>mr;if(judge(vl,mr) || judge(vr,ml))cout<<"YES"<<endl;else cout<<"NO"<<endl;return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/38703935	A. Ultra-Fast Mathematiciantime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputShapur was an extremely gifted student. He was great at everything including Combinatorics, Algebra, Number Theory, Geometry, Calculus, etc. He was not only smart but extraordinarily fast! He could manage to sum 1018 numbers in a single second.One day in 230 AD Shapur was trying to find out if any one can possibly do calculations faster than him. As a result he made a very great contest and asked every one to come and take part.In his contest he gave the contestants many different pairs of numbers. Each number is made from digits 0 or 1. The contestants should write a new number corresponding to the given pair of numbers. The rule is simple: The i-th digit of the answer is 1 if and only if the i-th digit of the two given numbers differ. In the other case the i-th digit of the answer is 0.Shapur made many numbers and first tried his own speed. He saw that he can perform these operations on numbers of length ∞ (length of a number is number of digits in it) in a glance! He always gives correct answers so he expects the contestants to give correct answers, too. He is a good fellow so he won't give anyone very big numbers and he always gives one person numbers of same length.Now you are going to take part in Shapur's contest. See if you are faster and more accurate.InputThere are two lines in each input. Each of them contains a single number. It is guaranteed that the numbers are made from 0 and 1 only and that their length is same. The numbers may start with 0. The length of each number doesn't exceed 100.OutputWrite one line — the corresponding answer. Do not omit the leading 0s.Sample test(s)input10101000100101output1110001input000111output111input11101010output0100input0111001100output00010这道题问的算是裸的异或运算概念，不同为true，同为false#include <cstdio>#include <memory>#include <string>#include <cstring>#include <iostream>#include <algorithm>using namespace std;int main(){string s1,s2;cin>>s1>>s2;for(int i=0;i<s1.length();i++)if(s1[i]==s2[i])cout<<0; else cout<<1;return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/38703835	A. Where Are My Flakes?time limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputOne morning the Cereal Guy found out that all his cereal flakes were gone. He found a note instead of them. It turned out that his smart roommate hid the flakes in one of n boxes. The boxes stand in one row, they are numbered from 1 to n from the left to the right. The roommate left hints like "Hidden to the left of the i-th box" ("To the left of i"), "Hidden to the right of the i-th box" ("To the right of i"). Such hints mean that there are no flakes in the i-th box as well. The Cereal Guy wants to know the minimal number of boxes he necessarily needs to check to find the flakes considering all the hints. Or he wants to find out that the hints are contradictory and the roommate lied to him, that is, no box has the flakes.InputThe first line contains two integers n and m (1 ≤ n ≤ 1000, 0 ≤ m ≤ 1000) which represent the number of boxes and the number of hints correspondingly. Next m lines contain hints like "To the left of i" and "To the right of i", where i is integer (1 ≤ i ≤ n). The hints may coincide.OutputThe answer should contain exactly one integer — the number of boxes that should necessarily be checked or "-1" if the hints are contradictory.Sample test(s)input2 1To the left of 2output1input3 2To the right of 1To the right of 2output1input3 1To the left of 3output2input3 2To the left of 2To the right of 1output-1这道题的意思是说给n个箱子（按照1-n的编号），有m句话，告诉你对的箱子在X号箱子的左边或者右边，问你最终符合条件的箱子有多少个，如果一个都没有输出-1字符串读入咯~ 记住用getline哟，cin或者%s都是空格截断的~#include <cstdio>#include <memory>#include <string>#include <cstring>#include <iostream>#include <algorithm>using namespace std;int main(){string s;int n,m,l,r,ans;cin>>n>>m;l=0,r=n+1,ans=0;char huiche,dir;scanf("%c",&huiche);for(int i=0;i<m;i++){getline(cin,s);int len=s.length()-1,num=0,tlen;dir=s[7],tlen=len;//cout<<dir<<endl;while(s[tlen]!=' ')tlen--;for(int j=1;j+tlen<=s.length()-1;tlen++)num= num*10 + s[tlen+j]-'0';if(dir=='l'){r=min(r,num);if(num<l || num==1) ans=-1;}else if(dir=='r'){l=max(l,num);if(num>r || num==n)ans=-1;}if(r<l || ans==-1)break;}if(ans==-1 || r-l==1)cout<<"-1";else{ans=r-l-1;cout<<ans;}return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/38680233	﻿﻿MUTC中自己手敲的一个记录sequence中int型出现位置模板#include <map>#include <list>#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <memory>#include <cstdlib>#include <cstring>#include <utility>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))int a[100086],b[100086],c[100086];map<int, list<int> > m;int main(){int n;while(scanf("%d",&n)!=EOF){if(n==0)return 0;else m.clear();memset(a,0,sizeof a);memset(b,0,sizeof b);memset(c,0,sizeof c);for(int i=1;i<=n;i++){scanf("%d",&a[i]);if(m.find(a[i])==m.end()){list<int> tmp;while(!tmp.empty())tmp.pop_back();tmp.push_back(i);m.insert(pair<int,list<int> >(a[i],tmp));}else m[a[i]].push_back(i);}map<int,list<int> >::iterator mit;list<int>  ::iterator lit;for(mit=m.begin();mit!=m.end();++mit){printf("%d:",mit->first);list<int> now=mit->second;for(lit=now.begin();lit!=now.end();++lit) printf("%d ",*lit);printf("\n");}}return 0;} 版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/38605291	COUT我恨你……大家注意哦，printf比cout快很多……这次原先C题我出的是最快的，除去超强的qwzeng学长我就是第一名了，然后FinalTest跪了，就变成只有2题AC了……就倒数了，哭……无奈了……当然这里贴给大家的是对的啦，自己在cf上提交ac过了……A. Pashmak and Gardentime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputPashmak has fallen in love with an attractive girl called Parmida since one year ago...Today, Pashmak set up a meeting with his partner in a romantic garden. Unfortunately, Pashmak has forgotten where the garden is. But he remembers that the garden looks like a square with sides parallel to the coordinate axes. He also remembers that there is exactly one tree on each vertex of the square. Now, Pashmak knows the position of only two of the trees. Help him to find the position of two remaining ones.InputThe first line contains four space-separated x1, y1, x2, y2 ( - 100 ≤ x1, y1, x2, y2 ≤ 100) integers, where x1 and y1 are coordinates of the first tree and x2 and y2 are coordinates of the second tree. It's guaranteed that the given points are distinct.OutputIf there is no solution to the problem, print -1. Otherwise print four space-separated integers x3, y3, x4, y4 that correspond to the coordinates of the two other trees. If there are several solutions you can output any of them.Note that x3, y3, x4, y4 must be in the range ( - 1000 ≤ x3, y3, x4, y4 ≤ 1000).Sample test(s)input0 0 0 1output1 0 1 1input0 0 1 1output0 1 1 0input0 0 1 2output-1A题的意思呢是给你两个点的坐标，问这两个能否作为一个正方形的两个点，如果可以，输出正方形的另两个点所以我们就这么判断：1）如果给的两个点连线是竖直的（x1==x2）2）如果给的两个点连线是水平的（y1==y2）3）如果两个点是对角点且可以构成正方形（两个差值绝对值相等）Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))int main(){int x1,y1,x2,y2,x3,y3,x4,y4,l;cin>>x1>>y1>>x2>>y2;if(x1==x2){l=abs(y1-y2);x3=x4=(x1-l>=-1000?(x1-l):(x1+l));if(x3==x1+l && x1+l>1000)cout<<-1<<endl;else cout<<x3<<" "<<y1<<" "<<x4<<" "<<y2<<endl;}else if(y1==y2){l=abs(x1-x2);y3=y4=(y1-l>=-1000?(y1-l):(y1+l));if(y3==y1+l && y1+l>1000)cout<<-1<<endl;else cout<<x1<<" "<<y3<<" "<<x2<<" "<<y4<<endl;}else{if(abs(x1-x2)!=abs(y1-y2))cout<<-1<<endl;else cout<<x1<<" "<<y2<<" "<<x2<<" "<<y1<<endl;}return 0;}B. Pashmak and Flowerstime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputPashmak decided to give Parmida a pair of flowers from the garden. There are n flowers in the garden and the i-th of them has a beauty number bi. Parmida is a very strange girl so she doesn't want to have the two most beautiful flowers necessarily. She wants to have those pairs of flowers that their beauty difference is maximal possible!Your task is to write a program which calculates two things:The maximum beauty difference of flowers that Pashmak can give to Parmida.The number of ways that Pashmak can pick the flowers. Two ways are considered different if and only if there is at least one flower that is chosen in the first way and not chosen in the second way.InputThe first line of the input contains n (2 ≤ n ≤ 2·105). In the next line there are n space-separated integers b1, b2, ...,bn (1 ≤ bi ≤ 109).OutputThe only line of output should contain two integers. The maximum beauty difference and the number of ways this may happen, respectively.Sample test(s)input21 2output1 1input31 4 5output4 1input53 1 2 3 1output2 4NoteIn the third sample the maximum beauty difference is 2 and there are 4 ways to do this:choosing the first and the second flowers;choosing the first and the fifth flowers;choosing the fourth and the second flowers;choosing the fourth and the fifth flowers.这题的意思是问最大值和最小值的差，以及最大值&最小值的对（Pair）有多少咱们遍历一遍找出最大值和最小值，同时输出有多少个，然后差就有了，数对的个数不就是两个cnt相乘，多简单~不好意思，WA at 5为啥呢？ 哈哈 如果所有值都是一样的咋办呢对不对^_^ ~ 是C（n,2）~~所以代码如下Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))int main(){int n;cin>>n;int max=0,min=2147483646,max_cnt=0,min_cnt=0,now;for(int ni=0;ni<n;ni++){cin>>now;if(now>max)max=now,max_cnt=0;if(max==now) max_cnt++;if(now<min) min=now,min_cnt=0;if(min==now) min_cnt++;} if(max==min) cout<<0<<" "<<(ll)max_cnt*(ll)(min_cnt-1)/2<<endl;else cout<<(max-min)<<" "<<(ll)max_cnt*(ll)min_cnt<<endl;return 0;}C. Pashmak and Busestime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputRecently Pashmak has been employed in a transportation company. The company has k buses and has a contract with a school which has n students. The school planned to take the students to d different places for d days (each day in one place). Each day the company provides all the buses for the trip. Pashmak has to arrange the students in the buses. He wants to arrange the students in a way that no two students become close friends. In his ridiculous idea, two students will become close friends if and only if they are in the same buses for all d days.Please help Pashmak with his weird idea. Assume that each bus has an unlimited capacity.InputThe first line of input contains three space-separated integers n, k, d (1 ≤ n, d ≤ 1000; 1 ≤ k ≤ 109).OutputIf there is no valid arrangement just print -1. Otherwise print d lines, in each of them print n integers. The j-th integer of the i-th line shows which bus the j-th student has to take on the i-th day. You can assume that the buses are numbered from 1 to k.Sample test(s)input3 2 2output1 1 2 1 2 1 input3 2 1output-1NoteNote that two students become close friends only if they share a bus each day. But the bus they share can differ from day to day.这里有一个特别不愿意成人之美的人~ 就是说不允许任何俩小盆友每天都在同一辆车上。问能不能做到，不能输出-1，能的话输出每一天每个人坐的车的编号（1-k）我们不横着看，咱竖着看，是不是能发现什么呢^_^比如样例一：第一个小盆友坐车的编号是 11第二个小盆友是12第三个小盆友是21（其实可以再来个第四个小盆友是22）竖着看的话是不是分分钟能发现这个问题的等效问题呢？既然不能有两个小盆友每天的车号都一致，即每两个小盆友竖着看都不能是同一个序列对不对。这个序列是每一位不超过k的数列的序列，那我们就把这个当成一个k+1（车数加一）进制的d（天数）位数能否表示n个不同的数值呢~可以的话是不是从1111..111到kkkk...kkk能表示就是可行，不能就是不行哇~在那之前，咱们通过judge函数（ll来存，一旦d自乘超过n就说明可行，k都用完了还没超过就输出-1）来直接预判剪枝大大降低时间~Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;typedef long long ll;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))int n,k,d,depth;int stu[1008][1008];  //stu(d,n)=no.kint judge(){ll tmp=k,tmpd=d;while(1){if(tmp>=n)return (int)d-(int)tmpd+1;if(tmpd==1)return -1;tmpd--;tmp*=k;}}void init(){memset(stu,0,sizeof stu);for(int i=1;i<=depth;i++)stu[i][1]=1;for(int j=2;j<=n;j++){stu[depth][j]+=1;for(int i=depth;i>=1;i--){stu[i][j]+=(stu[i][j-1]);if(stu[i][j]>k)stu[i][j]=stu[i][j]%k,stu[i-1][j]++;}}}int main(){cin>>n>>k>>d;depth=judge();if(depth==-1){cout<<-1<<endl;return 0;}else init();for(int i=1;i<=depth;i++){cout<<stu[i][1];for(int j=2;j<=n;j++){cout<<" "<<stu[i][j];}cout<<endl;}for(int i=depth+1;i<=d;i++){cout<<stu[i][1]+1;for(int j=2;j<=n;j++){cout<<" "<<stu[i][j]+1;}cout<<endl;}return 0;}﻿﻿版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/38583479	﻿﻿这次咱Team453出了仨题~Monster（1006）Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 2201    Accepted Submission(s): 510Problem Description   Teacher Mai has a kingdom. A monster has invaded this kingdom, and Teacher Mai wants to kill it.   Monster initially has h HP. And it will die if HP is less than 1.   Teacher Mai and monster take turns to do their action. In one round, Teacher Mai can attack the monster so that the HP of the monster will be reduced by a. At the end of this round, the HP of monster will be increased by b.   After k consecutive round's attack, Teacher Mai must take a rest in this round. However, he can also choose to take a rest in any round.   Output "YES" if Teacher Mai can kill this monster, else output "NO". Input   There are multiple test cases, terminated by a line "0 0 0 0".   For each test case, the first line contains four integers h,a,b,k(1<=h,a,b,k <=10^9). Output   For each case, output "Case #k: " first, where k is the case number counting from 1. Then output "YES" if Teacher Mai can kill this monster, else output "NO". Sample Input5 3 2 20 0 0 0 Sample OutputCase #1: NO 这道题大家都出了咱就不怎么多说啦~ 大概意思呢是说有个怪物，他有h滴血，我们的攻击力呢是每次a点，但打完之后怪会恢复b点血，我们每次最多持续攻击k次之后就得休息一次呆呆的望着怪回一回合的血，问咱能不能打过这个怪——所以呀，有这么几种情况要考虑哦~ （打完K局休息1局的这一个轮回称作一个周目）1)  一招克敌，这个不能忘记哦，如果我们第一刀就能秒怪要单独写哦，免得怪第一次恢复近似无限大还怎么玩对不对~2)  一周目内怪回血前的那一刀秒怪（在第K次攻击时攻击积累为最大，所以非第一次攻击到这一次都可以用这一个来判断完）3)  一周目中总伤害大于零，那么终有一日怪必死无疑Code：#include<cstdio>#include<iostream>using namespace std;typedef long long ll;int main(){    ll h,a,b,k;    int cas=1;    while(~scanf("%I64d%I64d%I64d%I64d",&h,&a,&b,&k)){        if (h==0&&a==0&&b==0&&k==0) break;        if (k*a>(k+1)*b||a>=h||(k-1)*(a-b)+a>=h)  printf("Case #%d: YES\n",cas);        else printf("Case #%d: NO\n",cas);        cas++;    }    return 0;}Multiplication table（1007 By Bluewind）Time Limit: 4000/2000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 370    Accepted Submission(s): 71Problem Description   Teacher Mai has a multiplication table in base p.   For example, the following is a multiplication table in base 4:*  0  1  2  30 00 00 00 001 00 01 02 032 00 02 10 123 00 03 12 21   But a naughty kid maps numbers 0..p-1 into another permutation and shuffle the multiplication table.   For example Teacher Mai only can see:1*1=11 1*3=11 1*2=11 1*0=113*1=11 3*3=13 3*2=12 3*0=102*1=11 2*3=12 2*2=31 2*0=320*1=11 0*3=10 0*2=32 0*0=23   Teacher Mai wants you to recover the multiplication table. Output the permutation number 0..p-1 mapped into.   It's guaranteed the solution is unique. Input   There are multiple test cases, terminated by a line "0".   For each test case, the first line contains one integer p(2<=p<=500).   In following p lines, each line contains 2*p integers.The (2*j+1)-th number x and (2*j+2)-th number y in the i-th line indicates equation i*j=xy in the shuffled multiplication table.   Warning: Large IO! Output   For each case, output one line.   First output "Case #k:", where k is the case number counting from 1. The following are p integers, indicating the permutation number 0..p-1 mapped into. Sample Input42 3 1 1 3 2 1 01 1 1 1 1 1 1 13 2 1 1 3 1 1 21 0 1 1 1 2 1 30 Sample OutputCase #1: 1 3 2 0 岩哥的代码，先贴着，等我看完再写结题报告Code：#include<iostream>#include<cstring>#include<cstdio>#include<algorithm>#include<cmath>#include<vector>using namespace std;int intab[509][509*2];int incnt[509], cnt[509];int p, tp, id, nums;int stod[509],dtos[509];bool find(){    for(int i=0; i<p; ++i){        if(dtos[i]==-1){            return true;        }    }     return false;}int main(){//    freopen("in.txt","r",stdin);    int Cases=1;        while(scanf("%d",&p)!=EOF){        if(p==0)            break;                memset(cnt,0,sizeof(cnt));        for(int i=0; i<p; ++i){            for(int j=0; j<p; ++j){                cnt[(i*j)/p]++;                cnt[(i*j)%p]++;            }        }         memset(incnt,0,sizeof(incnt));        for(int i=0; i<p; ++i){            for(int j=1; j<=p*2; ++j){                scanf("%d",&intab[i][j]);                incnt[intab[i][j]]++;            }        }        memset(stod,-1,sizeof(stod));        memset(dtos,-1,sizeof(dtos));        for(int i=0; i<p; ++i){            nums=0;            for(int j=0; j<p; ++j){                if(incnt[i]==cnt[j])                    nums++,id=j;            }            if(nums==1){                dtos[i]=id;                stod[id]=i;            }        }        while(find()){            for(int i=0; i<p; ++i){                if(dtos[i]!=-1)                    continue;                for(int j=1; j<2*p; j+=2){                    if(dtos[intab[i][j]]!=-1 && dtos[intab[i][j+1]]!=-1){                        nums=dtos[intab[i][j]]*p+dtos[intab[i][j+1]];                        if((j-1)/2==i && dtos[i]==-1){                            dtos[i]=(int)sqrt((double)nums);                            stod[dtos[i]]=i;                        }                         else if(dtos[(j-1)/2]>0){                            dtos[i]=nums/dtos[(j-1)/2];                            stod[dtos[i]]=i;                        }                    }                }            }        }        printf("Case #%d: %d",Cases,stod[0]);        Cases++;        for(int i=1; i<p; ++i){            printf(" %d",stod[i]);        }         printf("\n");    }    return 0;} Number Transformation（1008）Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 1395    Accepted Submission(s): 379Problem Description   Teacher Mai has an integer x.   He does the following operations k times. In the i-th operation, x becomes the least integer no less than x, which is the multiple of i.   He wants to know what is the number x now. Input   There are multiple test cases, terminated by a line "0 0".   For each test case, the only one line contains two integers x,k(1<=x<=10^10, 1<=k<=10^10). Output   For each test case, output one line "Case #k: x", where k is the case number counting from 1. Sample Input2520 102520 200 0 Sample OutputCase #1: 2520Case #2: 2600 这道题是说，有两个数x,k，REP(i,1,k)把x变成不小于x的最小的i的倍数关于这个操作啊，千万不能傻乎乎的每次都遍历哦，仔细想想看，这是不是这样一个过程呢——plus=kk-x%kk;x+=plus;接着，我们先把模拟代码写出来while(kk!=k){kk++;if(x%kk==0) continue;plus=kk-x%kk;cout<<kk<<":"<<plus<<endl;//if (plus==last)flag++;//else flag=0;//if(flag==10)//{//x+=plus*(k-kk+1);//break;//}x+=plus;last=plus;}然后随手写一点数看看，是不是到了最后都一样了哇？变着变着就等差数列了呢~ 我这里输出的是每次增加的值，所以我看到的是最后的输出的数字都一样了那么，我们只要判断啥时候一样了就可以直接乘了对不对？然后就是这个flag，大家都能看懂，连续flag个数相同我们就开始乘，那么flag是多少为好呢？ 我wa的两次是一次flag==3，一次flag==5，第三次AC是flag==10为啥小了不行呢？，因为咱仔细观察观察前面的plus的规律哦，是不是最终的公差是0，前面一点是2，在前面是4，然后6、8、10这样下去的呀？我们顺过来看的话，如果当前的plus小于公差，那么下一个数呢就是plus+下一个公差-当前公差——这样就有很大可能造成在公差小的时候出现abs（前一个plus公差-后一个plus公差）非0时也出错哦，所以flag大点好——#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))typedef long long ll;int main(){ll x,k,cnt=0;ll last=-1,plus,flag=0;while(scanf("%I64d%I64d",&x,&k)!=EOF){ll kk=1;cnt++;if(x==0 && k==0)return 0;if(x==1||x==2){printf("Case #%I64d: %I64d\n",cnt,k);continue;}while(kk!=k){kk++;if(x%kk==0) continue;plus=kk-x%kk;//cout<<kk<<":"<<plus<<endl;if (plus==last)flag++;else flag=0;if(flag==10){x+=plus*(k-kk+1);break;}x+=plus;last=plus;}printf("Case #%I64d: %I64d\n",cnt,x);}return 0;}然后说到这里啊，我就在想了……这个试验flag的方法会不会被人说咱是拼数据水过去的呢？那么，我们可以不用flag来试验，咱可以直接判定如果当前的abs为0即可对不对，嘛，先贴一个学长的1008Code：#include <iostream>#include <cstdio>#include <cstdlib>#include <cstring>#include <cmath>#include <algorithm>#include <string>#include <vector>#include <stack>#include <queue>#include <set>#include <time.h>using namespace std;const int maxint = -1u>>1;long long n,k;long long Cal(long long a,long long i){    if (a%i==0) return a;    return (a/i+1)*i;}long long pre[10];int main() {#ifndef ONLINE_JUDGE   freopen("f:/in.txt","r",stdin);#endif   int ca=0;   while (scanf("%I64d%I64d",&n,&k)!=EOF && (n!=0 || k!=0))   {       ca++;       long long ans=n;       long long pre4=-1;;       long long t=50000;       t=min(t,k);       memset(pre,-1,sizeof(pre));       for(long long i=1;i<=k;i++){                int f=0;                for(int j=0;j<9;j++){if (j>0 && (pre[j]!=pre[j+1] || pre[j+1]<0)) f=1; pre[j]=pre[j+1];}                pre[9]=ans;                ans=Cal(ans,i);                pre[9]=ans-pre[9];                if (f==0 && pre[8]==pre[9]){                    ans=ans+pre[9]*(k-i);                    break;                }       }       printf("Case #%d: %I64d\n",ca,ans);   }   return 0;}那么就先到这里吧~ 难得在MUTC上出题出到这么开心，就写一篇聊以记录一下～　Ｂｙｅ～版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/38451165	虽说还在Pending，但是已经万念俱灰了……已经知道了自己的C题PrePassed注定会变成SystemTestFailed了……因为先INT乘后LongLong强制转换一定会溢出……哭瞎……然后又犯了这个该死的错误……忘了注释掉freopen交了两发WA,反正这回死定了……A. Laptopstime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputOne day Dima and Alex had an argument about the price and quality of laptops. Dima thinks that the more expensive a laptop is, the better it is. Alex disagrees. Alex thinks that there are two laptops, such that the price of the first laptop is less (strictly smaller) than the price of the second laptop but the quality of the first laptop is higher (strictly greater) than the quality of the second laptop.Please, check the guess of Alex. You are given descriptions of n laptops. Determine whether two described above laptops exist.InputThe first line contains an integer n (1 ≤ n ≤ 105) — the number of laptops.Next n lines contain two integers each, ai and bi (1 ≤ ai, bi ≤ n), where ai is the price of the i-th laptop, and bi is the number that represents the quality of the i-th laptop (the larger the number is, the higher is the quality).All ai are distinct. All bi are distinct.OutputIf Alex is correct, print "Happy Alex", otherwise print "Poor Alex" (without the quotes).Sample test(s)input21 22 1outputHappy Alex这题是说，如果发现有两种电脑，便宜的性能更好则HA，否则PA那么我们就用pair存然后排序（我用的是优先队列自动维护顺序），然后遍历一遍，如果相邻的两个价格大的性能低则输出HA，遍历完都没有这种情况的话输出PACode：#include <cmath> #include <queue>#include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;int main(){int n;cin>>n;priority_queue <pair<int, int> > pq;  while(!pq.empty())pq.pop();for(int i=0;i<n;i++){int a,b;cin>>a>>b;pq.push(make_pair(a,b));}int la=-1,lb=-1,flag=0;while(!pq.empty()){pair<int,int> tmp=pq.top();pq.pop();//cout<<tmp.first<<"\t"<<tmp.second<<endl;if(la==-1 && lb==-1) la=tmp.first,lb=tmp.second;else{if(tmp.second>lb){flag=1;break;}lb=tmp.second;}}if(!flag)puts("Poor Alex");else puts("Happy Alex");return 0;}B. Fedya and Mathstime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputFedya studies in a gymnasium. Fedya's maths hometask is to calculate the following expression:(1n + 2n + 3n + 4n) mod 5for given value of n. Fedya managed to complete the task. Can you? Note that given number n can be extremely large (e.g. it can exceed any integer type of your programming language).InputThe single line contains a single integer n (0 ≤ n ≤ 10105). The number doesn't contain any leading zeroes.OutputPrint the value of the expression without leading zeros.Sample test(s)input4output4input124356983594583453458888889output0NoteOperation x mod y means taking remainder after division x by y.Note to the first sample:这题问(1^n+2^n+3^n+4^n)Mod 5是多少。n可以各种大。我们知道，1~4的n次幂mod5是有规律的：1) 1 1 1 12) 2 4 3 13) 3 4 2 14) 4 1 4 1Sum 0 0 0 4所以我们只需要知道这个好长好长的数字mod4是多少就行了，然而，一个数字mod4的话我们只需要判断后2位是否mod4=0即可。这里我用的是割位法，这个不只针对4，其他的数字也可以适用，较为普适的算法：（啊啊啊啊啊这里我freopen交了2发WA呀 啊啊啊啊啊）Code：#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>using namespace std;int main(){char c;int now = 0;//freopen("in.txt","r",stdin);while(1){if(scanf("%c",&c)==EOF)break;if(isdigit(c)){now=now*10 + (c-'0');now=now%4;}else break;}if(!now)cout<<"4";else cout<<"0";return 0;}C. Boredomtime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputAlex doesn't like boredom. That's why whenever he gets bored, he comes up with games. One long winter evening he came up with a game and decided to play it.Given a sequence a consisting of n integers. The player can make several steps. In a single step he can choose an element of the sequence (let's denote it ak) and delete it, at that all elements equal toak + 1 and ak - 1 also must be deleted from the sequence. That step brings ak points to the player.Alex is a perfectionist, so he decided to get as many points as possible. Help him.InputThe first line contains integer n (1 ≤ n ≤ 105) that shows how many numbers are in Alex's sequence.The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 105).OutputPrint a single integer — the maximum number of points that Alex can earn.Sample test(s)input21 2output2input31 2 3output4input91 2 1 3 2 2 2 2 3output10NoteConsider the third test example. At first step we need to choose any element equal to 2. After that step our sequence looks like this [2, 2, 2, 2]. Then we do 4 steps, on each step we choose any element equals to 2. In total we earn 10 points.哭瞎的一题……这题用dp做……首先读入，m[a]为a出现的个数，用a从大到小排序，cnt计数。那么—— REP （cnt，0，n）1）对于当前这个数a —— 如果a-1的数字没有出现过，那么dp[now]=dp[now-1]+a*m[a].（就是这里,要改成(long long)a*m[a]）2）当a-1出现过的话，dp[now]=max(dp[now-1],dp[now-2]+(long long)a*m[a])Ex) 既然有now-1.now-2，那么1、2要记得特判哦，免得RE了Code：#include <map>#include <cmath> #include <cctype>#include <cstdio>#include <string>#include <cstdlib>#include <cstring>#include <iostream>#include <algorithm>#define Max(a,b) ((a)>(b)?(a):(b))#define Min(a,b) ((a)<(b)?(a):(b))using namespace std;typedef long long ll;ll dp[100001];int main(){ll ans=0;int n;cin>>n;int tmp=0,max=0;map<int,int> m;m.clear();map<int,int>::key_compare kcm=m.key_comp();for(int nc=0;nc<n;nc++){scanf("%d",&tmp);if(max<tmp) max=tmp;m[tmp]++;}map<int,int>::iterator it=m.end();*it--;int cnt=0,lf,ls,nf,ns;for(;it!=m.begin();*it--,cnt++){//cout<<it->first<<":"<<it->second<<endl;nf=it->first,ns=it->second;if(cnt==0) dp[0]=(ll)nf*ns;else if(nf+1 < lf) dp[cnt]=dp[cnt-1]+(ll)nf*ns;else {if(cnt>1) dp[cnt]=Max(dp[cnt-1] , dp[cnt-2]+(ll)nf*ns);else dp[cnt]=Max(dp[cnt-1],(ll)nf*ns);}lf=nf,ls=ns;}//BEGIN FOGGOTTEN!//cout<<it->first<<":"<<it->second<<endl;nf=it->first,ns=it->second;if(nf+1 < lf) dp[cnt]=dp[cnt-1]+(ll)nf*ns;else {if(cnt>1) dp[cnt]=Max(dp[cnt-1] , dp[cnt-2]+(ll)nf*ns);else dp[cnt]=Max(dp[cnt-1],(ll)nf*ns);}//for(int i=0;i<=cnt;i++)cout<<dp[i]<<endl;cout<<dp[cnt];/*do{cout<<it->first<<":"<<it->second<<endl;} while (kcm((*it++).first, max) );*/return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/38445377	A. Wordtime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputVasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.InputThe first line contains a word s — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.OutputPrint the corrected word s. If the given word s has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.Sample test(s)inputHoUseoutputhouseinputViPoutputVIPinputmaTRIxoutputmatrix如果大写字符多就把字符串全大写，小写字符多或者大小写一样多就把字符串全都变小写for一次来遍历数数，再for一次输出即可。Code：#include <cstdio>#include <memory>#include <string>#include <cstring>#include <iostream>#include <algorithm>using namespace std;int main(){int u=0,l=0;string s;cin>>s;for(int i=0;i<s.length();i++)if(isupper(s[i])) u++;else l++;for(int i=0;i<s.length();i++)printf( "%c",((u>l) ? toupper(s[i]):tolower(s[i]) ) );return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/38445223	A. Chat roomtime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputVasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word s. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word "hello". For example, if Vasya types the word "ahhellllloou", it will be considered that he said hello, and if he types "hlelo", it will be considered that Vasya got misunderstood and he didn't manage to say hello. Determine whether Vasya managed to say hello by the given word s.InputThe first and only line contains the word s, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.OutputIf Vasya managed to say hello, print "YES", otherwise print "NO".Sample test(s)inputahhellllloououtputYESinputhlelooutputNO这道题，看完一遍题开始写，写完直接交了，一次都没有编译过……然后就A了抱歉……你不能怪我轻视你，真的是你太水……给一个字符串，问里面有没有hello这个子序列那么……模拟即可Code：#include <cstdio>#include <memory>#include <cstring>#include <iostream>#include <algorithm>using namespace std;int main(){int flag=0;string s;cin>>s;for(int i=0;i<s.length();i++){if(flag==0 && s[i]=='h')flag=1;else if(flag==1 && s[i]=='e')flag=2;else if(flag==2 && s[i]=='l')flag=3;else if(flag==3 && s[i]=='l')flag=4;else if(flag==4 && s[i]=='o')flag=5;}if(flag==5)cout<<"YES"<<endl;else cout<<"NO"<<endl;return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/38444841	A. Square Earth?time limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputMeg the Rabbit decided to do something nice, specifically — to determine the shortest distance between two points on the surface of our planet. But Meg... what can you say, she wants everything simple. So, she already regards our planet as a two-dimensional circle. No, wait, it's even worse — as a square of side n. Thus, the task has been reduced to finding the shortest path between two dots on a square (the path should go through the square sides). To simplify the task let us consider the vertices of the square to lie at points whose coordinates are: (0, 0), (n, 0), (0, n) and (n, n).InputThe single line contains 5 space-separated integers: n, x1, y1, x2, y2 (1 ≤ n ≤ 1000, 0 ≤ x1, y1, x2, y2 ≤ n) which correspondingly represent a side of the square, the coordinates of the first point and the coordinates of the second point. It is guaranteed that the points lie on the sides of the square.OutputYou must print on a single line the shortest distance between the points.Sample test(s)input2 0 0 1 0output1input2 0 1 2 1output4input100 0 0 100 100output200有一个n为边长的正方形边上有两个点，问只能走正方形边界的情况下最短路程是多长（顺时针A到B或者逆时针A到B咯~）。好吧……分情况讨论好了……我们把这个正方形从左下到右上分为两半，然后——1) 两个点在同侧的话，就坐标(x+y)的差即可，记住abs取绝对值2) 在不同侧的话，就两个方向看看哪个小咯~一侧为x1+y1+x2+y2,另一侧就直接正方形周长4n来减去前面那个就好。Code：#include <cstdio>#include <memory>#include <cstring>#include <iostream>#include <algorithm>using namespace std;int main(){int n,x1,y1,x2,y2;cin>>n>>x1>>y1>>x2>>y2;int len1=x1+y1,len2=x2+y2; //if((x1-y1)*(x2-y2)>=0) dist=abs(x1+y1-x2-y2); // 两点在 y=x 同侧 //else dist=x1+y1+x2+y2;// 两点在 y=x 异侧 int dist=abs( x1+y1-( (x1-y1)*(x2-y2)>=0 ? (x2+y2):(-x2-y2) ) );cout<<min(dist,4*n-dist)<<endl;return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/38443423	A. Bartime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputAccording to Berland laws it is only allowed to sell alcohol to people not younger than 18 years. Vasya's job is to monitor the law's enforcement. Tonight he entered a bar and saw n people sitting there. For every one of them Vasya happened to determine either the age or the drink the person is having. Vasya can check any person, i.e. learn his age and the drink he is having at the same time. What minimal number of people should Vasya check additionally to make sure that there are no clients under 18 having alcohol drinks?The list of all alcohol drinks in Berland is: ABSINTH, BEER, BRANDY, CHAMPAGNE, GIN, RUM, SAKE,TEQUILA, VODKA, WHISKEY, WINEInputThe first line contains an integer n (1 ≤ n ≤ 100) which is the number of the bar's clients. Then follown lines, each describing one visitor. A line either contains his age (an integer from 0 to 1000) or his drink (a string of capital Latin letters from 1 to 100 in length). It is guaranteed that the input data does not contain spaces and other unnecessary separators.Only the drinks from the list given above should be considered alcohol.OutputPrint a single number which is the number of people Vasya should check to guarantee the law enforcement.Sample test(s)input518VODKACOKE1917output2NoteIn the sample test the second and fifth clients should be checked.题目需要我们数出数字为18以下的，以及和已有字符串相同的个数有多少个。（年龄小于18、喝的饮料为酒精饮料的个数）混合输入处理，需要处理是数字还是字母的情况。我们需要的函数为isupper() \ islower() \ isdigit()这函数是通过ASCII码来判断某一个字符为大写字符、小写字符或数字的——Code：#include <cstdio>#include <memory>#include <cstring>#include <iostream>#include <algorithm>using namespace std;string name[11]={"ABSINTH","BEER","BRANDY","CHAMPAGNE","GIN","RUM","SAKE","TEQUILA","VODKA","WHISKEY","WINE"};int main(){int n,cnt=0;cin>>n;char huiche;scanf("%c",&huiche);for(int i=0;i<n;i++){string now;cin>>now;//cout<<now<<endl;if(isupper(now[0]) || islower(now[0])){for(int j=0;j<11;j++){if(now==name[j]){cnt++;//cout<<cnt<<":"<<now<<endl;break;}}}else if(isdigit(now[0])){int num=0;for(int j=0;j<now.length();j++) num=num*10+(now[j]-'0');if(num<18) {cnt++;//cout<<cnt<<":"<<now<<endl;}}} cout<<cnt<<endl;return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
http://blog.csdn.net/okcd00/article/details/38358295	这是我有史以来过的第一道最不明所以的D题我居然也能给这道题打上水题的标签……简直把自己帅到了~所以专门给这道题写一个题解：As you very well know, the whole Universe traditionally uses three-dimensional Cartesian system of coordinates. In this system each point corresponds to three real coordinates(x, y, z). In this coordinate system, the distance between the center of the Universe and the point is calculated by the following formula:. Mushroom scientists that work for the Great Mushroom King think that the Universe isn't exactly right and the distance from the center of the Universe to a point equalsxa·yb·zc.To test the metric of mushroom scientists, the usual scientists offered them a task: find suchx, y, z(0 ≤ x, y, z; x + y + z ≤ S), that the distance between the center of the Universe and the point(x, y, z) is maximum possible in the metric of mushroom scientists. The mushroom scientists aren't good at maths, so they commissioned you to do the task.Note that in this problem, it is considered that 00 = 1.InputThe first line contains a single integer S(1 ≤ S ≤ 103) — the maximum sum of coordinates of the sought point.The second line contains three space-separated integers a, b, c (0 ≤ a, b, c ≤ 103) — the numbers that describe the metric of mushroom scientists.OutputPrint three real numbers — the coordinates of the point that reaches maximum value in the metrics of mushroom scientists. If there are multiple answers, print any of them that meets the limitations.A natural logarithm of distance from the center of the Universe to the given point in the metric of mushroom scientists shouldn't differ from the natural logarithm of the maximum distance by more than10 - 6. We think thatln(0) =  - ∞.Sample test(s)Input31 1 1Output1.0 1.0 1.0Input32 0 0Output3.0 0.0 0.0我写的时候真心不知道这题题意是怎么个意思！！！有能三遍之内读懂的大神请让我膜拜下……当时我们几个人有几个不同的解释1）令这两个式子相等的，和不超过S的x,y,z分别为多少2）令第一个式子最大的，和不超过S的x,y,z分别为多少3）令第二个式子最大的，和不超过S的x,y,z分别为多少 （我是这个理解）4）令第二个式子的log值最大的，和不超过S的x,y,z分别为多少吾辈为了枚举题意，尝试了一发按照比例分配S的代码，过了你敢信？……如果a,b,c都为0，把S全都给a，然后bc为0，反之按比例给abc分配即可。实际上——若a,b,c中有一个为0，0的0次方为1，非0次方为0，那肯定得给他分配0啊。非零的情况下，当指数按照底数的比例分配的时候，可以获得最大的乘积，这个可以通过斜率啊、微分啊什么的都可以证明的出来Code：#include <cmath>#include <cstdio>#include <iostream>using namespace std;int main(){    int S,a,b,c;    cin>>S>>a>>b>>c;    if( a+b+c==0 ){ cout<<S<<" 0 0"; return 0;}    double x = double(a*S)/(a+b+c);    double y = double(b*S)/(a+b+c);double z = double(c*S)/(a+b+c);    printf("%.18lf %.18lf %.18lf", x, y, z);    return 0;}版权声明：本文为博主原创文章，未经博主允许不得转载。
